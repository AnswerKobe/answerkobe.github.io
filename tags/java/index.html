<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="upgrade-insecure-requests"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | Iverson's blog</title>
<meta name=keywords content><meta name=description content="Iverson's blog"><meta name=author content><link rel=canonical href=http://answerkobe.github.io/tags/java/><link crossorigin=anonymous href=/assets/css/stylesheet.81e9c84b86321fe9cfdf9f01a2f8060920d09e0fec45cb91f131cfed0284007e.css integrity="sha256-genIS4YyH+nP358BovgGCSDQng/sRcuR8THP7QKEAH4=" rel="preload stylesheet" as=style><link rel=icon href=http://answerkobe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://answerkobe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://answerkobe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://answerkobe.github.io/apple-touch-icon.png><link rel=mask-icon href=http://answerkobe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://answerkobe.github.io/tags/java/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4112QEXZJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4112QEXZJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Java"><meta property="og:description" content="Iverson's blog"><meta property="og:type" content="website"><meta property="og:url" content="http://answerkobe.github.io/tags/java/"><meta property="og:site_name" content="Iverson"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content="Iverson's blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://answerkobe.github.io/ accesskey=h title="Iverson's blog (Alt + H)">Iverson's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://answerkobe.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=http://answerkobe.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=http://answerkobe.github.io/profile title=Profile-X><span>Profile-X</span></a></li><li><a href=http://answerkobe.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://answerkobe.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://answerkobe.github.io/tags/>Tags</a></div><h1>Java</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>探索 Java & Kotlin 泛型</h2></header><div class=entry-content><p>Kotlin 泛型基础 泛型可以让我们在代码中声明类型参数，Kotlin 泛型最基本的使用和 Java 一样，可以声明在类上和函数上，用法也都差不多。
声明在函数上时，可将类型参数作为参数或返回值的类型，该函数为泛型函数 声明在类上时，可以用在任意一处类型声明处，该类为泛型类 class GenericsDemo&lt;T>(t: T) { val value = t } fun &lt;T> invoke(t: T) : T { return t } 我们可以在声明了类型参数的类中，声明一个泛型方法，但如果内部方法所声明的类型参数名称和类上所声明的相同，那么会覆盖类上所声明的类型参数。下面的代码不会报错，并会打印 Hello 字符串。
class GenericsDemo&lt;T>() { fun &lt;T> invoke(t: T) : T { return t } } val demo = GenericsDemo&lt;Int>() println(demo.invoke("Hello")) 此外，我们知道在类中可通过重载来定义同名方法，但这在泛型中并不起作用，如果类中拥有以下两个方法，那么将会报错。
class GenericsDemo&lt;T>() { // 泛型来自类 fun invoke(t: T) : T { return t } // 泛型来自方法本身 fun &lt;S> invoke(s: S) : S { return s } } 上诉代码报错原因是因为两个方法拥有相同的 signature，也就是在 JVM 看来这两个方法的方法名和参数都是一样的，报错信息如下：...</p></div><footer class=entry-footer><span title='2021-11-06 00:00:00 +0000 UTC'>November 6, 2021</span></footer><a class=entry-link aria-label="post link to 探索 Java & Kotlin 泛型" href=http://answerkobe.github.io/posts/explore-the-kotlin-generics/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>从源码角度分析 ThreadLocal 的使用</h2></header><div class=entry-content><p>Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。
// ThreadDemo.java static int v = 0; static void autoAdd(){ for (int i = 0; i &lt; 10000; i++) { v++; } } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); System.out.println(v); } 上面代码变量 v 的打印结果可能会小于 20000，随着 v 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。
要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。
局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。
虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。
ThreadLocal 的使用 ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。
ThreadLocal&lt;Integer> threadLocal = new ThreadLocal&lt;>(); System....</p></div><footer class=entry-footer><span title='2021-09-03 00:00:00 +0000 UTC'>September 3, 2021</span></footer><a class=entry-link aria-label="post link to 从源码角度分析 ThreadLocal 的使用" href=http://answerkobe.github.io/posts/threadlocal-usage-and-source/readme/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>基于 JDK 1.8 分析 HashMap 的底层原理</h2></header><div class=entry-content><p>Java 的 HashMap 可以说是用的最多、问的最多的一个 Map Collection 了。HashMap 是非同步的，即线程不安全。HashMap 允许存放的 key 为 null，但并不保证映射的顺序，也不保证这个顺序随时间保持不变。
本文对 HashMap 的代码分析基于 JDK 1.8
public class HashMap&lt;K,V> extends AbstractMap&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable 我们可以先从 HashMap 底层使用的数据结构了解 HashMap。
哈希表 + 链表 / 红黑树 static class Node&lt;K,V> implements Map.Entry&lt;K,V> { final int hash; final K key; V value; Node&lt;K,V> next; // ... } /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two....</p></div><footer class=entry-footer><span title='2021-05-31 00:00:00 +0000 UTC'>May 31, 2021</span></footer><a class=entry-link aria-label="post link to 基于 JDK 1.8 分析 HashMap 的底层原理" href=http://answerkobe.github.io/posts/the-principle-of-hashmap/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>被遗弃的 Vector 和 Stack</h2></header><div class=entry-content><p>在 Java Collections Framework 中有两个被遗弃的 List 实现类 —— Vector 和 Stack。
Vector 通过实现 AbstractList&lt;E> 接口来成为 Java Collections Framework List 接口的一员，而 Stack 直接继承于 Vector。
public class Vector&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, java.io.Serializable public class Stack&lt;E> extends Vector&lt;E> 与 ArrayList 类似的 Vector 如果希望了解 ArrayList 的底层结构可阅读另一篇文章 ArrayList 与 LinkedList 底层结构
与 ArrayList 一样，Vector 的底层结构也是 Object 数组 elementData，通过 elementCount 来表示 Vector 存储的元素个数，但与 ArrayList 不同的是，ArrayList 创建时不指定容器个数时，elementData 是一个长度为 0 的数组，只有在第一次添加元素的时候才会创建一个长度为 10 的数组，而 Vector 则是在构造方法中调用另一个构造方法直接为 elementData 创建一个长度为 10 的数组。...</p></div><footer class=entry-footer><span title='2021-04-27 00:00:00 +0000 UTC'>April 27, 2021</span></footer><a class=entry-link aria-label="post link to 被遗弃的 Vector 和 Stack" href=http://answerkobe.github.io/posts/vector-and-stack/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>ArrayList 与 LinkedList 底层结构</h2></header><div class=entry-content><p>在 Java 中，数组可用来存储相同类型的多个数据，但由于长度不可变，在某些场景下使用比较局限。当我们希望使用类似数组的结构来存储未知个数的元素时，可以使用 ArrayList&lt;E> 和 LinkedList&lt;E>，它们都是 Java Collection Framework 的成员，相比普通的数组，它们提供了更多的操作来方便我们开发。由于底层使用的数据结构不同，它们也经常被拿来做比较。
继承关系 ArrayList 属于 List&lt;E> 接口中的一个 可变长数组 实现，直接 extends AbstractList&lt;E> abstract 类。其继承关系如下：
public class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, java.io.Serializable LinkedList 直接 extends AbstractSequentialList&lt;E> abstract 类，间接 extends AbstractList&lt;E>，由于 LinkedList 也实现了 Deque&lt;E> 接口，所以它属于 List&lt;E> 和 Queue&lt;E> 接口的实现。
public class LinkedList&lt;E> extends AbstractSequentialList&lt;E> implements List&lt;E>, Deque&lt;E>, Cloneable, java.io.Serializable ArrayList 底层结构 对于 ArrayList，Java API 对它的第一句描述为 “Resizable-array implementation of the List interface”。其底层存储元素的结构为 Object 数组。...</p></div><footer class=entry-footer><span title='2021-04-24 00:00:00 +0000 UTC'>April 24, 2021</span></footer><a class=entry-link aria-label="post link to ArrayList 与 LinkedList 底层结构" href=http://answerkobe.github.io/posts/arraylist-and-linkedlist-principle/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>如何阅读 Java 字节码（Byte Code）</h2></header><div class=entry-content><p>字节码（Byte Code） 学习 Java 的都知道，我们所编写的 .java 代码文件通过编译将会生成 .class 文件，最初的方式就是通过 JDK 的 javac 指令来编译，再通过 java 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。
对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。
字节码文件结构 public class Hello { public static void main(String[] args) { int a = 1; int b = 1; int c = add(a, b); System....</p></div><footer class=entry-footer><span title='2021-03-07 00:00:00 +0000 UTC'>March 7, 2021</span></footer><a class=entry-link aria-label="post link to 如何阅读 Java 字节码（Byte Code）" href=http://answerkobe.github.io/posts/how-to-read-java-byte-code/></a></article></main><footer class=footer><span>&copy; 2023 <a href=http://answerkobe.github.io/>Iverson's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>