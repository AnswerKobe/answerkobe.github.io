[{"content":"机器学习（Machine Learning, ML） 在了解神经网络之前，我们需要先知道机器学习和神经网络之间的关系。\n机器学习是人工智能中的一个分支， 主要研究如何让计算机模拟人类的学习行为来获得知识和技能，在实践上就是通过让泛型算法（Generic Algorithm，和 C/C++ 中的泛型算法不是一个东西）自己在输入的数据上建立逻辑模型，并通过该模型来得到目标结论。\n泛型算法能处理的问题取决于我们所定义好的输入/输出的数据格式，而处理问题的条件和逻辑，则由泛型算法通过对输入数据进行分析学习构建处理逻辑参数，构建后的逻辑也能适应非预设数据的处理。神经网络属于机器学习泛型算法中的一种实现方案。\n根据泛型算法的学习方式，也可以将机器学习分为监督式学习、弱监督学习、半监督学习、非监督式学习、迁移学习、强化学习等。 人工智能中许多维度的分类都存在交叉关系，因此通常不会为任何一个方法论进行确切的归类。 神经网络结构 【概念】机器学习中的神经网络模型是一种模仿生物神经网络结构和功能的模型，因此也被称为人工神经网络或类神经网络。人工神经网络由多个人工神经元（处理单元）以及传递信号的链接形成拓扑结构，由于泛型算法能处理的问题取决于输入/输出的数据格式，因此神经网络基本会分为3个层：\nInput Layer：输入层，用于接收外界数据，节点数量根据输入的数据类型决定 Hidden Layer：隐含层，负责对输入层提供的数据进行信息处理、信息转化，通常这一层会有多个层次，每层会将处理结果向后面传递。 Output Layer：输出层，将隐含层提供的输出信息转化层最终结果，节点数量根据输出的结构类型决定 【生物知识点复习】生物神经元通常具有多个树突，树突用于接收信号，接收的信号在细胞体内整合产生阶梯性生电，而轴突用于传递信号，当细胞体的电位影响达到一定的阈值，则代表这个神经元被激活，激活的神经元会产生神经冲动（电脉冲），通过轴突传导出去，轴突尾端有许多和其他神经元树突产生连接的突触，电信号会通过这些突触传递给其他神经元，突触在一次突触事件中产生的电位幅度与突触的强度有关。\n人工神经元也是模拟生物神经元的结构和特性，下面是一个典型的人工神经元结构，以及人工神经元和生物神经元中各个行为的对照表。\n生物神经元 人工神经元 输入，即上一个神经元轴突传递过来的电信号 x𝑖 也就是下一个神经元的输出 y 突触强度 w𝑗 权重 树突接收到的电信号 x𝑖 * w𝑗 信号积累，阶段性生电 ∑(x𝑖 * w𝑗) 神经元激活 𝑓(·) 激活函数 轴突电信号传递 y 也就是下一个神经元的输入 x𝑖 线性回归 从上面的对照表可以看出，一个神经元对上一层的输入处理其实就是将各个输入值加权求和，本质上就是一个线性回归 𝑓(𝑥;𝑤) = 𝑤1𝑥1 + 𝑤2𝑥2 + ⋯ + 𝑤D𝑥D + 𝚋。线性回归模型是机器学习中最基础最广泛的模型，主要用于分析自变量和因变量之间的关系。 为什么使用的是线性回归呢？ 线性回归可以用来描述自变量和因变量之间的关系，机器学习中大部分问题都是分析数据里特征的关系来建立模型，因此在机器学习中很多问题都可以转换为线性回归问题来处理。 例如我们有如下左图关于面积和房价关系的数据，那么可以用一个一元线性回归模型来拟合这些数据，从而得到一个可以根据面积来预估房价的模型。当房屋特征变多时，也可以根据回归函数的参数建立一个没有 Hidden Layer 的神经网络。\n面积和房价的线性拟合 多个房屋特征的神经网络 有时候特征向量与因变量并不是简单的线性关系，例如我们给的不是面积，而是房子的长宽，那么将会存在特征之间相乘的计算逻辑。或者有时候特征向量之间可能也存在关系，例如加上时间维度来预测未来的房价，那么其他特征带来的效果可能会跟着时间变化发生变化。如果我们在各个线性回归的关系上再次建立回归模型，那么工作量和计算量将会特别高，但多层的神经网络来处理这个问题就非常方便。\n神经网络本身是由许多节点组成的，每个节点的输入输出都可以认为是一次线性转化，因此可以认为神经网络会将问题分为多个子问题来处理，不同纬度的问题会被分到各个层级，同一纬度的子问题会被分到各个神经元。每个神经元利用线性回归来对输入数据的特征进行线性转换（这个过程也称为特征提取），将子问题分析结果反馈给下一层级（父问题）继续处理。\n没有 Hidden Layer 的神经网络只能用于表示线性回归函数，但多层的网络则可以在线性回归上建立更高纬度的模型。下面是 The Number of Hidden Layers 中总结的常见层数体系结构的功能：\nThe Number of Hidden Layers Feature 没有隐含层 仅能够表示线性可分函数或决策 隐含层数=1 可以拟合任何“包含从一个有限空间到另一个有限空间的连续映射”的函数 隐含层数=2 搭配适当的激活函数可以表示任意精度的任意决策边界，并且可以拟合任何精度的任何平滑映射 隐含层数\u0026gt;2 多出来的隐藏层可以学习复杂的描述 层数越深，理论上拟合函数的能力增强，效果按理说会更好，但是实际上更深的层数可能会带来过拟合的问题，同时也会增加训练难度，使模型难以收敛。\n这时我们可以通过增加隐含层层数来增加模型的数据处理维度，以处理更加复杂的房价关系问题。\n在分类问题中，线性回归也可以用来作为判别函数，例如有一个 𝑓(𝑥;𝑤)= 𝒘T𝒙 + 𝚋 将特征空间中满足线性判别函数 y=0 的点组成一个决策边界，将特征空间分为两个区域，每个区域对应一个类别，下图是二分类的例子。\n当分类问题是类别数C大于2的多分类问题时，一般需要通过“一对其余”、“一对一”或“argmax”方式来设计多个线性判别函数。\n激活函数 如果神经网络每一层都只是接收上一层输入函数的线性变化，那么无论神经网络模型多复杂最终输出也是线性组合，纯粹的线性组合并不能解决更复杂的问题。\n例如我们知道房价不会为负数，也就是房价预估的输出实际上不是一个线性回归问题，上面的线性回归函数只是满足了我们对数据的拟合，函数计算值并不能作为最后的结果输出。因此在人工神经元进行线性转换后，需要再作用于另一个函数，也就是激活函数。\n激活函数可以分为线性激活函数（例如 𝑓(x)=x），以及非线性激活函数。由于神经元对输入数据的处理本身就是进行线性转换，因此为了增加网络的表达能力，激活函数一般使用的是非线性激活函数。\n激活函数一般需要具备以下几点特性：\n连续并且可导出（允许少数点上不可导），可导的激活函数 可以直接利用数值优化的方法来学习网络参数 激活函数及其导函数要尽可能简单，有利于提高网络计算效率 激活函数的导函数的值域要在一个合适的区间，区间大小会影响训练的效率和稳定性 常用的激活函数有 ReLU、Sigmoid、Tanh、Softmax 等。\n以线性修正函数（Rectified Linear Unit, ReLU）为例，当 x 大于 0 时，输出 x 的值，当 x 小于等于 0 时，输出 0，其表达式如下\nimport matplotlib.pyplot as plt import numpy as np rule = lambda z: np.maximum(0, z) start = -10 stop = 10 step = 0.1 num = (stop - start) / step x = np.linspace(start, stop, int(num)) y = rule(x) plt.plot(x, y, label=\u0026#39;ReLU\u0026#39;) plt.grid(True) plt.legend() plt.show() 例如当我们把 ReLU 应用到房屋预测模型的神经元中，那么将会得到下面的逻辑回归模型。\n逻辑回归 逻辑回归（Logistic Regression）是线形回归中使用 Sigmoid 作为激活函数的线性模型。常用与处理二分类问题。线形回归在二分类中只能拟合出一个决策边界，分类问题最终需要根据这个决策边界来得到最终类别结果。\n二分类中使用逻辑回归的表达式为\nimport matplotlib.pyplot as plt import numpy as np sigmoid = lambda z: 1 / (1 + np.exp(-z)) start = -10 stop = 10 step = 0.01 num = (stop - start) / step x = np.linspace(start, stop, int(num)) y = sigmoid(x) plt.plot(x, y, label=\u0026#39;Sigmoid\u0026#39;) plt.grid(True) plt.legend() plt.show() 为什么选择 Sigmoid 作为逻辑回归的激活函数可以看【参考5】的文章\nLogistic 回归可以看作预测值为“标签的对数几率”的线性回归模型．因此， Logistic回归也称为对数几率回归（Logit Regression）。\n一维数据二分类（图来自神经网络与深度学习）\n二维数据二分类\n多分类问题中使用的是 softmax 函数\n前馈神经网络 前馈神经网络模型是神经网络中最简单最基础的模型，本文许多知识点都是以前馈神经网络为基础来讲解。前馈神经网络每层的每个节点，都会和上一层/下一层的所有节点建立连接，该层为全连接层，所有层次都是全连接层的网络也称为全连接网络。\n实际上网络可以根据不同特征之间的关系来建立对应的连接，并不需要全部连接在一起，但这会增加许多模型结构建立的人为工作量。\n全连接网络在训练的过程中，那些不需要的连接权重会被置 0（或接近0），此时可以认为两个节点之间是没有连接关系的，这样我们就不需要再去关心那些节点应该连接起来了。\n损失函数 对于单个神经元来说，需要确定的参数就是权重 _ω_j 的值，所有神经元之间连接的权重组成权重矩阵，权重矩阵大幅决定了模型最终输出结果的准确性，在机器学习中，会使用损失函数来评估一个模型的好坏。\n损失函数（误差函数、代价函数，Cost Function / Loss function）用于衡量模型的预测值 𝑓(x) 和预期值 y 的不一致程度，它是一个非负实值函数，损失函数在测试数据上输出的值越小，可以认为模型的准确度越高。\n模型训练最终目的就是得到最佳的权重，使损失函数在测试数据上的值最小。\n损失函数有多种，例如线性回归经常使用的平方损失。\n对于线性回归函数，我们可以使用最小二乘法则来得到各个权重最佳值，最小二乘法的公式如下，其中 𝜃 代表权重矩阵，通过损失函数对 𝜃 求导取 0 从而得到最优 𝜃。\n使用最小二乘法则的使用需要考虑下面两个问题：\n需要计算逆矩阵，时间复杂度为 O(n^3)，当特征数变多时将会非常耗时 需要 XTX 可逆，当训练样本数小于特征数，或者特征之间存在线性关系，那么 XTX 将不可逆 最小二乘法只适用于线性模型 对于神经网络而言，由于上面的问题，一般并不推荐使用最小二乘法则来计算神经网络的权重矩阵。 我们可以将权重矩阵的计算问题，转化为损失函数的优化问题，使用最优化方法来优化损失函数的输出，得到目标权重矩阵。\n梯度下降 梯度下降算法（Gradient Descent）属于最优化方法的一种，由于它的时间复杂度和初始要求都比较低，相对其他最优化方法，更加适合神经网络这种特征维度大的场景。\n梯度下降算法的思路是，先给所有权重一个初始值，每次迭代时更新权重，使损失函数的值往期望的方向变化。 就像一个人在下山，会根据当前位置，往低的地方迈出一步，最终到局部最低点。\nfrom matplotlib import pyplot, cm import numpy as np fig = pyplot.figure() axes = pyplot.axes(projection=\u0026#39;3d\u0026#39;) xx = np.arange(-10,10,0.1) yy = np.arange(-10,10,0.1) X, Y = np.meshgrid(xx, yy) Z = X**2+Y**2+10 axes.plot_surface(X,Y,Z,alpha=0.9,cmap=cm.coolwarm) axes.contour(X,Y,Z,zdir=\u0026#39;z\u0026#39;, offset=-5,cmap=\u0026#34;rainbow\u0026#34;) axes.set_xlabel(\u0026#39;w1\u0026#39;) axes.set_xlim(-9, 9) axes.set_ylabel(\u0026#39;w2\u0026#39;) axes.set_ylim(-9, 9) axes.set_zlabel(\u0026#39;cost\u0026#39;) axes.set_zlim(-5, 200) pyplot.show() 梯度下降算法中，每次迭代更新时所有权重要一起更新，从而达到整体位置的向下偏移，每个权重的更新公式如下，其中：\n:=号为赋值符号 𝜔𝑗 为进行更新的权重 𝛼 为学习速率，该值应当大于 0 后面那部分为损失函数的偏导数，也就是损失函数在 𝜔𝑗 方向的斜率 当损失函数在 𝜔𝑗 方向的斜率是负数时， 𝜔𝑗 减去一个负数， 𝜔𝑗 变大 当损失函数在 𝜔𝑗 方向的斜率是正数时， 𝜔𝑗 减去一个正数， 𝜔𝑗 变小 无论是偏导数是正数还是负数，𝜔𝑗 损失函数总会向着 0 值的方向变化，最终接近 𝜔𝑗 的局部最优解。\nfrom matplotlib import pyplot import numpy as np fig = pyplot.figure() X = np.arange(-10,10,0.1) Y = X**2 pyplot.plot(X, Y) pyplot.xlabel(\u0026#34;w\u0026#34;) pyplot.ylabel(\u0026#34;cost\u0026#34;) pyplot.ylim(0, 100) pyplot.ylim(0, 100) pyplot.xticks([]) pyplot.yticks([]) pyplot.show() 学习速率 学习速率 𝛼 决定了梯度下降每次迭代时，权重 𝜔𝑗 的更新距离，也可以称为单次训练的步长。\n当 𝛼 太小时，每次迭代带来的下降值也会非常小，这意味着需要迭代更多次数才能到达局部最优解。\n当 𝛼 太大时，每次迭代权重 𝜔𝑗 的变化也会很大，这可能出现两个问题：\n损失函数导数变小，但接近最小值时发生震荡，无法收敛 损失函数导数变大，学习速率不变，结果发散 为了解决学习速率的问题，目前也有很多对学习速率进行改良的梯度下降算法：\nAdaGrad：每次迭代时，学习速率根据梯度平方积累值的增加逐渐衰减 RMSprop：AdaGrad 优化版，在衰减过程中进行加权移动 Monmentum：基于物理加速度和阻力的思路，更新参数时加上一个冲量，当冲量和梯度方向相同时冲量会增加，相反时冲量会减少 Adam：自适应矩估计，Monmentum + RMSprop 的结合体 非凸函数 上面提到的权重矩阵求解都是指局部最优解。拟合函数并不总是像上面的图一样，是一个弓形的函数（凸函数），当集合里面任意两个点的连线都在落集合里面，否则则认为是非凸问题。\n机器学习中许多问题属于非凸问题，非凸优化问题可能存在多个局部最优解，因此使用梯度下降算法得到的不一定是全局最优解，这与初始权重使损失函数值落在哪一点有关系。\n小批量梯度下降 批量梯度下降（Batch Gradient Descent, BGD）\nBGD 是训练时，采用整个样本来优化算法。BGD 虽然迭代次数能相对比较少，但一次迭代都要遍历所有样本，需要大量的时间，并且更新在所有样本遍历完才发生，在全连接网络中多余的参数更新也会被计算进去。\n随机梯度下降（Stochastic Gradient Descent, SGD）\n每次迭代使用一个样本来更新参数。SGD 相比 BGD 会多出噪声，提高了泛化误差，但学习过程较慢，遇到局部极小或鞍点容易卡在梯度 0 的地方。现在的 SGD** **更多指的是小批量随机梯度下降，下文也一样。\n小批量梯度下降（Min-batch Gradient Descent, MBGD）\nBGD 和 SGD 的结合，即每次迭代从打乱的训练集中随机抽取一小批数据样本来更新。\n反向传播算法 由于神经网络模型的误差计算在输出层，因此使用梯度下降算法来训练时，隐含层没办法直接获得误差来更新参数。这时可以通过反向传播算法来将误差传递给上一层来更新权重。\n反向传播算法（Back Propagation, BP）是一个和其他最优化方法结合更新神经网络参数的方法，其的思路是，当前节点计算出来的结果与预期值的误差，和上一层节点的输入有关，上层各节点的输入对误差带来的影响应该是不同的，因此需要合理地将误差分配给上层的神经元，控制上层权重变化比例来更快的降低代价。\n反向传播算法和梯度下降结合使用时，可以直接计算权重相对于最终输出（损失）的梯度，不用计算隐藏层值相对于权重变化的导数。\n反向传播的公式推导并不容易，我们先直接记下公式\n使用反向传播算法的神经网络训练流程如下：\n从训练集里随机获取一个/批训练样本 前馈计算每层的净输入和激活值，直到最后一层 使用公式 1 计算输出值和预期值的误差 使用公式 2 反向传播计算每一层的误差值 使用公式 3 和 4 更新权重参数和偏置量 回到 1 进行下一次迭代 到这里，一个基础的前馈神经网络模型的输出和训练流程都讲到了，下面可以开始动手写代码了。\n代码实践 本次代码实践使用手写图片识别作为的例子，因为有开放的数据集，并且手写时模型结构也可以定义的比较简单。\n手写图片的数据集可以从 MNIST 官网下载，为了方便，我们使用 TrochVision 来获取 MNIST 数据集，它会自动帮我们下载 MNIST 数据集并解压，获取时也会提供了对应的数据转换。\n这里会再使用一个 numpy 的库，这个库可以帮助我们完成一些复杂的矩阵计算。\nimport numpy as np import torchvision torchvision.datasets.MNIST(root=\u0026#39;data/\u0026#39;, train=True, download=True) 首先我们先来看看 MNIST 数据长什么样。\nMNIST 数据集为 0～9 的手写数字图片，有 60000 张训练样本，还有 10000 张测试样本，每张图片的分辨率为 28 * 28。 我们可以定义 28 * 28 = 784 个节点的输入层，使用 10 个节点的输出层，每个节点输出代表 0～9 各数字的决策值，输出 1 时代表为该数字。\n定义模型结构 手写图片识别属于分类问题，因此我们可以采用逻辑回归，先定义 Sigmoid 激活函数以及其导数形式\nsigmoid = lambda z: 1 / (1 + np.exp(-z)) derivative_sigmoid = lambda z: sigmoid(z) * (1 - sigmoid(z)) 图片特征提取属于高维度的回归问题，二维矩阵 + 矩阵特征转换，因此可以定义一个 3 层的神经网络（1层输入，2层隐含，1层输出）。训练方式使用 MBGD 算法 + BP 算法。因此我们可以简单地定义下面的的模型结构。\nclass NeuralNetwork(object): def __init__(self, l0, l1, l2, l3, batch_size=6): \u0026#34;\u0026#34;\u0026#34; 初始化神经网络 :param l0: 输入层节点数 :param l1: 隐含层 l1 节点数 :param l2: 隐含层 l2 节点数 :param l3: 输出层节点数量 :param batch_size: 单次训练批次数据量 \u0026#34;\u0026#34;\u0026#34; self.lr = 0.5 # 学习率 self.batch_size = batch_size # 各层权重与偏置量 self.w1 = np.random.randn(l0, l1) * 0.01 self.b1 = np.random.randn(l1) * 0.01 self.w2 = np.random.randn(l1, l2) * 0.01 self.b2 = np.random.randn(l2) * 0.01 self.w3 = np.random.randn(l2, l3) * 0.01 self.b3 = np.random.randn(l3) * 0.01 算法实现 定义了模型的结构，接下来就是前馈传播和反向传播算法的实现了，由于反向传播算法需要使用到各层在前馈时的净输入和激活值，因此前馈方法会将这些数据返回，用于反向传播。\n只需要使用代码将数据代入上面提到的公式，因此实现起来很简单。\n# in NeuralNetwork def forward(self, x): \u0026#34;\u0026#34;\u0026#34; 向前传播推导结果 :param x: 输入的 [784] 向量矩阵 :return: 输出各层的净输入和激活值 \u0026#34;\u0026#34;\u0026#34; z1 = np.dot(x, self.w1) + self.b1 o1 = sigmoid(z1) z2 = np.dot(o1, self.w2) + self.b2 o2 = sigmoid(z2) z3 = np.dot(o2, self.w3) + self.b3 o3 = sigmoid(z3) return z1, o1, z2, o2, z3, o3 # in NeuralNetwork def backward(self, x, z1, o1, z2, o2, err3): \u0026#34;\u0026#34;\u0026#34; 反向传播更新权重 \u0026#34;\u0026#34;\u0026#34; dot_w3 = np.dot(o2.T, err3) / self.batch_size dot_b3 = np.sum(err3, axis=0) / self.batch_size err2 = np.dot(err3, self.w3.T) * derivative_sigmoid(z2) dot_w2 = np.dot(o1.T, err2) / self.batch_size dot_b2 = np.sum(err2, axis=0) / self.batch_size err1 = np.dot(err2, self.w2.T) * derivative_sigmoid(z1) dot_w1 = np.dot(x.T, err1) / self.batch_size dot_b1 = np.sum(err1, axis=0) / self.batch_size self.w3 -= self.lr * dot_w3 self.b3 -= self.lr * dot_b3 self.w2 -= self.lr * dot_w2 self.b2 -= self.lr * dot_b2 self.w1 -= self.lr * dot_w1 self.b1 -= self.lr * dot_b1 训练与测试 最后编写训练和测试的方法，测试时使用完成训练的模型。由于我们采用小批次梯度，因此取数据时需要按照每个批次的数据量来取。另外一次样本的遍历可能不足以让模型得到很好的效果，因此我们可以进行多次全样本的训练。训练时我们也可以计算一下当前批次的损失，来观察模型的拟合情况。\n测试时采用一次性计算，得到所有测试数据的结果矩阵，对预测结果获取最大值索引，也就是单个样本预测结果为 1 的位置，该位置为样本的预测结果数值，最后计算样本预测值和预期值的匹配数量，来得到准确率。\ndef train(nn, data, targets): for cou in range(10): for i in range(0, 60000, nn.batch_size): x = data[i:i + nn.batch_size] y = targets[i:i + nn.batch_size] z1, o1, z2, o2, z3, o3 = nn.forward(x) err3 = (o3 - y) * derivative_sigmoid(z3) loss = np.sum((o3 - y) * (o3 - y)) / nn.batch_size print(\u0026#34;cou:\u0026#34; + str(cou) + \u0026#34;, err:\u0026#34; + str(loss)) nn.backward(x, z1, o1, z2, o2, err3) def test(nn, data, targets): _, _, _, _, _, o3 = nn.forward(data) result = np.argmax(o3, axis=1) precision = np.sum(result == targets) / 10000 print(\u0026#34;Precision:\u0026#34;, precision) 数据预处理 在获取数据时，我们需要先将图片二维的像素数据平铺成一维矩阵，将对应的数字标签 0～9 转换成 1 维矩阵的输出，例如 3 转换为 [0, 0, 0, 1, 0, 0, 0, 0, 0, 0]。由于测试数据的标签不需要参与反向传播，我们不做矩阵转换，这样可以方便我们对预测结果做计算。\ndef target_matrix(targets): \u0026#34;\u0026#34;\u0026#34; 数字标签转换 :param targets: 对于的数字标签矩阵 :return: \u0026#34;\u0026#34;\u0026#34; num = len(targets) result = np.zeros((num, 10)) for i in range(num): result[i][targets[i]] = 1 return result # 训练数据 def load_train_data(): train_data = torchvision.datasets.MNIST(root=\u0026#39;data/\u0026#39;, train=True, download=True) # Numpy 矩阵转换 train_data.data = train_data.data.numpy() # [60000,28,28] train_data.targets = train_data.targets.numpy() # [60000] # 输入向量处理，将二维数据平铺 train_data.data = train_data.data.reshape(60000, 28 * 28) / 255. # (60000, 784) # 标签转换 train_data.targets = target_matrix(train_data.targets) # (60000, 10) return train_data # 测试数据 def load_test_data(): test_data = torchvision.datasets.MNIST(root=\u0026#39;data/\u0026#39;, train=False) test_data.data = test_data.data.numpy() # [10000,28,28] test_data.targets = test_data.targets.numpy() # [10000] test_data.data = test_data.data.reshape(10000, 28 * 28) / 255. # (10000, 784) return test_data 最后把上面的步骤组织起来\ndef demo(): nn = NeuralNetwork(784, 200, 30, 10) train_data = load_train_data() train(nn, train_data.data, train_data.targets) test_data = load_test_data() test(nn, test_data.data, test_data.targets) demo() 最终测试结果 Precision: 0.9686，即准确率有 96%。\n代码地址：https://github.com/korilin/neural_network_tech_sharing\n其他网络模型设计 除了前馈神经网络外，神经网络的节点类型还有很多，不同模型的训练/处理消耗的资源，以及应用场景也不一样。\n深度神经网络 在机器学习中有一个深度学习话题，在神经网络中，深度学习体现在网络隐含层数量，层数多的网络称为深度神经网络（DNN），像深度残差学习网络最多能有 152 层，但随着网络增加训练难度也非常大。\n卷积神经网络 卷积神经网络（CNN）也是比较常用的网络结构，CNN 在图片识别上有非常理想的效果，许多图片、视频的识别/分类模型都采用了 CNN 的思想。\nCNN 的核心为卷积核，在图像中有着颜色通道，局部特征等特有特性，这些特征的特点来自相邻像素的关联性，通常这些特征在局部或整体上会给人带来不同的感受。因此出现了采用卷积来提取局部特征的方式，在数学算子上卷积是通过两个函数生成第三个函数，表征函数 f 与经过翻转和平移的 g 的乘积函数所围成的曲边梯形的面积。函数 g 在卷积神经网络中也称为滤波器。\n循环神经网络 在普通神经网络和 CNN 中，每层神经元的信号只能向上层传播，但这样对时间序列上的变化进行建模会比较困难，循环神经网络（RNN）就是为了适应这种需求出现的。 RNN 中的神经元的输出可以在下一个时间戳中直接作用到自身，也就是每个神经元的输入，出了上一层的输入外，还结合了神经元自身的上一次输入，用图表示如下 生成对抗网络 生成对抗网络（GAN）属于生成模型的一种，由一个生成网络和一个判别网络组成。 生成网络模仿真实样本生成假数据来给判别网络识别，判别网络则识别输入数据为真实样本还是生成网络生成的假数据。两个网络之间通过相互对抗和参数调整，最终使得判别网络无法判断生成网络的输出是否为真实数据。 GAN 是非监督式学习的一种，但实际上在半监督、强化学习中也有效果。 GAN 还有一个变体 DCGAN，由于 CNN 中卷积核对图片特征的提取具有非常好的效果，因此 DCGAN 中使用了反卷积来对特征进行反推，来对特征进行更好转换输出。\n参考 机器学习算法（一）：逻辑回归模型（Logistic Regression, LR）_意念回复的博客-CSDN博客 神经网络与深度学习 The Number of Hidden Layers 深度学习笔记：如何理解激活函数？（附常用激活函数） 机器学习之Logistic回归激活函数为什么是Sigmoid？_logistic回归的激活函数_MuBaicao的博客-CSDN博客 常见的几种最优化方法（梯度下降法、牛顿法、拟牛顿法、共轭梯度法等） - 蓝鲸王子 - 博客园 卷积神经网络中二维卷积核与三维卷积核有什么区别？_3d卷积和2d卷积区别_意念回复的博客-CSDN博客 生成模型（Generative）和判别模型（Discriminative）_生成模型和判别模型_意念回复的博客-CSDN博客 CNN（卷积神经网络）、RNN（循环神经网络）、DNN（深度神经网络）的内部网络结构有什么区别？ - 知乎 ","permalink":"http://answerkobe.github.io/posts/basic-theory-and-simple-practice-of-neural-network/","summary":"机器学习（Machine Learning, ML） 在了解神经网络之前，我们需要先知道机器学习和神经网络之间的关系。\n机器学习是人工智能中的一个分支， 主要研究如何让计算机模拟人类的学习行为来获得知识和技能，在实践上就是通过让泛型算法（Generic Algorithm，和 C/C++ 中的泛型算法不是一个东西）自己在输入的数据上建立逻辑模型，并通过该模型来得到目标结论。\n泛型算法能处理的问题取决于我们所定义好的输入/输出的数据格式，而处理问题的条件和逻辑，则由泛型算法通过对输入数据进行分析学习构建处理逻辑参数，构建后的逻辑也能适应非预设数据的处理。神经网络属于机器学习泛型算法中的一种实现方案。\n根据泛型算法的学习方式，也可以将机器学习分为监督式学习、弱监督学习、半监督学习、非监督式学习、迁移学习、强化学习等。 人工智能中许多维度的分类都存在交叉关系，因此通常不会为任何一个方法论进行确切的归类。 神经网络结构 【概念】机器学习中的神经网络模型是一种模仿生物神经网络结构和功能的模型，因此也被称为人工神经网络或类神经网络。人工神经网络由多个人工神经元（处理单元）以及传递信号的链接形成拓扑结构，由于泛型算法能处理的问题取决于输入/输出的数据格式，因此神经网络基本会分为3个层：\nInput Layer：输入层，用于接收外界数据，节点数量根据输入的数据类型决定 Hidden Layer：隐含层，负责对输入层提供的数据进行信息处理、信息转化，通常这一层会有多个层次，每层会将处理结果向后面传递。 Output Layer：输出层，将隐含层提供的输出信息转化层最终结果，节点数量根据输出的结构类型决定 【生物知识点复习】生物神经元通常具有多个树突，树突用于接收信号，接收的信号在细胞体内整合产生阶梯性生电，而轴突用于传递信号，当细胞体的电位影响达到一定的阈值，则代表这个神经元被激活，激活的神经元会产生神经冲动（电脉冲），通过轴突传导出去，轴突尾端有许多和其他神经元树突产生连接的突触，电信号会通过这些突触传递给其他神经元，突触在一次突触事件中产生的电位幅度与突触的强度有关。\n人工神经元也是模拟生物神经元的结构和特性，下面是一个典型的人工神经元结构，以及人工神经元和生物神经元中各个行为的对照表。\n生物神经元 人工神经元 输入，即上一个神经元轴突传递过来的电信号 x𝑖 也就是下一个神经元的输出 y 突触强度 w𝑗 权重 树突接收到的电信号 x𝑖 * w𝑗 信号积累，阶段性生电 ∑(x𝑖 * w𝑗) 神经元激活 𝑓(·) 激活函数 轴突电信号传递 y 也就是下一个神经元的输入 x𝑖 线性回归 从上面的对照表可以看出，一个神经元对上一层的输入处理其实就是将各个输入值加权求和，本质上就是一个线性回归 𝑓(𝑥;𝑤) = 𝑤1𝑥1 + 𝑤2𝑥2 + ⋯ + 𝑤D𝑥D + 𝚋。线性回归模型是机器学习中最基础最广泛的模型，主要用于分析自变量和因变量之间的关系。 为什么使用的是线性回归呢？ 线性回归可以用来描述自变量和因变量之间的关系，机器学习中大部分问题都是分析数据里特征的关系来建立模型，因此在机器学习中很多问题都可以转换为线性回归问题来处理。 例如我们有如下左图关于面积和房价关系的数据，那么可以用一个一元线性回归模型来拟合这些数据，从而得到一个可以根据面积来预估房价的模型。当房屋特征变多时，也可以根据回归函数的参数建立一个没有 Hidden Layer 的神经网络。\n面积和房价的线性拟合 多个房屋特征的神经网络 有时候特征向量与因变量并不是简单的线性关系，例如我们给的不是面积，而是房子的长宽，那么将会存在特征之间相乘的计算逻辑。或者有时候特征向量之间可能也存在关系，例如加上时间维度来预测未来的房价，那么其他特征带来的效果可能会跟着时间变化发生变化。如果我们在各个线性回归的关系上再次建立回归模型，那么工作量和计算量将会特别高，但多层的神经网络来处理这个问题就非常方便。\n神经网络本身是由许多节点组成的，每个节点的输入输出都可以认为是一次线性转化，因此可以认为神经网络会将问题分为多个子问题来处理，不同纬度的问题会被分到各个层级，同一纬度的子问题会被分到各个神经元。每个神经元利用线性回归来对输入数据的特征进行线性转换（这个过程也称为特征提取），将子问题分析结果反馈给下一层级（父问题）继续处理。\n没有 Hidden Layer 的神经网络只能用于表示线性回归函数，但多层的网络则可以在线性回归上建立更高纬度的模型。下面是 The Number of Hidden Layers 中总结的常见层数体系结构的功能：","title":"神经网络基础理论与简单实践"},{"content":"黑马设计模式精讲 1，设计模式概述 1.1 软件设计模式的产生背景 \u0026ldquo;设计模式\u0026quot;最初并不是出现在软件设计中，而是被用于建筑领域的设计中。\n1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。\n1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。\n1.2 软件设计模式的概念 软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。\n1.3 学习设计模式的必要性 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。\n正确使用设计模式具有以下优点。\n可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 1.4 设计模式分类 创建型模式\n用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。\n结构型模式\n用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。\n行为型模式\n用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。\n2，UML图 统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。\nUML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。\n2.1 类图概述 类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。\n2.2 类图的作用 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解； 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。 2.3 类图表示法 2.3.1 类的表示方式 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。\n属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：\n+：表示public\n-：表示private\n#：表示protected\n属性的完整表示方式是： 可见性 名称 ：类型 [ = 缺省值]\n方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型]\n注意：\n​\t1，中括号中的内容表示是可选的\n​\t2，也有将类型放在变量名前面，返回值类型放在方法名前面\n举个栗子：\n上图Demo类定义了三个方法：\nmethod()方法：修饰符为public，没有参数，没有返回值。 method1()方法：修饰符为private，没有参数，返回值类型为String。 method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。 2.3.2 类与类之间关系的表示方式 2.3.2.1 关联关系 关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。\n关联又可以分为单向关联，双向关联，自关联。\n1，单向关联\n在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。\n2，双向关联\n从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。\n在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List\u0026lt;Product\u0026gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。\n3，自关联\n自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。\n2.3.2.2 聚合关系 聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。\n聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\n在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：\n2.3.2.3 组合关系 组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。\n在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\n在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：\n2.3.2.4 依赖关系 依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\n在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：\n2.3.2.5 继承关系 继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。\n在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：\n2.3.2.6 实现关系 实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\n在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。\n3，软件设计原则 在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。\n3.1 开闭原则 对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。\n想要达到这样的效果，我们需要使用接口和抽象类。\n因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\n下面以 搜狗输入法 的皮肤为例介绍开闭原则的应用。\n【例】搜狗输入法 的皮肤设计。\n分析：搜狗输入法 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。\n3.2 里氏代换原则 里氏代换原则是面向对象设计的基本原则之一。\n里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。\n下面看一个里氏替换原则中经典的一个例子\n【例】正方形不是长方形。\n在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。\n代码如下：\n长方形类（Rectangle）：\npublic class Rectangle { private double length; private double width; public double getLength() { return length; } public void setLength(double length) { this.length = length; } public double getWidth() { return width; } public void setWidth(double width) { this.width = width; } } 正方形（Square）：\n由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。\npublic class Square extends Rectangle { public void setWidth(double width) { super.setLength(width); super.setWidth(width); } public void setLength(double length) { super.setLength(length); super.setWidth(length); } } 类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。\npublic class RectangleDemo { public static void resize(Rectangle rectangle) { while (rectangle.getWidth() \u0026lt;= rectangle.getLength()) { rectangle.setWidth(rectangle.getWidth() + 1); } } //打印长方形的长和宽 public static void printLengthAndWidth(Rectangle rectangle) { System.out.println(rectangle.getLength()); System.out.println(rectangle.getWidth()); } public static void main(String[] args) { Rectangle rectangle = new Rectangle(); rectangle.setLength(20); rectangle.setWidth(10); resize(rectangle); printLengthAndWidth(rectangle); System.out.println(\u0026#34;============\u0026#34;); Rectangle rectangle1 = new Square(); rectangle1.setLength(10); resize(rectangle1); printLengthAndWidth(rectangle1); } } 我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。 我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。\n如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口\n3.3 依赖倒转原则 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n下面看一个例子来理解依赖倒转原则\n【例】组装电脑\n现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。\n类图如下：\n代码如下：\n希捷硬盘类（XiJieHardDisk）:\npublic class XiJieHardDisk implements HardDisk { public void save(String data) { System.out.println(\u0026#34;使用希捷硬盘存储数据\u0026#34; + data); } public String get() { System.out.println(\u0026#34;使用希捷希捷硬盘取数据\u0026#34;); return \u0026#34;数据\u0026#34;; } } Intel处理器（IntelCpu）：\npublic class IntelCpu implements Cpu { public void run() { System.out.println(\u0026#34;使用Intel处理器\u0026#34;); } } 金士顿内存条（KingstonMemory）：\npublic class KingstonMemory implements Memory { public void save() { System.out.println(\u0026#34;使用金士顿作为内存条\u0026#34;); } } 电脑（Computer）：\npublic class Computer { private XiJieHardDisk hardDisk; private IntelCpu cpu; private KingstonMemory memory; public IntelCpu getCpu() { return cpu; } public void setCpu(IntelCpu cpu) { this.cpu = cpu; } public KingstonMemory getMemory() { return memory; } public void setMemory(KingstonMemory memory) { this.memory = memory; } public XiJieHardDisk getHardDisk() { return hardDisk; } public void setHardDisk(XiJieHardDisk hardDisk) { this.hardDisk = hardDisk; } public void run() { System.out.println(\u0026#34;计算机工作\u0026#34;); cpu.run(); memory.save(); String data = hardDisk.get(); System.out.println(\u0026#34;从硬盘中获取的数据为：\u0026#34; + data); } } 测试类（TestComputer）：\n测试类用来组装电脑。\npublic class TestComputer { public static void main(String[] args) { Computer computer = new Computer(); computer.setHardDisk(new XiJieHardDisk()); computer.setCpu(new IntelCpu()); computer.setMemory(new KingstonMemory()); computer.run(); } } 上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。\n根据依赖倒转原则进行改进：\n代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。\n类图如下：\n电脑（Computer）：\npublic class Computer { private HardDisk hardDisk; private Cpu cpu; private Memory memory; public HardDisk getHardDisk() { return hardDisk; } public void setHardDisk(HardDisk hardDisk) { this.hardDisk = hardDisk; } public Cpu getCpu() { return cpu; } public void setCpu(Cpu cpu) { this.cpu = cpu; } public Memory getMemory() { return memory; } public void setMemory(Memory memory) { this.memory = memory; } public void run() { System.out.println(\u0026#34;计算机工作\u0026#34;); } } 面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。\n3.4 接口隔离原则 客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。\n下面看一个例子来理解接口隔离原则\n【例】安全门案例\n我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：\n上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：\n代码如下：\nAntiTheft（接口）：\npublic interface AntiTheft { void antiTheft(); } Fireproof（接口）：\npublic interface Fireproof { void fireproof(); } Waterproof（接口）：\npublic interface Waterproof { void waterproof(); } HeiMaSafetyDoor（类）：\npublic class HeiMaSafetyDoor implements AntiTheft,Fireproof,Waterproof { public void antiTheft() { System.out.println(\u0026#34;防盗\u0026#34;); } public void fireproof() { System.out.println(\u0026#34;防火\u0026#34;); } public void waterproof() { System.out.println(\u0026#34;防水\u0026#34;); } } ItcastSafetyDoor（类）：\npublic class ItcastSafetyDoor implements AntiTheft,Fireproof { public void antiTheft() { System.out.println(\u0026#34;防盗\u0026#34;); } public void fireproof() { System.out.println(\u0026#34;防火\u0026#34;); } } 3.5 迪米特法则 迪米特法则又叫最少知识原则。\n只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。\n其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\n迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\n下面看一个例子来理解迪米特法则\n【例】明星与经纪人的关系实例\n明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。\n类图如下：\n代码如下：\n明星类（Star）\npublic class Star { private String name; public Star(String name) { this.name=name; } public String getName() { return name; } } 粉丝类（Fans）\npublic class Fans { private String name; public Fans(String name) { this.name=name; } public String getName() { return name; } } 媒体公司类（Company）\npublic class Company { private String name; public Company(String name) { this.name=name; } public String getName() { return name; } } 经纪人类（Agent）\npublic class Agent { private Star star; private Fans fans; private Company company; public void setStar(Star star) { this.star = star; } public void setFans(Fans fans) { this.fans = fans; } public void setCompany(Company company) { this.company = company; } public void meeting() { System.out.println(fans.getName() + \u0026#34;与明星\u0026#34; + star.getName() + \u0026#34;见面了。\u0026#34;); } public void business() { System.out.println(company.getName() + \u0026#34;与明星\u0026#34; + star.getName() + \u0026#34;洽淡业务。\u0026#34;); } } 3.6 合成复用原则 合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n通常类的复用分为继承复用和合成复用两种。\n继承复用虽然有简单和易实现的优点，但它也存在以下缺点：\n继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：\n它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 对象间的耦合度低。可以在类的成员位置声明抽象。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 下面看一个例子来理解合成复用原则\n【例】汽车分类管理程序\n汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：\n从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。\n4，创建者模式 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。\n这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。\n创建型模式分为：\n单例模式 工厂方法模式 抽象工程模式 原型模式 建造者模式 4.1 单例设计模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n4.1.1 单例模式的结构 单例模式的主要有以下角色：\n单例类。只能创建一个实例的类 访问类。使用单例类 4.1.2 单例模式的实现 单例设计模式分类两种：\n​\t饿汉式：类加载就会导致该单实例对象被创建\n​\t懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建\n饿汉式-方式1（静态变量方式）\n/** * 饿汉式 * 静态变量创建类的对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } 说明：\n该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。\n饿汉式-方式2（静态代码块方式）\n/** * 恶汉式 * 在静态代码块中创建该类对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; static { instance = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } 说明：\n该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。\n懒汉式-方式1（线程不安全）\n/** * 懒汉式 * 线程不安全 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 说明：\n从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。\n懒汉式-方式2（线程安全）\n/** * 懒汉式 * 线程安全 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 说明：\n该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。\n懒汉式-方式3（双重检查锁）\n再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式\n/** * 双重检查方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) { synchronized (Singleton.class) { //抢到锁之后再次判断是否为null if(instance == null) { instance = new Singleton(); } } } return instance; } } 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。\n要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关键字可以保证可见性和有序性。\n/** * 双重检查方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际 if(instance == null) { synchronized (Singleton.class) { //抢到锁之后再次判断是否为空 if(instance == null) { instance = new Singleton(); } } } return instance; } } 小结：\n添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。\n懒汉式-方式4（静态内部类方式）\n静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。\n/** * 静态内部类方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } 说明：\n​\t第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder\n并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。\n小结：\n​\t静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。\n枚举方式\n枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。\n/** * 枚举方式 */ public enum Singleton { INSTANCE; } 说明：\n​\t枚举方式属于恶汉式方式。\n4.1.3 存在的问题 4.1.3.1 问题演示 破坏单例模式：\n使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。\n序列化反序列化\nSingleton类：\npublic class Singleton implements Serializable { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } Test类：\npublic class Test { public static void main(String[] args) throws Exception { //往文件中写对象 //writeObject2File(); //从文件中读取对象 Singleton s1 = readObjectFromFile(); Singleton s2 = readObjectFromFile(); //判断两个反序列化后的对象是否是同一个对象 System.out.println(s1 == s2); } private static Singleton readObjectFromFile() throws Exception { //创建对象输入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt\u0026#34;)); //第一个读取Singleton对象 Singleton instance = (Singleton) ois.readObject(); return instance; } public static void writeObject2File() throws Exception { //获取Singleton类的对象 Singleton instance = Singleton.getInstance(); //创建对象输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt\u0026#34;)); //将instance对象写出到文件中 oos.writeObject(instance); } } 上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式。\n反射\nSingleton类：\npublic class Singleton { //私有构造方法 private Singleton() {} private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance != null) { return instance; } synchronized (Singleton.class) { if(instance != null) { return instance; } instance = new Singleton(); return instance; } } } Test类：\npublic class Test { public static void main(String[] args) throws Exception { //获取Singleton类的字节码对象 Class clazz = Singleton.class; //获取Singleton类的私有无参构造方法对象 Constructor constructor = clazz.getDeclaredConstructor(); //取消访问检查 constructor.setAccessible(true); //创建Singleton类的对象s1 Singleton s1 = (Singleton) constructor.newInstance(); //创建Singleton类的对象s2 Singleton s2 = (Singleton) constructor.newInstance(); //判断通过反射创建的两个Singleton对象是否是同一个对象 System.out.println(s1 == s2); } } 上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式\n注意：枚举方式不会出现这两个问题。\n4.1.3.2 问题的解决 序列化、反序列方式破坏单例模式的解决方法\n在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。\nSingleton类：\npublic class Singleton implements Serializable { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } /** * 下面是为了解决序列化反序列化破解单例模式 */ private Object readResolve() { return SingletonHolder.INSTANCE; } } 源码解析：\nObjectInputStream类\npublic final Object readObject() throws IOException, ClassNotFoundException{ ... // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try { Object obj = readObject0(false);//重点查看readObject0方法 ..... } private Object readObject0(boolean unshared) throws IOException { ... try { switch (tc) { ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法 ... } } finally { depth--; bin.setBlockDataMode(oldMode); } } private Object readOrdinaryObject(boolean unshared) throws IOException { ... //isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类， obj = desc.isInstantiable() ? desc.newInstance() : null; ... // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true if (obj != null \u0026amp;\u0026amp; handles.lookupException(passHandle) == null \u0026amp;\u0026amp; desc.hasReadResolveMethod()) { // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量 // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。 Object rep = desc.invokeReadResolve(obj); ... } return obj; } 反射方式破解单例的解决方法\npublic class Singleton { //私有构造方法 private Singleton() { /* 反射破解单例模式需要添加的代码 */ if(instance != null) { throw new RuntimeException(); } } private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance != null) { return instance; } synchronized (Singleton.class) { if(instance != null) { return instance; } instance = new Singleton(); return instance; } } } 说明:\n​\t这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。\n4.1.4 JDK源码解析-Runtime类 Runtime类就是使用的单例设计模式。\n通过源代码查看使用的是哪儿种单例模式\npublic class Runtime { private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } /** Don\u0026#39;t let anyone else instantiate this class */ private Runtime() {} ... } 从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。\n使用Runtime类中的方法\npublic class RuntimeDemo { public static void main(String[] args) throws IOException { //获取Runtime类对象 Runtime runtime = Runtime.getRuntime(); //返回 Java 虚拟机中的内存总量。 System.out.println(runtime.totalMemory()); //返回 Java 虚拟机试图使用的最大内存量。 System.out.println(runtime.maxMemory()); //创建一个新的进程执行指定的字符串命令，返回进程对象 Process process = runtime.exec(\u0026#34;ipconfig\u0026#34;); //获取命令执行后的结果，通过输入流获取 InputStream inputStream = process.getInputStream(); byte[] arr = new byte[1024 * 1024* 100]; int b = inputStream.read(arr); System.out.println(new String(arr,0,b,\u0026#34;gbk\u0026#34;)); } } 4.2 工厂模式 4.2.1 概述 需求：设计一个咖啡店点餐系统。\n设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。\n具体类的设计如下：\n在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。\n在本教程中会介绍三种工厂的使用\n简单工厂模式（不属于GOF的23种经典设计模式） 工厂方法模式 抽象工厂模式 4.2.2 简单工厂模式 简单工厂不是一种设计模式，反而比较像是一种编程习惯。\n4.2.2.1 结构 简单工厂包含如下角色：\n抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。 具体产品 ：实现或者继承抽象产品的子类 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。 4.2.2.2 实现 现在使用简单工厂对上面案例进行改进，类图如下：\n工厂类代码如下：\npublic class SimpleCoffeeFactory { public Coffee createCoffee(String type) { Coffee coffee = null; if(\u0026#34;americano\u0026#34;.equals(type)) { coffee = new AmericanoCoffee(); } else if(\u0026#34;latte\u0026#34;.equals(type)) { coffee = new LatteCoffee(); } return coffee; } } 工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。\n后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。\n4.2.2.4 优缺点 优点：\n封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。\n缺点：\n增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。\n4.2.2.3 扩展 静态工厂\n在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：\npublic class SimpleCoffeeFactory { public static Coffee createCoffee(String type) { Coffee coffee = null; if(\u0026#34;americano\u0026#34;.equals(type)) { coffee = new AmericanoCoffee(); } else if(\u0026#34;latte\u0026#34;.equals(type)) { coffee = new LatteCoffee(); } return coffe; } } 4.2.3 工厂方法模式 针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。\n4.2.3.1 概念 定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。\n4.2.3.2 结构 工厂方法模式的主要角色：\n抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。 4.2.3.3 实现 使用工厂方法模式对上例进行改进，类图如下：\n代码如下：\n抽象工厂：\npublic interface CoffeeFactory { Coffee createCoffee(); } 具体工厂：\npublic class LatteCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new LatteCoffee(); } } public class AmericanCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new AmericanCoffee(); } } 咖啡店类：\npublic class CoffeeStore { private CoffeeFactory factory; public CoffeeStore(CoffeeFactory factory) { this.factory = factory; } public Coffee orderCoffee(String type) { Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; } } 从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。\n工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\n4.2.3.4 优缺点 优点：\n用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程； 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则； 缺点：\n每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。 4.2.4 抽象工厂模式 前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。\n这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。\n本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。\n4.2.4.1 概念 是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\n抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\n4.2.4.2 结构 抽象工厂模式的主要角色如下：\n抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。 4.2.4.2 实现 现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：\n代码如下：\n抽象工厂：\npublic interface DessertFactory { Coffee createCoffee(); Dessert createDessert(); } 具体工厂：\n//美式甜点工厂 public class AmericanDessertFactory implements DessertFactory { public Coffee createCoffee() { return new AmericanCoffee(); } public Dessert createDessert() { return new MatchaMousse(); } } //意大利风味甜点工厂 public class ItalyDessertFactory implements DessertFactory { public Coffee createCoffee() { return new LatteCoffee(); } public Dessert createDessert() { return new Tiramisu(); } } 如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。\n4.2.4.3 优缺点 优点：\n当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\n缺点：\n当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。\n4.2.4.4 使用场景 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。\n系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。\n系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。\n如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。\n4.2.5 模式扩展 简单工厂+配置文件解除耦合\n可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。\n第一步：定义配置文件\n为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties\namerican=com.itheima.pattern.factory.config_factory.AmericanCoffee latte=com.itheima.pattern.factory.config_factory.LatteCoffee 第二步：改进工厂类\npublic class CoffeeFactory { private static Map\u0026lt;String,Coffee\u0026gt; map = new HashMap(); static { Properties p = new Properties(); InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(\u0026#34;bean.properties\u0026#34;); try { p.load(is); //遍历Properties集合对象 Set\u0026lt;Object\u0026gt; keys = p.keySet(); for (Object key : keys) { //根据键获取值（全类名） String className = p.getProperty((String) key); //获取字节码对象 Class clazz = Class.forName(className); Coffee obj = (Coffee) clazz.newInstance(); map.put((String)key,obj); } } catch (Exception e) { e.printStackTrace(); } } public static Coffee createCoffee(String name) { return map.get(name); } } 静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。\n4.2.6 JDK源码解析-Collection.iterator方法 public class Demo { public static void main(String[] args) { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;令狐冲\u0026#34;); list.add(\u0026#34;风清扬\u0026#34;); list.add(\u0026#34;任我行\u0026#34;); //获取迭代器对象 Iterator\u0026lt;String\u0026gt; it = list.iterator(); //使用迭代器遍历 while(it.hasNext()) { String ele = it.next(); System.out.println(ele); } } } 对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：\nCollection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。\n另：\n​\t1,DateForamt类中的getInstance()方法使用的是工厂模式；\n​\t2,Calendar类中的getInstance()方法使用的是工厂模式；\n4.3 原型模式 4.3.1 概述 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。\n4.3.2 结构 原型模式包含如下角色：\n抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 接口类图如下：\n4.3.3 实现 原型模式的克隆分为浅克隆和深克隆。\n浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。\n深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\nJava中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：\nRealizetype（具体的原型类）：\npublic class Realizetype implements Cloneable { public Realizetype() { System.out.println(\u0026#34;具体的原型对象创建完成！\u0026#34;); } @Override protected Realizetype clone() throws CloneNotSupportedException { System.out.println(\u0026#34;具体原型复制成功！\u0026#34;); return (Realizetype) super.clone(); } } PrototypeTest（测试访问类）：\npublic class PrototypeTest { public static void main(String[] args) throws CloneNotSupportedException { Realizetype r1 = new Realizetype(); Realizetype r2 = r1.clone(); System.out.println(\u0026#34;对象r1和r2是同一个对象？\u0026#34; + (r1 == r2)); } } 4.3.4 案例 用原型模式生成“三好学生”奖状\n同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。\n类图如下： 代码如下：\n//奖状类 public class Citation implements Cloneable { private String name; public void setName(String name) { this.name = name; } public String getName() { return (this.name); } public void show() { System.out.println(name + \u0026#34;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\u0026#34;); } @Override public Citation clone() throws CloneNotSupportedException { return (Citation) super.clone(); } } //测试访问类 public class CitationTest { public static void main(String[] args) throws CloneNotSupportedException { Citation c1 = new Citation(); c1.setName(\u0026#34;张三\u0026#34;); //复制奖状 Citation c2 = c1.clone(); //将奖状的名字修改李四 c2.setName(\u0026#34;李四\u0026#34;); c1.show(); c2.show(); } } 4.3.5 使用场景 对象的创建非常复杂，可以使用原型模式快捷的创建对象。 性能和安全要求比较高。 4.3.6 扩展（深克隆） 将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：\n//奖状类 public class Citation implements Cloneable { private Student stu; public Student getStu() { return stu; } public void setStu(Student stu) { this.stu = stu; } void show() { System.out.println(stu.getName() + \u0026#34;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\u0026#34;); } @Override public Citation clone() throws CloneNotSupportedException { return (Citation) super.clone(); } } //学生类 public class Student { private String name; private String address; public Student(String name, String address) { this.name = name; this.address = address; } public Student() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } //测试类 public class CitationTest { public static void main(String[] args) throws CloneNotSupportedException { Citation c1 = new Citation(); Student stu = new Student(\u0026#34;张三\u0026#34;, \u0026#34;西安\u0026#34;); c1.setStu(stu); //复制奖状 Citation c2 = c1.clone(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(\u0026#34;李四\u0026#34;); //判断stu对象和stu1对象是否是同一个对象 System.out.println(\u0026#34;stu和stu1是同一个对象？\u0026#34; + (stu == stu1)); c1.show(); c2.show(); } } 运行结果为： 说明：\n​\tstu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：\npublic class CitationTest1 { public static void main(String[] args) throws Exception { Citation c1 = new Citation(); Student stu = new Student(\u0026#34;张三\u0026#34;, \u0026#34;西安\u0026#34;); c1.setStu(stu); //创建对象输出流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\u0026#34;)); //将c1对象写出到文件中 oos.writeObject(c1); oos.close(); //创建对象出入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\u0026#34;)); //读取对象 Citation c2 = (Citation) ois.readObject(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(\u0026#34;李四\u0026#34;); //判断stu对象和stu1对象是否是同一个对象 System.out.println(\u0026#34;stu和stu1是同一个对象？\u0026#34; + (stu == stu1)); c1.show(); c2.show(); } } 运行结果为：\n注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。\n4.5 建造者模式 4.4.1 概述 将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。\n分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 4.4.2 结构 建造者（Builder）模式包含如下角色：\n抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。\n具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。\n产品类（Product）：要创建的复杂对象。\n指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。\n类图如下：\n4.4.3 实例 创建共享单车\n生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。\n这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：\n具体的代码如下：\n//自行车类 public class Bike { private String frame; private String seat; public String getFrame() { return frame; } public void setFrame(String frame) { this.frame = frame; } public String getSeat() { return seat; } public void setSeat(String seat) { this.seat = seat; } } // 抽象 builder 类 public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); } //摩拜单车Builder类 public class MobikeBuilder extends Builder { @Override public void buildFrame() { mBike.setFrame(\u0026#34;铝合金车架\u0026#34;); } @Override public void buildSeat() { mBike.setSeat(\u0026#34;真皮车座\u0026#34;); } @Override public Bike createBike() { return mBike; } } //ofo单车Builder类 public class OfoBuilder extends Builder { @Override public void buildFrame() { mBike.setFrame(\u0026#34;碳纤维车架\u0026#34;); } @Override public void buildSeat() { mBike.setSeat(\u0026#34;橡胶车座\u0026#34;); } @Override public Bike createBike() { return mBike; } } //指挥者类 public class Director { private Builder mBuilder; public Director(Builder builder) { mBuilder = builder; } public Bike construct() { mBuilder.buildFrame(); mBuilder.buildSeat(); return mBuilder.createBike(); } } //测试类 public class Client { public static void main(String[] args) { showBike(new OfoBuilder()); showBike(new MobikeBuilder()); } private static void showBike(Builder builder) { Director director = new Director(builder); Bike bike = director.construct(); System.out.println(bike.getFrame()); System.out.println(bike.getSeat()); } } 注意：\n上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合\n// 抽象 builder 类 public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); public Bike construct() { this.buildFrame(); this.BuildSeat(); return this.createBike(); } } 说明：\n这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。\n4.4.4 优缺点 优点：\n建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。 缺点：\n造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\n4.4.5 使用场景 建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。\n创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。 4.4.6 模式扩展 建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。\n重构前代码如下：\npublic class Phone { private String cpu; private String screen; private String memory; private String mainboard; public Phone(String cpu, String screen, String memory, String mainboard) { this.cpu = cpu; this.screen = screen; this.memory = memory; this.mainboard = mainboard; } public String getCpu() { return cpu; } public void setCpu(String cpu) { this.cpu = cpu; } public String getScreen() { return screen; } public void setScreen(String screen) { this.screen = screen; } public String getMemory() { return memory; } public void setMemory(String memory) { this.memory = memory; } public String getMainboard() { return mainboard; } public void setMainboard(String mainboard) { this.mainboard = mainboard; } @Override public String toString() { return \u0026#34;Phone{\u0026#34; + \u0026#34;cpu=\u0026#39;\u0026#34; + cpu + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, screen=\u0026#39;\u0026#34; + screen + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, memory=\u0026#39;\u0026#34; + memory + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, mainboard=\u0026#39;\u0026#34; + mainboard + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } public class Client { public static void main(String[] args) { //构建Phone对象 Phone phone = new Phone(\u0026#34;intel\u0026#34;,\u0026#34;三星屏幕\u0026#34;,\u0026#34;金士顿\u0026#34;,\u0026#34;华硕\u0026#34;); System.out.println(phone); } } 上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。\n重构后代码：\npublic class Phone { private String cpu; private String screen; private String memory; private String mainboard; private Phone(Builder builder) { cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; } public static final class Builder { private String cpu; private String screen; private String memory; private String mainboard; public Builder() {} public Builder cpu(String val) { cpu = val; return this; } public Builder screen(String val) { screen = val; return this; } public Builder memory(String val) { memory = val; return this; } public Builder mainboard(String val) { mainboard = val; return this; } public Phone build() { return new Phone(this);} } @Override public String toString() { return \u0026#34;Phone{\u0026#34; + \u0026#34;cpu=\u0026#39;\u0026#34; + cpu + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, screen=\u0026#39;\u0026#34; + screen + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, memory=\u0026#39;\u0026#34; + memory + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, mainboard=\u0026#39;\u0026#34; + mainboard + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } public class Client { public static void main(String[] args) { Phone phone = new Phone.Builder() .cpu(\u0026#34;intel\u0026#34;) .mainboard(\u0026#34;华硕\u0026#34;) .memory(\u0026#34;金士顿\u0026#34;) .screen(\u0026#34;三星\u0026#34;) .build(); System.out.println(phone); } } 重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。\n4.6 创建者模式对比 4.6.1 工厂方法模式VS建造者模式 工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。\n我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。\n4.6.2 抽象工厂模式VS建造者模式 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。\n建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。\n如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。\n5，结构型模式 结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\n由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。\n结构型模式分为以下 7 种：\n代理模式 适配器模式 装饰者模式 桥接模式 外观模式 组合模式 享元模式 5.1 代理模式 5.1.1 概述 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\nJava中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。\n5.1.2 结构 代理（Proxy）模式分为三种角色：\n抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 5.1.3 静态代理 我们通过案例来感受一下静态代理。\n【例】火车站卖票\n如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：\n代码如下：\n//卖票接口 public interface SellTickets { void sell(); } //火车站 火车站具有卖票功能，所以需要实现SellTickets接口 public class TrainStation implements SellTickets { public void sell() { System.out.println(\u0026#34;火车站卖票\u0026#34;); } } //代售点 public class ProxyPoint implements SellTickets { private TrainStation station = new TrainStation(); public void sell() { System.out.println(\u0026#34;代理点收取一些服务费用\u0026#34;); station.sell(); } } //测试类 public class Client { public static void main(String[] args) { ProxyPoint pp = new ProxyPoint(); pp.sell(); } } 从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。\n5.1.4 JDK动态代理 接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。\n代码如下：\n//卖票接口 public interface SellTickets { void sell(); } //火车站 火车站具有卖票功能，所以需要实现SellTickets接口 public class TrainStation implements SellTickets { public void sell() { System.out.println(\u0026#34;火车站卖票\u0026#34;); } } //代理工厂，用来创建代理对象 public class ProxyFactory { private TrainStation station = new TrainStation(); public SellTickets getProxyObject() { //使用Proxy获取代理对象 /* newProxyInstance()方法参数说明： ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可 Class\u0026lt;?\u0026gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口 InvocationHandler h ： 代理对象的调用处理程序 */ SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { /* InvocationHandler中invoke方法参数说明： proxy ： 代理对象 method ： 对应于在代理对象上调用的接口方法的 Method 实例 args ： 代理对象调用接口方法时传递的实际参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;代理点收取一些服务费用(JDK动态代理方式)\u0026#34;); //执行真实对象 Object result = method.invoke(station, args); return result; } }); return sellTickets; } } //测试类 public class Client { public static void main(String[] args) { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); } } 使用了动态代理，我们思考下面问题：\nProxyFactory是代理类吗？\nProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：\npackage com.sun.proxy; import com.itheima.proxy.dynamic.jdk.SellTickets; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; public final class $Proxy0 extends Proxy implements SellTickets { private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler invocationHandler) { super(invocationHandler); } static { try { m1 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;equals\u0026#34;, Class.forName(\u0026#34;java.lang.Object\u0026#34;)); m2 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;toString\u0026#34;, new Class[0]); m3 = Class.forName(\u0026#34;com.itheima.proxy.dynamic.jdk.SellTickets\u0026#34;).getMethod(\u0026#34;sell\u0026#34;, new Class[0]); m0 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;hashCode\u0026#34;, new Class[0]); return; } catch (NoSuchMethodException noSuchMethodException) { throw new NoSuchMethodError(noSuchMethodException.getMessage()); } catch (ClassNotFoundException classNotFoundException) { throw new NoClassDefFoundError(classNotFoundException.getMessage()); } } public final boolean equals(Object object) { try { return (Boolean)this.h.invoke(this, m1, new Object[]{object}); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final String toString() { try { return (String)this.h.invoke(this, m2, null); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final int hashCode() { try { return (Integer)this.h.invoke(this, m0, null); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final void sell() { try { this.h.invoke(this, m3, null); return; } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } } 从上面的类中，我们可以看到以下几个信息：\n代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。 代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。 动态代理的执行流程是什么样？\n下面是摘取的重点代码：\n//程序运行过程中动态生成的代理类 public final class $Proxy0 extends Proxy implements SellTickets { private static Method m3; public $Proxy0(InvocationHandler invocationHandler) { super(invocationHandler); } static { m3 = Class.forName(\u0026#34;com.itheima.proxy.dynamic.jdk.SellTickets\u0026#34;).getMethod(\u0026#34;sell\u0026#34;, new Class[0]); } public final void sell() { this.h.invoke(this, m3, null); } } //Java提供的动态代理相关类 public class Proxy implements java.io.Serializable { protected InvocationHandler h; protected Proxy(InvocationHandler h) { this.h = h; } } //代理工厂类 public class ProxyFactory { private TrainStation station = new TrainStation(); public SellTickets getProxyObject() { SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;代理点收取一些服务费用(JDK动态代理方式)\u0026#34;); Object result = method.invoke(station, args); return result; } }); return sellTickets; } } //测试访问类 public class Client { public static void main(String[] args) { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); } } 执行流程如下：\n在测试类中通过代理对象调用sell()方法 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法 invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法 5.1.5 CGLIB动态代理 同样是上面的案例，我们再次使用CGLIB代理实现。\n如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。\nCGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。\nCGLIB是第三方提供的包，所以需要引入jar包的坐标：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cglib\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cglib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 代码如下：\n//火车站 public class TrainStation { public void sell() { System.out.println(\u0026#34;火车站卖票\u0026#34;); } } //代理工厂 public class ProxyFactory implements MethodInterceptor { private TrainStation target = new TrainStation(); public TrainStation getProxyObject() { //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数 Enhancer enhancer =new Enhancer(); //设置父类的字节码对象 enhancer.setSuperclass(target.getClass()); //设置回调函数 enhancer.setCallback(this); //创建代理对象 TrainStation obj = (TrainStation) enhancer.create(); return obj; } /* intercept方法参数说明： o ： 代理对象 method ： 真实对象中的方法的Method实例 args ： 实际参数 methodProxy ：代理对象中的方法的method实例 */ public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\u0026#34;代理点收取一些服务费用(CGLIB动态代理方式)\u0026#34;); TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args); return result; } } //测试类 public class Client { public static void main(String[] args) { //创建代理工厂对象 ProxyFactory factory = new ProxyFactory(); //获取代理对象 TrainStation proxyObject = factory.getProxyObject(); proxyObject.sell(); } } 5.1.6 三种代理的对比 jdk代理和CGLIB代理\n使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。\n在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。\n动态代理和静态代理\n动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。\n如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题\n5.1.7 优缺点 优点：\n代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点：\n增加了系统的复杂度； 5.1.8 使用场景 远程（Remote）代理\n本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。\n防火墙（Firewall）代理\n当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。\n保护（Protect or Access）代理\n控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。\n5.2 适配器模式 5.2.1 概述 如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。\n定义：\n​\t将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n​\t适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n5.2.2 结构 适配器模式（Adapter）包含以下主要角色：\n目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 5.2.3 类适配器模式 实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。\n【例】读卡器\n现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。\n类图如下：\n代码如下：\n//SD卡的接口 public interface SDCard { //读取SD卡方法 String readSD(); //写入SD卡功能 void writeSD(String msg); } //SD卡实现类 public class SDCardImpl implements SDCard { public String readSD() { String msg = \u0026#34;sd card read a msg :hello word SD\u0026#34;; return msg; } public void writeSD(String msg) { System.out.println(\u0026#34;sd card write msg : \u0026#34; + msg); } } //电脑类 public class Computer { public String readSD(SDCard sdCard) { if(sdCard == null) { throw new NullPointerException(\u0026#34;sd card null\u0026#34;); } return sdCard.readSD(); } } //TF卡接口 public interface TFCard { //读取TF卡方法 String readTF(); //写入TF卡功能 void writeTF(String msg); } //TF卡实现类 public class TFCardImpl implements TFCard { public String readTF() { String msg =\u0026#34;tf card read msg : hello word tf card\u0026#34;; return msg; } public void writeTF(String msg) { System.out.println(\u0026#34;tf card write a msg : \u0026#34; + msg); } } //定义适配器类（SD兼容TF） public class SDAdapterTF extends TFCardImpl implements SDCard { public String readSD() { System.out.println(\u0026#34;adapter read tf card \u0026#34;); return readTF(); } public void writeSD(String msg) { System.out.println(\u0026#34;adapter write tf card\u0026#34;); writeTF(msg); } } //测试类 public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(\u0026#34;------------\u0026#34;); SDAdapterTF adapter = new SDAdapterTF(); System.out.println(computer.readSD(adapter)); } } 类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。\n5.2.4 对象适配器模式 实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。\n【例】读卡器\n我们使用对象适配器模式将读卡器的案例进行改写。类图如下：\n代码如下：\n类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。\n//创建适配器对象（SD兼容TF） public class SDAdapterTF implements SDCard { private TFCard tfCard; public SDAdapterTF(TFCard tfCard) { this.tfCard = tfCard; } public String readSD() { System.out.println(\u0026#34;adapter read tf card \u0026#34;); return tfCard.readTF(); } public void writeSD(String msg) { System.out.println(\u0026#34;adapter write tf card\u0026#34;); tfCard.writeTF(msg); } } //测试类 public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(\u0026#34;------------\u0026#34;); TFCard tfCard = new TFCardImpl(); SDAdapterTF adapter = new SDAdapterTF(tfCard); System.out.println(computer.readSD(adapter)); } } 注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。\n5.2.5 应用场景 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 5.2.6 JDK源码解析 Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。\nInputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：\npublic int read() throws IOException { return sd.read(); } public int read(char cbuf[], int offset, int length) throws IOException { return sd.read(cbuf, offset, length); } 如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：\n从上图可以看出：\nInputStreamReader是对同样实现了Reader的StreamDecoder的封装。 StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。 结论：\n​\t从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。\n5.3 装饰者模式 5.3.1 概述 我们先来看一个快餐店的例子。\n快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。\n使用继承的方式存在的问题：\n扩展性不好\n如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。\n产生过多的子类\n定义：\n​\t指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。\n5.3.2 结构 装饰（Decorator）模式中的角色：\n抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 5.3.3 案例 我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。\n类图如下：\n代码如下：\n//快餐接口 public abstract class FastFood { private float price; private String desc; public FastFood() { } public FastFood(float price, String desc) { this.price = price; this.desc = desc; } public void setPrice(float price) { this.price = price; } public float getPrice() { return price; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public abstract float cost(); //获取价格 } //炒饭 public class FriedRice extends FastFood { public FriedRice() { super(10, \u0026#34;炒饭\u0026#34;); } public float cost() { return getPrice(); } } //炒面 public class FriedNoodles extends FastFood { public FriedNoodles() { super(12, \u0026#34;炒面\u0026#34;); } public float cost() { return getPrice(); } } //配料类 public abstract class Garnish extends FastFood { private FastFood fastFood; public FastFood getFastFood() { return fastFood; } public void setFastFood(FastFood fastFood) { this.fastFood = fastFood; } public Garnish(FastFood fastFood, float price, String desc) { super(price,desc); this.fastFood = fastFood; } } //鸡蛋配料 public class Egg extends Garnish { public Egg(FastFood fastFood) { super(fastFood,1,\u0026#34;鸡蛋\u0026#34;); } public float cost() { return getPrice() + getFastFood().getPrice(); } @Override public String getDesc() { return super.getDesc() + getFastFood().getDesc(); } } //培根配料 public class Bacon extends Garnish { public Bacon(FastFood fastFood) { super(fastFood,2,\u0026#34;培根\u0026#34;); } @Override public float cost() { return getPrice() + getFastFood().getPrice(); } @Override public String getDesc() { return super.getDesc() + getFastFood().getDesc(); } } //测试类 public class Client { public static void main(String[] args) { //点一份炒饭 FastFood food = new FriedRice(); //花费的价格 System.out.println(food.getDesc() + \u0026#34; \u0026#34; + food.cost() + \u0026#34;元\u0026#34;); System.out.println(\u0026#34;========\u0026#34;); //点一份加鸡蛋的炒饭 FastFood food1 = new FriedRice(); food1 = new Egg(food1); //花费的价格 System.out.println(food1.getDesc() + \u0026#34; \u0026#34; + food1.cost() + \u0026#34;元\u0026#34;); System.out.println(\u0026#34;========\u0026#34;); //点一份加培根的炒面 FastFood food2 = new FriedNoodles(); food2 = new Bacon(food2); //花费的价格 System.out.println(food2.getDesc() + \u0026#34; \u0026#34; + food2.cost() + \u0026#34;元\u0026#34;); } } 好处：\n饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。\n装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n5.3.4 使用场景 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。\n不能采用继承的情况主要有两类：\n第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长； 第二类是因为类定义不能继承（如final类） 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n当对象的功能要求可以动态地添加，也可以再动态地撤销时。\n5.3.5 JDK源码解析 IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。\n我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter\npublic class Demo { public static void main(String[] args) throws Exception{ //创建BufferedWriter对象 //创建FileWriter对象 FileWriter fw = new FileWriter(\u0026#34;C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt\u0026#34;); BufferedWriter bw = new BufferedWriter(fw); //写数据 bw.write(\u0026#34;hello Buffered\u0026#34;); bw.close(); } } 使用起来感觉确实像是装饰者模式，接下来看它们的结构：\n小结：\n​\tBufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。\n5.3.6 代理和装饰者的区别 静态代理和装饰者模式的区别：\n相同点： 都要实现与目标类相同的业务接口 在两个类中都要声明目标对象 都可以在不修改目标类的前提下增强目标方法 不同点： 目的不同 装饰者是为了增强目标对象 静态代理是为了保护和隐藏目标对象 获取目标对象构建的地方不同 装饰者是由外界传递进来，可以通过构造方法传递 静态代理是在代理类内部创建，以此来隐藏目标对象 5.4 桥接模式 5.4.1 概述 现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：\n我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。\n试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。\n定义：\n​\t将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n5.4.2 结构 桥接（Bridge）模式包含以下主要角色：\n抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。 5.4.3 案例 【例】视频播放器\n需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。\n类图如下：\n代码如下：\n//视频文件 public interface VideoFile { void decode(String fileName); } //avi文件 public class AVIFile implements VideoFile { public void decode(String fileName) { System.out.println(\u0026#34;avi视频文件：\u0026#34;+ fileName); } } //rmvb文件 public class REVBBFile implements VideoFile { public void decode(String fileName) { System.out.println(\u0026#34;rmvb文件：\u0026#34; + fileName); } } //操作系统版本 public abstract class OperatingSystemVersion { protected VideoFile videoFile; public OperatingSystemVersion(VideoFile videoFile) { this.videoFile = videoFile; } public abstract void play(String fileName); } //Windows版本 public class Windows extends OperatingSystem { public Windows(VideoFile videoFile) { super(videoFile); } public void play(String fileName) { videoFile.decode(fileName); } } //mac版本 public class Mac extends OperatingSystemVersion { public Mac(VideoFile videoFile) { super(videoFile); } public void play(String fileName) { videoFile.decode(fileName); } } //测试类 public class Client { public static void main(String[] args) { OperatingSystem os = new Windows(new AVIFile()); os.play(\u0026#34;战狼3\u0026#34;); } } 好处：\n桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。\n如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。\n实现细节对客户透明\n5.4.4 使用场景 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 5.5 外观模式 5.5.1 概述 有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。\n定义：\n​\t又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。\n​\t外观（Facade）模式是“迪米特法则”的典型应用\n5.5.2 结构 外观（Facade）模式包含以下主要角色：\n外观（Facade）角色：为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 5.5.3 案例 【例】智能家电控制\n小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：\n代码如下：\n//灯类 public class Light { public void on() { System.out.println(\u0026#34;打开了灯....\u0026#34;); } public void off() { System.out.println(\u0026#34;关闭了灯....\u0026#34;); } } //电视类 public class TV { public void on() { System.out.println(\u0026#34;打开了电视....\u0026#34;); } public void off() { System.out.println(\u0026#34;关闭了电视....\u0026#34;); } } //控制类 public class AirCondition { public void on() { System.out.println(\u0026#34;打开了空调....\u0026#34;); } public void off() { System.out.println(\u0026#34;关闭了空调....\u0026#34;); } } //智能音箱 public class SmartAppliancesFacade { private Light light; private TV tv; private AirCondition airCondition; public SmartAppliancesFacade() { light = new Light(); tv = new TV(); airCondition = new AirCondition(); } public void say(String message) { if(message.contains(\u0026#34;打开\u0026#34;)) { on(); } else if(message.contains(\u0026#34;关闭\u0026#34;)) { off(); } else { System.out.println(\u0026#34;我还听不懂你说的！！！\u0026#34;); } } //起床后一键开电器 private void on() { System.out.println(\u0026#34;起床了\u0026#34;); light.on(); tv.on(); airCondition.on(); } //睡觉一键关电器 private void off() { System.out.println(\u0026#34;睡觉了\u0026#34;); light.off(); tv.off(); airCondition.off(); } } //测试类 public class Client { public static void main(String[] args) { //创建外观对象 SmartAppliancesFacade facade = new SmartAppliancesFacade(); //客户端直接与外观对象进行交互 facade.say(\u0026#34;打开家电\u0026#34;); facade.say(\u0026#34;关闭家电\u0026#34;); } } 好处：\n降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 缺点：\n不符合开闭原则，修改很麻烦 5.5.4 使用场景 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。 5.5.5 源码解析 使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。\nRequestFacade类就使用了外观模式。先看结构图：\n为什么在此处使用外观模式呢？\n​\t定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request 的实现。然后，将 RequestFacade上转为 ServletRequest 传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。\n5.6 组合模式 5.6.1 概述 ​\t对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。\n定义：\n​\t又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。\n5.6.2 结构 组合模式主要包含三种角色：\n抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 5.6.3 案例实现 【例】软件菜单\n如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。\n要实现该案例，我们先画出类图：\n代码实现：\n不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。\n//菜单组件 不管是菜单还是菜单项，都应该继承该类 public abstract class MenuComponent { protected String name; protected int level; //添加菜单 public void add(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } //移除菜单 public void remove(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } //获取指定的子菜单 public MenuComponent getChild(int i){ throw new UnsupportedOperationException(); } //获取菜单名称 public String getName(){ return name; } public void print(){ throw new UnsupportedOperationException(); } } 这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。\npublic class Menu extends MenuComponent { private List\u0026lt;MenuComponent\u0026gt; menuComponentList; public Menu(String name,int level){ this.level = level; this.name = name; menuComponentList = new ArrayList\u0026lt;MenuComponent\u0026gt;(); } @Override public void add(MenuComponent menuComponent) { menuComponentList.add(menuComponent); } @Override public void remove(MenuComponent menuComponent) { menuComponentList.remove(menuComponent); } @Override public MenuComponent getChild(int i) { return menuComponentList.get(i); } @Override public void print() { for (int i = 1; i \u0026lt; level; i++) { System.out.print(\u0026#34;--\u0026#34;); } System.out.println(name); for (MenuComponent menuComponent : menuComponentList) { menuComponent.print(); } } } Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。\npublic class MenuItem extends MenuComponent { public MenuItem(String name,int level) { this.name = name; this.level = level; } @Override public void print() { for (int i = 1; i \u0026lt; level; i++) { System.out.print(\u0026#34;--\u0026#34;); } System.out.println(name); } } MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。\n5.6.4 组合模式的分类 在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。\n透明组合模式\n透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 MenuComponent 声明了 add、remove 、getChild 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。\n透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）\n安全组合模式\n在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 Menu 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。\n5.6.5 优点 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 5.6.6 使用场景 组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。\n5.7 享元模式 5.7.1 概述 定义：\n​\t运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。\n5.7.2 结构 享元（Flyweight ）模式中存在以下两种状态：\n内部状态，即不会随着环境的改变而改变的可共享部分。 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。 享元模式的主要有以下角色：\n抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 5.7.3 案例实现 【例】俄罗斯方块\n下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。\n先来看类图：\n代码如下：\n俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。\npublic abstract class AbstractBox { public abstract String getShape(); public void display(String color) { System.out.println(\u0026#34;方块形状：\u0026#34; + this.getShape() + \u0026#34; 颜色：\u0026#34; + color); } } 接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。\npublic class IBox extends AbstractBox { @Override public String getShape() { return \u0026#34;I\u0026#34;; } } public class LBox extends AbstractBox { @Override public String getShape() { return \u0026#34;L\u0026#34;; } } public class OBox extends AbstractBox { @Override public String getShape() { return \u0026#34;O\u0026#34;; } } 提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。\npublic class BoxFactory { private static HashMap\u0026lt;String, AbstractBox\u0026gt; map; private BoxFactory() { map = new HashMap\u0026lt;String, AbstractBox\u0026gt;(); AbstractBox iBox = new IBox(); AbstractBox lBox = new LBox(); AbstractBox oBox = new OBox(); map.put(\u0026#34;I\u0026#34;, iBox); map.put(\u0026#34;L\u0026#34;, lBox); map.put(\u0026#34;O\u0026#34;, oBox); } public static final BoxFactory getInstance() { return SingletonHolder.INSTANCE; } private static class SingletonHolder { private static final BoxFactory INSTANCE = new BoxFactory(); } public AbstractBox getBox(String key) { return map.get(key); } } 5.7.5 优缺点和使用场景 1，优点\n极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能 享元模式中的外部状态相对独立，且不影响内部状态 2，缺点：\n为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂\n3，使用场景：\n一个系统有大量相同或者相似的对象，造成内存的大量耗费。 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。 5.7.6 JDK源码解析 Integer类使用了享元模式。我们先看下面的例子：\npublic class Demo { public static void main(String[] args) { Integer i1 = 127; Integer i2 = 127; System.out.println(\u0026#34;i1和i2对象是否是同一个对象？\u0026#34; + (i1 == i2)); Integer i3 = 128; Integer i4 = 128; System.out.println(\u0026#34;i3和i4对象是否是同一个对象？\u0026#34; + (i3 == i4)); } } 运行上面代码，结果如下：\n为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：\npublic class Demo { public static void main(String[] args) { Integer i1 = Integer.valueOf((int)127); Integer i2 Integer.valueOf((int)127); System.out.println((String)new StringBuilder().append((String)\u0026#34;i1\\u548ci2\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f\u0026#34;).append((boolean)(i1 == i2)).toString()); Integer i3 = Integer.valueOf((int)128); Integer i4 = Integer.valueOf((int)128); System.out.println((String)new StringBuilder().append((String)\u0026#34;i3\\u548ci4\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f\u0026#34;).append((boolean)(i3 == i4)).toString()); } } 上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 valueOf() ，所以只需要看该方法即可\npublic final class Integer extends Number implements Comparable\u0026lt;Integer\u0026gt; { public static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k \u0026lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } private IntegerCache() {} } } 可以看到 Integer 默认先创建并缓存 -128 ~ 127 之间数的 Integer 对象，当调用 valueOf 时如果参数在 -128 ~ 127 之间则计算下标并从缓存中返回，否则创建一个新的 Integer 对象。\n6，行为型模式 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。\n行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。\n行为型模式分为：\n模板方法模式 策略模式 命令模式 职责链模式 状态模式 观察者模式 中介者模式 迭代器模式 访问者模式 备忘录模式 解释器模式 以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。\n6.1 模板方法模式 6.1.1 概述 在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。\n例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。\n定义：\n定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n6.1.2 结构 模板方法（Template Method）模式包含以下主要角色：\n抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。\n模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。\n基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：\n抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。\n具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\n钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。\n一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。\n具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。\n6.1.3 案例实现 【例】炒菜\n炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：\n代码如下：\npublic abstract class AbstractClass { public final void cookProcess() { //第一步：倒油 this.pourOil(); //第二步：热油 this.heatOil(); //第三步：倒蔬菜 this.pourVegetable(); //第四步：倒调味料 this.pourSauce(); //第五步：翻炒 this.fry(); } public void pourOil() { System.out.println(\u0026#34;倒油\u0026#34;); } //第二步：热油是一样的，所以直接实现 public void heatOil() { System.out.println(\u0026#34;热油\u0026#34;); } //第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心） public abstract void pourVegetable(); //第四步：倒调味料是不一样 public abstract void pourSauce(); //第五步：翻炒是一样的，所以直接实现 public void fry(){ System.out.println(\u0026#34;炒啊炒啊炒到熟啊\u0026#34;); } } public class ConcreteClass_BaoCai extends AbstractClass { @Override public void pourVegetable() { System.out.println(\u0026#34;下锅的蔬菜是包菜\u0026#34;); } @Override public void pourSauce() { System.out.println(\u0026#34;下锅的酱料是辣椒\u0026#34;); } } public class ConcreteClass_CaiXin extends AbstractClass { @Override public void pourVegetable() { System.out.println(\u0026#34;下锅的蔬菜是菜心\u0026#34;); } @Override public void pourSauce() { System.out.println(\u0026#34;下锅的酱料是蒜蓉\u0026#34;); } } public class Client { public static void main(String[] args) { //炒手撕包菜 ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai(); baoCai.cookProcess(); //炒蒜蓉菜心 ConcreteClass_CaiXin caiXin = new ConcreteClass_CaiXin(); caiXin.cookProcess(); } } 注意：为防止恶意操作，一般模板方法都加上 final 关键词。\n6.1.3 优缺点 优点：\n提高代码复用性\n将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。\n实现了反向控制\n通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。\n缺点：\n对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 6.1.4 适用场景 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。 6.1.5 JDK源码解析 InputStream类就使用了模板方法模式。在InputStream类中定义了多个 read() 方法，如下：\npublic abstract class InputStream implements Closeable { //抽象方法，要求子类必须重写 public abstract int read() throws IOException; public int read(byte b[]) throws IOException { return read(b, 0, b.length); } public int read(byte b[], int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (off \u0026lt; 0 || len \u0026lt; 0 || len \u0026gt; b.length - off) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据 if (c == -1) { return -1; } b[off] = (byte)c; int i = 1; try { for (; i \u0026lt; len ; i++) { c = read(); if (c == -1) { break; } b[off + i] = (byte)c; } } catch (IOException ee) { } return i; } } 从上面代码可以看到，无参的 read() 方法是抽象方法，要求子类必须实现。而 read(byte b[]) 方法调用了 read(byte b[], int off, int len) 方法，所以在此处重点看的方法是带三个参数的方法。\n在该方法中第18行、27行，可以看到调用了无参的抽象的 read() 方法。\n总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。\n6.2 策略模式 6.2.1 概述 先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。\n作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。\n定义：\n​\t该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。\n6.2.2 结构 策略模式的主要角色如下：\n抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。 环境（Context）类：持有一个策略类的引用，最终给客户端调用。 6.2.3 案例实现 【例】促销活动\n一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：\n代码如下：\n定义百货公司所有促销活动的共同接口\npublic interface Strategy { void show(); } 定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动\n//为春节准备的促销活动A public class StrategyA implements Strategy { public void show() { System.out.println(\u0026#34;买一送一\u0026#34;); } } //为中秋准备的促销活动B public class StrategyB implements Strategy { public void show() { System.out.println(\u0026#34;满200元减50元\u0026#34;); } } //为圣诞准备的促销活动C public class StrategyC implements Strategy { public void show() { System.out.println(\u0026#34;满1000元加一元换购任意200元以下商品\u0026#34;); } } 定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员\npublic class SalesMan { //持有抽象策略角色的引用 private Strategy strategy; public SalesMan(Strategy strategy) { this.strategy = strategy; } //向客户展示促销活动 public void salesManShow(){ strategy.show(); } } 6.2.4 优缺点 1，优点：\n策略类之间可以自由切换\n由于策略类都实现同一个接口，所以使它们之间可以自由切换。\n易于扩展\n增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“\n避免使用多重条件选择语句（if else），充分体现面向对象设计思想。\n2，缺点：\n客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。 6.2.5 使用场景 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。 6.2.6 JDK源码解析 Comparator 中的策略模式。在Arrays类中有一个 sort() 方法，如下：\npublic class Arrays{ public static \u0026lt;T\u0026gt; void sort(T[] a, Comparator\u0026lt;? super T\u0026gt; c) { if (c == null) { sort(a); } else { if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); } } } Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。\npublic class demo { public static void main(String[] args) { Integer[] data = {12, 2, 3, 2, 4, 5, 1}; // 实现降序排序 Arrays.sort(data, new Comparator\u0026lt;Integer\u0026gt;() { public int compare(Integer o1, Integer o2) { return o2 - o1; } }); System.out.println(Arrays.toString(data)); //[12, 5, 4, 3, 2, 2, 1] } } 这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 compare() 方法吗？让我们继续查看TimSort类的 sort() 方法，代码如下：\nclass TimSort\u0026lt;T\u0026gt; { static \u0026lt;T\u0026gt; void sort(T[] a, int lo, int hi, Comparator\u0026lt;? super T\u0026gt; c, T[] work, int workBase, int workLen) { assert c != null \u0026amp;\u0026amp; a != null \u0026amp;\u0026amp; lo \u0026gt;= 0 \u0026amp;\u0026amp; lo \u0026lt;= hi \u0026amp;\u0026amp; hi \u0026lt;= a.length; int nRemaining = hi - lo; if (nRemaining \u0026lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a \u0026#34;mini-TimSort\u0026#34; with no merges if (nRemaining \u0026lt; MIN_MERGE) { int initRunLen = countRunAndMakeAscending(a, lo, hi, c); binarySort(a, lo, hi, lo + initRunLen, c); return; } ... } private static \u0026lt;T\u0026gt; int countRunAndMakeAscending(T[] a, int lo, int hi,Comparator\u0026lt;? super T\u0026gt; c) { assert lo \u0026lt; hi; int runHi = lo + 1; if (runHi == hi) return 1; // Find end of run, and reverse range if descending if (c.compare(a[runHi++], a[lo]) \u0026lt; 0) { // Descending while (runHi \u0026lt; hi \u0026amp;\u0026amp; c.compare(a[runHi], a[runHi - 1]) \u0026lt; 0) runHi++; reverseRange(a, lo, runHi); } else { // Ascending while (runHi \u0026lt; hi \u0026amp;\u0026amp; c.compare(a[runHi], a[runHi - 1]) \u0026gt;= 0) runHi++; } return runHi - lo; } } 上面的代码中最终会跑到 countRunAndMakeAscending() 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。\n6.3 命令模式 6.3.1 概述 日常生活中，我们出去吃饭都会遇到下面的场景。\n定义：\n将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。\n6.3.2 结构 命令模式包含以下主要角色：\n抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。 具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 6.3.3 案例实现 将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。\n服务员： 就是调用者角色，由她来发起命令。\n资深大厨： 就是接收者角色，真正命令执行的对象。\n订单： 命令中包含订单。\n类图如下：\n代码如下：\npublic interface Command { void execute();//只需要定义一个统一的执行方法 } public class OrderCommand implements Command { //持有接受者对象 private SeniorChef receiver; private Order order; public OrderCommand(SeniorChef receiver, Order order){ this.receiver = receiver; this.order = order; } public void execute() { System.out.println(order.getDiningTable() + \u0026#34;桌的订单：\u0026#34;); Set\u0026lt;String\u0026gt; keys = order.getFoodDic().keySet(); for (String key : keys) { receiver.makeFood(order.getFoodDic().get(key),key); } try { Thread.sleep(100);//停顿一下 模拟做饭的过程 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(order.getDiningTable() + \u0026#34;桌的饭弄好了\u0026#34;); } } public class Order { // 餐桌号码 private int diningTable; // 用来存储餐名并记录份数 private Map\u0026lt;String, Integer\u0026gt; foodDic = new HashMap\u0026lt;String, Integer\u0026gt;(); public int getDiningTable() { return diningTable; } public void setDiningTable(int diningTable) { this.diningTable = diningTable; } public Map\u0026lt;String, Integer\u0026gt; getFoodDic() { return foodDic; } public void setFoodDic(String name, int num) { foodDic.put(name,num); } } // 资深大厨类 是命令的Receiver public class SeniorChef { public void makeFood(int num,String foodName) { System.out.println(num + \u0026#34;份\u0026#34; + foodName); } } public class Waitor { private ArrayList\u0026lt;Command\u0026gt; commands;//可以持有很多的命令对象 public Waitor() { commands = new ArrayList(); } public void setCommand(Command cmd){ commands.add(cmd); } // 发出命令 喊 订单来了，厨师开始执行 public void orderUp() { System.out.println(\u0026#34;美女服务员：叮咚，大厨，新订单来了.......\u0026#34;); for (int i = 0; i \u0026lt; commands.size(); i++) { Command cmd = commands.get(i); if (cmd != null) { cmd.execute(); } } } } public class Client { public static void main(String[] args) { //创建2个order Order order1 = new Order(); order1.setDiningTable(1); order1.getFoodDic().put(\u0026#34;西红柿鸡蛋面\u0026#34;,1); order1.getFoodDic().put(\u0026#34;小杯可乐\u0026#34;,2); Order order2 = new Order(); order2.setDiningTable(3); order2.getFoodDic().put(\u0026#34;尖椒肉丝盖饭\u0026#34;,1); order2.getFoodDic().put(\u0026#34;小杯雪碧\u0026#34;,1); //创建接收者 SeniorChef receiver=new SeniorChef(); //将订单和接收者封装成命令对象 OrderCommand cmd1 = new OrderCommand(receiver, order1); OrderCommand cmd2 = new OrderCommand(receiver, order2); //创建调用者 waitor Waitor invoker = new Waitor(); invoker.setCommand(cmd1); invoker.setCommand(cmd2); //将订单带到柜台 并向厨师喊 订单来了 invoker.orderUp(); } } 6.3.4 优缺点 1，优点：\n降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。 2，缺点：\n使用命令模式可能会导致某些系统有过多的具体命令类。 系统结构更加复杂。 6.3.5 使用场景 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 系统需要在不同的时间指定请求、将请求排队和执行请求。 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 6.3.6 JDK源码解析 Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法\n//命令接口(抽象命令角色) public interface Runnable { public abstract void run(); } //调用者 public class Thread implements Runnable { private Runnable target; public synchronized void start() { if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { } } } private native void start0(); } 会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。\n/** * jdk Runnable 命令模式 *\tTurnOffThread ： 属于具体 */ public class TurnOffThread implements Runnable{ private Receiver receiver; public TurnOffThread(Receiver receiver) { this.receiver = receiver; } public void run() { receiver.turnOFF(); } } /** * 测试类 */ public class Demo { public static void main(String[] args) { Receiver receiver = new Receiver(); TurnOffThread turnOffThread = new TurnOffThread(receiver); Thread thread = new Thread(turnOffThread); thread.start(); } } 6.4 责任链模式 6.4.1 概述 在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。\n定义：\n又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。\n6.4.2 结构 职责链模式主要包含以下角色:\n抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。 6.4.3 案例实现 现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。\n类图如下：\n代码如下：\n//请假条 public class LeaveRequest { private String name;//姓名 private int num;//请假天数 private String content;//请假内容 public LeaveRequest(String name, int num, String content) { this.name = name; this.num = num; this.content = content; } public String getName() { return name; } public int getNum() { return num; } public String getContent() { return content; } } //处理者抽象类 public abstract class Handler { protected final static int NUM_ONE = 1; protected final static int NUM_THREE = 3; protected final static int NUM_SEVEN = 7; //该领导处理的请假天数区间 private int numStart; private int numEnd; //领导上面还有领导 private Handler nextHandler; //设置请假天数范围 上不封顶 public Handler(int numStart) { this.numStart = numStart; } //设置请假天数范围 public Handler(int numStart, int numEnd) { this.numStart = numStart; this.numEnd = numEnd; } //设置上级领导 public void setNextHandler(Handler nextHandler){ this.nextHandler = nextHandler; } //提交请假条 public final void submit(LeaveRequest leave){ if(0 == this.numStart){ return; } //如果请假天数达到该领导者的处理要求 if(leave.getNum() \u0026gt;= this.numStart){ this.handleLeave(leave); //如果还有上级 并且请假天数超过了当前领导的处理范围 if(null != this.nextHandler \u0026amp;\u0026amp; leave.getNum() \u0026gt; numEnd){ this.nextHandler.submit(leave);//继续提交 } else { System.out.println(\u0026#34;流程结束\u0026#34;); } } } //各级领导处理请假条方法 protected abstract void handleLeave(LeaveRequest leave); } //小组长 public class GroupLeader extends Handler { public GroupLeader() { //小组长处理1-3天的请假 super(Handler.NUM_ONE, Handler.NUM_THREE); } @Override protected void handleLeave(LeaveRequest leave) { System.out.println(leave.getName() + \u0026#34;请假\u0026#34; + leave.getNum() + \u0026#34;天,\u0026#34; + leave.getContent() + \u0026#34;。\u0026#34;); System.out.println(\u0026#34;小组长审批：同意。\u0026#34;); } } //部门经理 public class Manager extends Handler { public Manager() { //部门经理处理3-7天的请假 super(Handler.NUM_THREE, Handler.NUM_SEVEN); } @Override protected void handleLeave(LeaveRequest leave) { System.out.println(leave.getName() + \u0026#34;请假\u0026#34; + leave.getNum() + \u0026#34;天,\u0026#34; + leave.getContent() + \u0026#34;。\u0026#34;); System.out.println(\u0026#34;部门经理审批：同意。\u0026#34;); } } //总经理 public class GeneralManager extends Handler { public GeneralManager() { //部门经理处理7天以上的请假 super(Handler.NUM_SEVEN); } @Override protected void handleLeave(LeaveRequest leave) { System.out.println(leave.getName() + \u0026#34;请假\u0026#34; + leave.getNum() + \u0026#34;天,\u0026#34; + leave.getContent() + \u0026#34;。\u0026#34;); System.out.println(\u0026#34;总经理审批：同意。\u0026#34;); } } //测试类 public class Client { public static void main(String[] args) { //请假条来一张 LeaveRequest leave = new LeaveRequest(\u0026#34;小花\u0026#34;,5,\u0026#34;身体不适\u0026#34;); //各位领导 GroupLeader groupLeader = new GroupLeader(); Manager manager = new Manager(); GeneralManager generalManager = new GeneralManager(); groupLeader.setNextHandler(manager);//小组长的领导是部门经理 manager.setNextHandler(generalManager);//部门经理的领导是总经理 //之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。 //提交申请 groupLeader.submit(leave); } } 6.4.4 优缺点 1，优点：\n降低了对象之间的耦合度\n该模式降低了请求发送者和接收者的耦合度。\n增强了系统的可扩展性\n可以根据需要增加新的请求处理类，满足开闭原则。\n增强了给对象指派职责的灵活性\n当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。\n责任链简化了对象之间的连接\n一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。\n责任分担\n每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。\n2，缺点：\n不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。 6.4.5 源码解析 在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析:\n模拟web请求Request以及web响应Response\npublic interface Request{ } public interface Response{ } 模拟web过滤器Filter\npublic interface Filter { public void doFilter(Request req,Response res,FilterChain c); } 模拟实现具体过滤器\npublic class FirstFilter implements Filter { @Override public void doFilter(Request request, Response response, FilterChain chain) { System.out.println(\u0026#34;过滤器1 前置处理\u0026#34;); // 先执行所有request再倒序执行所有response chain.doFilter(request, response); System.out.println(\u0026#34;过滤器1 后置处理\u0026#34;); } } public class SecondFilter implements Filter { @Override public void doFilter(Request request, Response response, FilterChain chain) { System.out.println(\u0026#34;过滤器2 前置处理\u0026#34;); // 先执行所有request再倒序执行所有response chain.doFilter(request, response); System.out.println(\u0026#34;过滤器2 后置处理\u0026#34;); } } 模拟实现过滤器链FilterChain\npublic class FilterChain { private List\u0026lt;Filter\u0026gt; filters = new ArrayList\u0026lt;Filter\u0026gt;(); private int index = 0; // 链式调用 public FilterChain addFilter(Filter filter) { this.filters.add(filter); return this; } public void doFilter(Request request, Response response) { if (index == filters.size()) { return; } Filter filter = filters.get(index); index++; filter.doFilter(request, response, this); } } 测试类\npublic class Client { public static void main(String[] args) { Request req = null; Response res = null ; FilterChain filterChain = new FilterChain(); filterChain.addFilter(new FirstFilter()).addFilter(new SecondFilter()); filterChain.doFilter(req,res); } } 6.5 状态模式 6.5.1 概述 【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。\n类图如下：\n代码如下：\npublic interface ILift { //电梯的4个状态 //开门状态 public final static int OPENING_STATE = 1; //关门状态 public final static int CLOSING_STATE = 2; //运行状态 public final static int RUNNING_STATE = 3; //停止状态 public final static int STOPPING_STATE = 4; //设置电梯的状态 public void setState(int state); //电梯的动作 public void open(); public void close(); public void run(); public void stop(); } public class Lift implements ILift { private int state; @Override public void setState(int state) { this.state = state; } //执行关门动作 @Override public void close() { switch (this.state) { case OPENING_STATE: System.out.println(\u0026#34;电梯关门了。。。\u0026#34;);//只有开门状态可以关闭电梯门，可以对应电梯状态表来看 this.setState(CLOSING_STATE);//关门之后电梯就是关闭状态了 break; case CLOSING_STATE: //do nothing //已经是关门状态，不能关门 break; case RUNNING_STATE: //do nothing //运行时电梯门是关着的，不能关门 break; case STOPPING_STATE: //do nothing //停止时电梯也是关着的，不能关门 break; } } //执行开门动作 @Override public void open() { switch (this.state) { case OPENING_STATE://门已经开了，不能再开门了 //do nothing break; case CLOSING_STATE://关门状态，门打开: System.out.println(\u0026#34;电梯门打开了。。。\u0026#34;); this.setState(OPENING_STATE); break; case RUNNING_STATE: //do nothing 运行时电梯不能开门 break; case STOPPING_STATE: System.out.println(\u0026#34;电梯门开了。。。\u0026#34;);//电梯停了，可以开门了 this.setState(OPENING_STATE); break; } } //执行运行动作 @Override public void run() { switch (this.state) { case OPENING_STATE://电梯不能开着门就走 //do nothing break; case CLOSING_STATE://门关了，可以运行了 System.out.println(\u0026#34;电梯开始运行了。。。\u0026#34;); this.setState(RUNNING_STATE);//现在是运行状态 break; case RUNNING_STATE: //do nothing 已经是运行状态了 break; case STOPPING_STATE: System.out.println(\u0026#34;电梯开始运行了。。。\u0026#34;); this.setState(RUNNING_STATE); break; } } //执行停止动作 @Override public void stop() { switch (this.state) { case OPENING_STATE: //开门的电梯已经是是停止的了(正常情况下) //do nothing break; case CLOSING_STATE://关门时才可以停止 System.out.println(\u0026#34;电梯停止了。。。\u0026#34;); this.setState(STOPPING_STATE); break; case RUNNING_STATE://运行时当然可以停止了 System.out.println(\u0026#34;电梯停止了。。。\u0026#34;); this.setState(STOPPING_STATE); break; case STOPPING_STATE: //do nothing break; } } } public class Client { public static void main(String[] args) { Lift lift = new Lift(); lift.setState(ILift.STOPPING_STATE);//电梯是停止的 lift.open();//开门 lift.close();//关门 lift.run();//运行 lift.stop();//停止 } } 问题分析：\n使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。 扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑 定义：\n对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。\n6.5.2 结构 状态模式包含以下主要角色。\n环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。 具体状态（Concrete State）角色：实现抽象状态所对应的行为。 6.5.3 案例实现 对上述电梯的案例使用状态模式进行改进。类图如下：\n代码如下：\n//抽象状态类 public abstract class LiftState { //定义一个环境角色，也就是封装状态的变化引起的功能变化 protected Context context; public void setContext(Context context) { this.context = context; } //电梯开门动作 public abstract void open(); //电梯关门动作 public abstract void close(); //电梯运行动作 public abstract void run(); //电梯停止动作 public abstract void stop(); } //开启状态 public class OpenningState extends LiftState { //开启当然可以关闭了，我就想测试一下电梯门开关功能 @Override public void open() { System.out.println(\u0026#34;电梯门开启...\u0026#34;); } @Override public void close() { //状态修改 super.context.setLiftState(Context.closeingState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().close(); } //电梯门不能开着就跑，这里什么也不做 @Override public void run() { //do nothing } //开门状态已经是停止的了 @Override public void stop() { //do nothing } } //运行状态 public class RunningState extends LiftState { //运行的时候开电梯门？你疯了！电梯不会给你开的 @Override public void open() { //do nothing } //电梯门关闭？这是肯定了 @Override public void close() {//虽然可以关门，但这个动作不归我执行 //do nothing } //这是在运行状态下要实现的方法 @Override public void run() { System.out.println(\u0026#34;电梯正在运行...\u0026#34;); } //这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了 @Override public void stop() { super.context.setLiftState(Context.stoppingState); super.context.stop(); } } //停止状态 public class StoppingState extends LiftState { //停止状态，开门，那是要的！ @Override public void open() { //状态修改 super.context.setLiftState(Context.openningState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().open(); } @Override public void close() {//虽然可以关门，但这个动作不归我执行 //状态修改 super.context.setLiftState(Context.closeingState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().close(); } //停止状态再跑起来，正常的很 @Override public void run() { //状态修改 super.context.setLiftState(Context.runningState); //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作 super.context.getLiftState().run(); } //停止状态是怎么发生的呢？当然是停止方法执行了 @Override public void stop() { System.out.println(\u0026#34;电梯停止了...\u0026#34;); } } //关闭状态 public class ClosingState extends LiftState { @Override //电梯门关闭，这是关闭状态要实现的动作 public void close() { System.out.println(\u0026#34;电梯门关闭...\u0026#34;); } //电梯门关了再打开，逗你玩呢，那这个允许呀 @Override public void open() { super.context.setLiftState(Context.openningState); super.context.open(); } //电梯门关了就跑，这是再正常不过了 @Override public void run() { super.context.setLiftState(Context.runningState); super.context.run(); } //电梯门关着，我就不按楼层 @Override public void stop() { super.context.setLiftState(Context.stoppingState); super.context.stop(); } } //环境角色 public class Context { //定义出所有的电梯状态 public final static OpenningState openningState = new OpenningState();//开门状态，这时候电梯只能关闭 public final static ClosingState closeingState = new ClosingState();//关闭状态，这时候电梯可以运行、停止和开门 public final static RunningState runningState = new RunningState();//运行状态，这时候电梯只能停止 public final static StoppingState stoppingState = new StoppingState();//停止状态，这时候电梯可以开门、运行 //定义一个当前电梯状态 private LiftState liftState; public LiftState getLiftState() { return this.liftState; } public void setLiftState(LiftState liftState) { //当前环境改变 this.liftState = liftState; //把当前的环境通知到各个实现类中 this.liftState.setContext(this); } public void open() { this.liftState.open(); } public void close() { this.liftState.close(); } public void run() { this.liftState.run(); } public void stop() { this.liftState.stop(); } } //测试类 public class Client { public static void main(String[] args) { Context context = new Context(); context.setLiftState(new ClosingState()); context.open(); context.close(); context.run(); context.stop(); } } 6.5.4 优缺点 1，优点：\n将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 2，缺点：\n状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对\u0026quot;开闭原则\u0026quot;的支持并不太好。 6.5.5 使用场景 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。 6.6 观察者模式 6.6.1 概述 定义：\n又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。\n6.6.2 结构 在观察者模式中有如下角色：\nSubject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。 Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。 ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 6.6.3 案例实现 【例】微信公众号\n在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。\n类图如下：\n代码如下：\n定义抽象观察者类，里面定义一个更新的方法\npublic interface Observer { void update(String message); } 定义具体观察者类，微信用户是观察者，里面实现了更新的方法\npublic class WeixinUser implements Observer { // 微信用户名 private String name; public WeixinUser(String name) { this.name = name; } @Override public void update(String message) { System.out.println(name + \u0026#34;-\u0026#34; + message); } } 定义抽象主题类，提供了attach、detach、notify三个方法\npublic interface Subject { //增加订阅者 public void attach(Observer observer); //删除订阅者 public void detach(Observer observer); //通知订阅者更新消息 public void notify(String message); } 微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法\npublic class SubscriptionSubject implements Subject { //储存订阅公众号的微信用户 private List\u0026lt;Observer\u0026gt; weixinUserlist = new ArrayList\u0026lt;Observer\u0026gt;(); @Override public void attach(Observer observer) { weixinUserlist.add(observer); } @Override public void detach(Observer observer) { weixinUserlist.remove(observer); } @Override public void notify(String message) { for (Observer observer : weixinUserlist) { observer.update(message); } } } 客户端程序\npublic class Client { public static void main(String[] args) { SubscriptionSubject mSubscriptionSubject=new SubscriptionSubject(); //创建微信用户 WeixinUser user1=new WeixinUser(\u0026#34;孙悟空\u0026#34;); WeixinUser user2=new WeixinUser(\u0026#34;猪悟能\u0026#34;); WeixinUser user3=new WeixinUser(\u0026#34;沙悟净\u0026#34;); //订阅公众号 mSubscriptionSubject.attach(user1); mSubscriptionSubject.attach(user2); mSubscriptionSubject.attach(user3); //公众号更新发出消息给订阅的微信用户 mSubscriptionSubject.notify(\u0026#34;传智黑马的专栏更新了\u0026#34;); } } 6.6.4 优缺点 1，优点：\n降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。 被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】 2，缺点：\n如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时 如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃 6.6.5 使用场景 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。 6.6.6 JDK中提供的实现 在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。\n1，Observable类\nObservable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。\nvoid addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。\nvoid notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。\nvoid setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。\n2，Observer 接口\nObserver 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。\n【例】警察抓小偷\n警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：\n小偷是一个被观察者，所以需要继承Observable类\npublic class Thief extends Observable { private String name; public Thief(String name) { this.name = name; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void steal() { System.out.println(\u0026#34;小偷：我偷东西了，有没有人来抓我！！！\u0026#34;); super.setChanged(); //changed = true super.notifyObservers(); } } 警察是一个观察者，所以需要让其实现Observer接口\npublic class Policemen implements Observer { private String name; public Policemen(String name) { this.name = name; } public void setName(String name) { this.name = name; } public String getName() { return name; } @Override public void update(Observable o, Object arg) { System.out.println(\u0026#34;警察：\u0026#34; + ((Thief) o).getName() + \u0026#34;，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！\u0026#34;); } } 客户端代码\npublic class Client { public static void main(String[] args) { //创建小偷对象 Thief t = new Thief(\u0026#34;隔壁老王\u0026#34;); //创建警察对象 Policemen p = new Policemen(\u0026#34;小李\u0026#34;); //让警察盯着小偷 t.addObserver(p); //小偷偷东西 t.steal(); } } 6.7 中介者模式 6.7.1 概述 一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。\n如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。\n定义：\n又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。\n6.7.2 结构 中介者模式包含以下主要角色：\n抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。\n具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。\n抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。\n具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。\n6.7.3 案例实现 【例】租房\n现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。\n类图如下：\n代码如下：\n//抽象中介者 public abstract class Mediator { //申明一个联络方法 public abstract void constact(String message,Person person); } //抽象同事类 public abstract class Person { protected String name; protected Mediator mediator; public Person(String name,Mediator mediator){ this.name = name; this.mediator = mediator; } } //具体同事类 房屋拥有者 public class HouseOwner extends Person { public HouseOwner(String name, Mediator mediator) { super(name, mediator); } //与中介者联系 public void constact(String message){ mediator.constact(message, this); } //获取信息 public void getMessage(String message){ System.out.println(\u0026#34;房主\u0026#34; + name +\u0026#34;获取到的信息：\u0026#34; + message); } } //具体同事类 承租人 public class Tenant extends Person { public Tenant(String name, Mediator mediator) { super(name, mediator); } //与中介者联系 public void constact(String message){ mediator.constact(message, this); } //获取信息 public void getMessage(String message){ System.out.println(\u0026#34;租房者\u0026#34; + name +\u0026#34;获取到的信息：\u0026#34; + message); } } //中介机构 public class MediatorStructure extends Mediator { //首先中介结构必须知道所有房主和租房者的信息 private HouseOwner houseOwner; private Tenant tenant; public HouseOwner getHouseOwner() { return houseOwner; } public void setHouseOwner(HouseOwner houseOwner) { this.houseOwner = houseOwner; } public Tenant getTenant() { return tenant; } public void setTenant(Tenant tenant) { this.tenant = tenant; } public void constact(String message, Person person) { if (person == houseOwner) { //如果是房主，则租房者获得信息 tenant.getMessage(message); } else { //反正则是房主获得信息 houseOwner.getMessage(message); } } } //测试类 public class Client { public static void main(String[] args) { //一个房主、一个租房者、一个中介机构 MediatorStructure mediator = new MediatorStructure(); //房主和租房者只需要知道中介机构即可 HouseOwner houseOwner = new HouseOwner(\u0026#34;张三\u0026#34;, mediator); Tenant tenant = new Tenant(\u0026#34;李四\u0026#34;, mediator); //中介结构要知道房主和租房者 mediator.setHouseOwner(houseOwner); mediator.setTenant(tenant); tenant.constact(\u0026#34;需要租三室的房子\u0026#34;); houseOwner.constact(\u0026#34;我这有三室的房子，你需要租吗？\u0026#34;); } } 6.7.4 优缺点 1，优点：\n松散耦合\n中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。\n集中控制交互\n多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。\n一对多关联转变为一对一的关联\n没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。\n2，缺点：\n当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。\n6.7.5 使用场景 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。 当想创建一个运行于多个类之间的对象，又不想生成新的子类时。 6.8 迭代器模式 6.8.1 概述 定义：\n提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n6.8.2 结构 迭代器模式主要包含以下角色：\n抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。\n具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。\n抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。\n具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。\n6.8.3 案例实现 【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：\n代码如下：\n定义迭代器接口，声明hasNext、next方法\npublic interface StudentIterator { boolean hasNext(); Student next(); } 定义具体的迭代器类，重写所有的抽象方法\npublic class StudentIteratorImpl implements StudentIterator { private List\u0026lt;Student\u0026gt; list; private int position = 0; public StudentIteratorImpl(List\u0026lt;Student\u0026gt; list) { this.list = list; } @Override public boolean hasNext() { return position \u0026lt; list.size(); } @Override public Student next() { Student currentStudent = list.get(position); position ++; return currentStudent; } } 定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法\npublic interface StudentAggregate { void addStudent(Student student); void removeStudent(Student student); StudentIterator getStudentIterator(); } 定义具体的容器类，重写所有的方法\npublic class StudentAggregateImpl implements StudentAggregate { private List\u0026lt;Student\u0026gt; list = new ArrayList\u0026lt;Student\u0026gt;(); // 学生列表 @Override public void addStudent(Student student) { this.list.add(student); } @Override public void removeStudent(Student student) { this.list.remove(student); } @Override public StudentIterator getStudentIterator() { return new StudentIteratorImpl(list); } } 6.8.4 优缺点 1，优点：\n它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。 2，缺点：\n增加了类的个数，这在一定程度上增加了系统的复杂性。\n6.8.5 使用场景 当需要为聚合对象提供多种遍历方式时。 当需要为遍历不同的聚合结构提供一个统一的接口时。 当访问一个聚合对象的内容而无须暴露其内部细节的表示时。 6.8.6 JDK源码解析 迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。\nList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); //list.iterator()方法返回的肯定是Iterator接口的子实现类对象 while (iterator.hasNext()) { System.out.println(iterator.next()); } 看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明\nList：抽象聚合类 ArrayList：具体的聚合类 Iterator：抽象迭代器 list.iterator()：返回的是实现了 Iterator 接口的具体迭代器对象 具体的来看看 ArrayList的代码实现\npublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } private class Itr implements Iterator\u0026lt;E\u0026gt; { int cursor; // 下一个要返回元素的索引 int lastRet = -1; // 上一个返回元素的索引 int expectedModCount = modCount; Itr() {} //判断是否还有元素 public boolean hasNext() { return cursor != size; } //获取下一个元素 public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } ... } 这部分代码还是比较简单，大致就是在 iterator 方法中返回了一个实例化的 Iterator 对象。Itr是一个内部类，它实现了 Iterator 接口并重写了其中的抽象方法。\n注意：\n​\t当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现java.util.Iterable并实现其中的iterator()方法使其返回一个 java.util.Iterator 的实现类就可以了。\n6.9 访问者模式 6.9.1 概述 定义：\n封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。\n6.9.2 结构 访问者模式包含以下主要角色:\n抽象访问者（Visitor）角色：定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。 抽象元素（Element）角色：定义了一个接受访问者的方法（accept），其意义是指，每一个元素都要可以被访问者访问。 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问。 6.9.3 案例实现 【例】给宠物喂食\n现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。\n访问者角色：给宠物喂食的人 具体访问者角色：主人、其他人 抽象元素角色：动物抽象类 具体元素角色：宠物狗、宠物猫 结构对象角色：主人家 类图如下：\n代码如下：\n创建抽象访问者接口\npublic interface Person { void feed(Cat cat); void feed(Dog dog); } 创建不同的具体访问者角色（主人和其他人），都需要实现 Person接口\npublic class Owner implements Person { @Override public void feed(Cat cat) { System.out.println(\u0026#34;主人喂食猫\u0026#34;); } @Override public void feed(Dog dog) { System.out.println(\u0026#34;主人喂食狗\u0026#34;); } } public class Someone implements Person { @Override public void feed(Cat cat) { System.out.println(\u0026#34;其他人喂食猫\u0026#34;); } @Override public void feed(Dog dog) { System.out.println(\u0026#34;其他人喂食狗\u0026#34;); } } 定义抽象节点 \u0026ndash; 宠物\npublic interface Animal { void accept(Person person); } 定义实现Animal接口的 具体节点（元素）\npublic class Dog implements Animal { @Override public void accept(Person person) { person.feed(this); System.out.println(\u0026#34;好好吃，汪汪汪！！！\u0026#34;); } } public class Cat implements Animal { @Override public void accept(Person person) { person.feed(this); System.out.println(\u0026#34;好好吃，喵喵喵！！！\u0026#34;); } } 定义对象结构，此案例中就是主人的家\npublic class Home { private List\u0026lt;Animal\u0026gt; nodeList = new ArrayList\u0026lt;Animal\u0026gt;(); public void action(Person person) { for (Animal node : nodeList) { node.accept(person); } } //添加操作 public void add(Animal animal) { nodeList.add(animal); } } 测试类\npublic class Client { public static void main(String[] args) { Home home = new Home(); home.add(new Dog()); home.add(new Cat()); Owner owner = new Owner(); home.action(owner); Someone someone = new Someone(); home.action(someone); } } 6.9.4 优缺点 1，优点：\n扩展性好\n在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。\n复用性好\n通过访问者来定义整个对象结构通用的功能，从而提高复用程度。\n分离无关行为\n通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。\n2，缺点：\n对象结构变化很困难\n在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。\n违反了依赖倒置原则\n访问者模式依赖了具体类，而没有依赖抽象类。\n6.9.5 使用场景 对象结构相对稳定，但其操作算法经常变化的程序。\n对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。\n6.9.6 扩展 访问者模式用到了一种双分派的技术。\n1，分派：\n变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 Map map = new HashMap() ，map变量的静态类型是 Map ，实际类型是 HashMap 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。\n静态分派(Static Dispatch) 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。\n动态分派(Dynamic Dispatch) 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。\n2，动态分派：\n通过方法的重写支持动态分派。\npublic class Animal { public void execute() { System.out.println(\u0026#34;Animal\u0026#34;); } } public class Dog extends Animal { @Override public void execute() { System.out.println(\u0026#34;dog\u0026#34;); } } public class Cat extends Animal { @Override public void execute() { System.out.println(\u0026#34;cat\u0026#34;); } } public class Client { public static void main(String[] args) { Animal a = new Dog(); a.execute(); Animal a1 = new Cat(); a1.execute(); } } 上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。\nJava编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。\n3，静态分派：\n通过方法重载支持静态分派。\npublic class Animal { } public class Dog extends Animal { } public class Cat extends Animal { } public class Execute { public void execute(Animal a) { System.out.println(\u0026#34;Animal\u0026#34;); } public void execute(Dog d) { System.out.println(\u0026#34;dog\u0026#34;); } public void execute(Cat c) { System.out.println(\u0026#34;cat\u0026#34;); } } public class Client { public static void main(String[] args) { Animal a = new Animal(); Animal a1 = new Dog(); Animal a2 = new Cat(); Execute exe = new Execute(); exe.execute(a); exe.execute(a1); exe.execute(a2); } } 运行结果：\n这个结果可能出乎一些人的意料了，为什么呢？\n重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。\n4，双分派：\n所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。\npublic class Animal { public void accept(Execute exe) { exe.execute(this); } } public class Dog extends Animal { public void accept(Execute exe) { exe.execute(this); } } public class Cat extends Animal { public void accept(Execute exe) { exe.execute(this); } } public class Execute { public void execute(Animal a) { System.out.println(\u0026#34;animal\u0026#34;); } public void execute(Dog d) { System.out.println(\u0026#34;dog\u0026#34;); } public void execute(Cat c) { System.out.println(\u0026#34;cat\u0026#34;); } } public class Client { public static void main(String[] args) { Animal a = new Animal(); Animal d = new Dog(); Animal c = new Cat(); Execute exe = new Execute(); a.accept(exe); d.accept(exe); c.accept(exe); } } 在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也将自己this作为参数传递进去，这里就完成了第二次分派，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。\n说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。\n运行结果如下：\n双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。\n6.10 备忘录模式 6.10.1 概述 备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。\n定义：\n又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。\n6.10.2 结构 备忘录模式的主要角色如下：\n发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。 备忘录有两个等效的接口：\n窄接口：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。 宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。 6.10.3 案例实现 【例】游戏挑战BOSS\n游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。\n要实现上述案例，有两种方式：\n“白箱”备忘录模式 “黑箱”备忘录模式 6.10.3.1 “白箱”备忘录模式 备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：\n代码如下：\n//游戏角色类 public class GameRole { private int vit; //生命力 private int atk; //攻击力 private int def; //防御力 //初始化状态 public void initState() { this.vit = 100; this.atk = 100; this.def = 100; } //战斗 public void fight() { this.vit = 0; this.atk = 0; this.def = 0; } //保存角色状态 public RoleStateMemento saveState() { return new RoleStateMemento(vit, atk, def); } //回复角色状态 public void recoverState(RoleStateMemento roleStateMemento) { this.vit = roleStateMemento.getVit(); this.atk = roleStateMemento.getAtk(); this.def = roleStateMemento.getDef(); } public void stateDisplay() { System.out.println(\u0026#34;角色生命力：\u0026#34; + vit); System.out.println(\u0026#34;角色攻击力：\u0026#34; + atk); System.out.println(\u0026#34;角色防御力：\u0026#34; + def); } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getAtk() { return atk; } public void setAtk(int atk) { this.atk = atk; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } //游戏状态存储类(备忘录类) public class RoleStateMemento { private int vit; private int atk; private int def; public RoleStateMemento(int vit, int atk, int def) { this.vit = vit; this.atk = atk; this.def = def; } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getAtk() { return atk; } public void setAtk(int atk) { this.atk = atk; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } //角色状态管理者类 public class RoleStateCaretaker { private RoleStateMemento roleStateMemento; public RoleStateMemento getRoleStateMemento() { return roleStateMemento; } public void setRoleStateMemento(RoleStateMemento roleStateMemento) { this.roleStateMemento = roleStateMemento; } } //测试类 public class Client { public static void main(String[] args) { System.out.println(\u0026#34;------------大战Boss前------------\u0026#34;); //大战Boss前 GameRole gameRole = new GameRole(); gameRole.initState(); gameRole.stateDisplay(); //保存进度 RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker(); roleStateCaretaker.setRoleStateMemento(gameRole.saveState()); System.out.println(\u0026#34;------------大战Boss后------------\u0026#34;); //大战Boss时，损耗严重 gameRole.fight(); gameRole.stateDisplay(); System.out.println(\u0026#34;------------恢复之前状态------------\u0026#34;); //恢复之前状态 gameRole.recoverState(roleStateCaretaker.getRoleStateMemento()); gameRole.stateDisplay(); } } 分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。\n6.10.3.2 “黑箱”备忘录模式 备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将备忘录类设计成发起人类的内部成员类。\n将 RoleStateMemento 设为 GameRole 的内部类，从而将 RoleStateMemento 对象封装在 GameRole 里面；在外面提供一个标识接口 Memento 给 RoleStateCaretaker 及其他对象使用。这样 GameRole 类看到的是 RoleStateMemento 所有的接口，而RoleStateCaretaker 及其他对象看到的仅仅是标识接口 Memento 所暴露出来的接口，从而维护了封装型。类图如下：\n代码如下：\n窄接口Memento，这是一个标识接口，因此没有定义出任何的方法\npublic interface Memento { } 定义发起人类 GameRole，并在内部定义备忘录内部类 RoleStateMemento（该内部类设置为私有的）\n/游戏角色类 public class GameRole { private int vit; //生命力 private int atk; //攻击力 private int def; //防御力 //初始化状态 public void initState() { this.vit = 100; this.atk = 100; this.def = 100; } //战斗 public void fight() { this.vit = 0; this.atk = 0; this.def = 0; } //保存角色状态 public Memento saveState() { return new RoleStateMemento(vit, atk, def); } //回复角色状态 public void recoverState(Memento memento) { RoleStateMemento roleStateMemento = (RoleStateMemento) memento; this.vit = roleStateMemento.getVit(); this.atk = roleStateMemento.getAtk(); this.def = roleStateMemento.getDef(); } public void stateDisplay() { System.out.println(\u0026#34;角色生命力：\u0026#34; + vit); System.out.println(\u0026#34;角色攻击力：\u0026#34; + atk); System.out.println(\u0026#34;角色防御力：\u0026#34; + def); } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getAtk() { return atk; } public void setAtk(int atk) { this.atk = atk; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } private class RoleStateMemento implements Memento { private int vit; private int atk; private int def; public RoleStateMemento(int vit, int atk, int def) { this.vit = vit; this.atk = atk; this.def = def; } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getAtk() { return atk; } public void setAtk(int atk) { this.atk = atk; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } } 负责人角色类 RoleStateCaretaker 能够得到的备忘录对象是以 Memento 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容\n//角色状态管理者类 public class RoleStateCaretaker { private Memento memento; public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } 客户端测试类\npublic class Client { public static void main(String[] args) { System.out.println(\u0026#34;------------大战Boss前------------\u0026#34;); //大战Boss前 GameRole gameRole = new GameRole(); gameRole.initState(); gameRole.stateDisplay(); //保存进度 RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker(); roleStateCaretaker.setMemento(gameRole.saveState()); System.out.println(\u0026#34;------------大战Boss后------------\u0026#34;); //大战Boss时，损耗严重 gameRole.fight(); gameRole.stateDisplay(); System.out.println(\u0026#34;------------恢复之前状态------------\u0026#34;); //恢复之前状态 gameRole.recoverState(roleStateCaretaker.getMemento()); gameRole.stateDisplay(); } } 6.10.4 优缺点 1，优点：\n提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。 2，缺点：\n资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 6.10.5 使用场景 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。\n需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。\n6.11 解释器模式 6.11.1 概述 如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。\n//用于两个整数相加 public static int add(int a,int b){ return a + b; } //用于两个整数相加 public static int add(int a,int b,int c){ return a + b + c; } //用于n个整数相加 public static int add(Integer ... arr) { int sum = 0; for (Integer i : arr) { sum += i; } return sum; } 上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。\n显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。\n定义：\n给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。\n解释器就是要解析出来语句的含义。但是如何描述规则呢？\n文法（语法）规则：\n文法是用于描述语言的语法结构的形式规则。\nexpression ::= value | plus | minus\rplus ::= expression ‘+’ expression minus ::= expression ‘-’ expression value ::= integer 注意： 这里的符号“::=”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。\n上面规则描述为 ：\n表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。\n抽象语法树：\n在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。\n用树形来表示符合文法规则的句子。\n6.11.2 结构 解释器模式包含以下主要角色。\n抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。\n终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。\n非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。\n环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。\n客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。\n6.11.3 案例实现 【例】设计实现加减法的软件\n代码如下：\n//抽象角色AbstractExpression public abstract class AbstractExpression { public abstract int interpret(Context context); } //终结符表达式角色 public class Value extends AbstractExpression { private int value; public Value(int value) { this.value = value; } @Override public int interpret(Context context) { return value; } @Override public String toString() { return new Integer(value).toString(); } } //非终结符表达式角色 加法表达式 public class Plus extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public Plus(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret(Context context) { return left.interpret(context) + right.interpret(context); } @Override public String toString() { return \u0026#34;(\u0026#34; + left.toString() + \u0026#34; + \u0026#34; + right.toString() + \u0026#34;)\u0026#34;; } } ///非终结符表达式角色 减法表达式 public class Minus extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public Minus(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret(Context context) { return left.interpret(context) - right.interpret(context); } @Override public String toString() { return \u0026#34;(\u0026#34; + left.toString() + \u0026#34; - \u0026#34; + right.toString() + \u0026#34;)\u0026#34;; } } //终结符表达式角色 变量表达式 public class Variable extends AbstractExpression { private String name; public Variable(String name) { this.name = name; } @Override public int interpret(Context ctx) { return ctx.getValue(this); } @Override public String toString() { return name; } } //环境类 public class Context { private Map\u0026lt;Variable, Integer\u0026gt; map = new HashMap\u0026lt;Variable, Integer\u0026gt;(); public void assign(Variable var, Integer value) { map.put(var, value); } public int getValue(Variable var) { Integer value = map.get(var); return value; } } //测试类 public class Client { public static void main(String[] args) { Context context = new Context(); Variable a = new Variable(\u0026#34;a\u0026#34;); Variable b = new Variable(\u0026#34;b\u0026#34;); Variable c = new Variable(\u0026#34;c\u0026#34;); Variable d = new Variable(\u0026#34;d\u0026#34;); Variable e = new Variable(\u0026#34;e\u0026#34;); //Value v = new Value(1); context.assign(a, 1); context.assign(b, 2); context.assign(c, 3); context.assign(d, 4); context.assign(e, 5); AbstractExpression expression = new Minus(new Plus(new Plus(new Plus(a, b), c), d), e); System.out.println(expression + \u0026#34;= \u0026#34; + expression.interpret(context)); } } 6.11.4 优缺点 1，优点：\n易于改变和扩展文法。\n由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。\n实现文法较为容易。\n在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。\n增加新的解释表达式较为方便。\n如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 \u0026ldquo;开闭原则\u0026rdquo;。\n2，缺点：\n对于复杂文法难以维护。\n在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。\n执行效率较低。\n由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。\n6.11.5 使用场景 当语言的文法较为简单，且执行效率不是关键问题时。\n当问题重复出现，且可以用一种简单的语言来进行表达时。\n当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。\n7，自定义Spring框架 7.1 spring使用回顾 自定义spring框架前，先回顾一下spring框架的使用，从而分析spring的核心，并对核心功能进行模拟。\n数据访问层。定义UserDao接口及其子实现类\npublic interface UserDao { public void add(); } public class UserDaoImpl implements UserDao { public void add() { System.out.println(\u0026#34;userDaoImpl ....\u0026#34;); } } 业务逻辑层。定义UserService接口及其子实现类\npublic interface UserService { public void add(); } public class UserServiceImpl implements UserService { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add() { System.out.println(\u0026#34;userServiceImpl ...\u0026#34;); userDao.add(); } } 定义UserController类，使用main方法模拟controller层\npublic class UserController { public static void main(String[] args) { //创建spring容器对象 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); //从IOC容器中获取UserService对象 UserService userService = applicationContext.getBean(\u0026#34;userService\u0026#34;, UserService.class); //调用UserService对象的add方法 userService.add(); } } 编写配置文件。在类路径下编写一个名为ApplicationContext.xml的配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.itheima.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.itheima.dao.impl.UserDaoImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 代码运行结果如下：\n通过上面代码及结果可以看出：\nuserService对象是从applicationContext容器对象获取到的，也就是userService对象交由spring进行管理。 上面结果可以看到调用了UserDao对象中的add方法，也就是说UserDao子实现类对象也交由spring管理了。 UserService中的userDao变量我们并没有进行赋值，但是可以正常使用，说明spring已经将UserDao对象赋值给了userDao变量。 上面三点体现了Spring框架的IOC（Inversion of Control）和DI（Dependency Injection, DI）\n7.2 spring核心功能结构 Spring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为:\n核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是 Spring 框架的总体架构图：\n核心容器由 beans、core、context 和 expression（Spring Expression Language，SpEL）4个模块组成。\nspring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。BeanFactory属于延时加载，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该 Bean 进行实例化与依赖关系的装配。 spring-context模块构架于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，它的超类是 BeanFactory。与BeanFactory不同，ApplicationContext实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。 spring-context-support模块是对Spring IoC容器及IoC子容器的扩展支持。 spring-context-indexer模块是Spring的类管理组件和Classpath扫描组件。 spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同Spring IoC进行交互。 7.1.1 bean概述 Spring 就是面向 Bean 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring IoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。\nspring中bean用于对一个类进行封装。如下面的配置：\n\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.itheima.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.itheima.dao.impl.UserDaoImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 为什么Bean如此重要呢？\nspring 将bean对象交由一个叫IOC容器进行管理。 bean对象之间的依赖关系在配置文件中体现，并由spring完成。 7.3 Spring IOC相关接口分析 7.3.1 BeanFactory解析 Spring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。\n其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。\n那么为何要定义这么多层次的接口呢？\n每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如，\nListableBeanFactory接口表示这些Bean可列表化。 HierarchicalBeanFactory表示这些Bean 是有继承关系的，也就是每个 Bean 可能有父 Bean AutowireCapableBeanFactory 接口定义Bean的自动装配规则。 这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是BeanFactory，来看一下它的源码：\npublic interface BeanFactory { String FACTORY_BEAN_PREFIX = \u0026#34;\u0026amp;\u0026#34;; //根据bean的名称获取IOC容器中的的bean对象 Object getBean(String name) throws BeansException; //根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了 \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; \u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; requiredType) throws BeansException; \u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; requiredType, Object... args) throws BeansException; \u0026lt;T\u0026gt; ObjectProvider\u0026lt;T\u0026gt; getBeanProvider(Class\u0026lt;T\u0026gt; requiredType); \u0026lt;T\u0026gt; ObjectProvider\u0026lt;T\u0026gt; getBeanProvider(ResolvableType requiredType); //判断容器中是否包含指定名称的bean对象 boolean containsBean(String name); //根据bean的名称判断是否是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class\u0026lt;?\u0026gt; typeToMatch) throws NoSuchBeanDefinitionException; @Nullable Class\u0026lt;?\u0026gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name); } 在BeanFactory里只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。\nBeanFactory有一个很重要的子接口，就是ApplicationContext接口，该接口主要来规范容器中的bean对象是非延时加载，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。\n要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如：\nClasspathXmlApplicationContext : 根据类路径加载xml配置文件，并创建IOC容器对象。 FileSystemXmlApplicationContext ：根据系统路径加载xml配置文件，并创建IOC容器对象。 AnnotationConfigApplicationContext ：加载注解类配置，并创建IOC容器。 7.3.2 BeanDefinition解析 Spring IoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以BeanDefinition来描述的，如下面配置文件\n\u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.itheima.dao.impl.UserDaoImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; bean标签还有很多属性： scope、init-method、destory-method等。 其继承体系如下图所示。\n7.3.3 BeanDefinitionReader解析 Bean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。\n看看BeanDefinitionReader接口定义的功能来理解它具体的作用：\npublic interface BeanDefinitionReader { //获取BeanDefinitionRegistry注册器对象 BeanDefinitionRegistry getRegistry(); @Nullable ResourceLoader getResourceLoader(); @Nullable ClassLoader getBeanClassLoader(); BeanNameGenerator getBeanNameGenerator(); /* 下面的loadBeanDefinitions都是加载bean定义，从指定的资源中 */ int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException; int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException; int loadBeanDefinitions(String location) throws BeanDefinitionStoreException; int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException; } 7.3.4 BeanDefinitionRegistry解析 BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry。\npublic interface BeanDefinitionRegistry extends AliasRegistry { //往注册表中注册bean void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException; //从注册表中删除指定名称的bean void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; //获取注册表中指定名称的bean BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; //判断注册表中是否已经注册了指定名称的bean boolean containsBeanDefinition(String beanName); //获取注册表中所有的bean的名称 String[] getBeanDefinitionNames(); int getBeanDefinitionCount(); boolean isBeanNameInUse(String beanName); } 继承结构图如下：\n从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个：\nDefaultListableBeanFactory\n在该类中定义了如下代码，就是用来注册bean\nprivate final Map\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap = new ConcurrentHashMap\u0026lt;\u0026gt;(256); SimpleBeanDefinitionRegistry\n在该类中定义了如下代码，就是用来注册bean\nprivate final Map\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap = new ConcurrentHashMap\u0026lt;\u0026gt;(64); 7.3.5 创建容器 ClassPathXmlApplicationContext对Bean配置资源的载入是从refresh（）方法开始的。refresh（）方法是一个模板方法，规定了 IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean 配置资源进行载入，ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh（）方法启动整个IoC容器对Bean定义的载入过程。\n7.4 自定义SpringIOC 现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.itheima.service.impl.UserServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDao\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userDao\u0026#34; class=\u0026#34;com.itheima.dao.impl.UserDaoImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 7.4.1 定义bean相关的pojo类 7.4.1.1 PropertyValue类 用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。\npublic class PropertyValue { private String name; private String ref; private String value; public PropertyValue() { } public PropertyValue(String name, String ref,String value) { this.name = name; this.ref = ref; this.value = value; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getRef() { return ref; } public void setRef(String ref) { this.ref = ref; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } 7.4.1.2 MutablePropertyValues类 一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来存储并管理多个PropertyValue对象。\npublic class MutablePropertyValues implements Iterable\u0026lt;PropertyValue\u0026gt; { private final List\u0026lt;PropertyValue\u0026gt; propertyValueList; public MutablePropertyValues() { this.propertyValueList = new ArrayList\u0026lt;PropertyValue\u0026gt;(); } public MutablePropertyValues(List\u0026lt;PropertyValue\u0026gt; propertyValueList) { this.propertyValueList = (propertyValueList != null ? propertyValueList : new ArrayList\u0026lt;PropertyValue\u0026gt;()); } public PropertyValue[] getPropertyValues() { return this.propertyValueList.toArray(new PropertyValue[0]); } public PropertyValue getPropertyValue(String propertyName) { for (PropertyValue pv : this.propertyValueList) { if (pv.getName().equals(propertyName)) { return pv; } } return null; } @Override public Iterator\u0026lt;PropertyValue\u0026gt; iterator() { return propertyValueList.iterator(); } public boolean isEmpty() { return this.propertyValueList.isEmpty(); } public MutablePropertyValues addPropertyValue(PropertyValue pv) { for (int i = 0; i \u0026lt; this.propertyValueList.size(); i++) { PropertyValue currentPv = this.propertyValueList.get(i); if (currentPv.getName().equals(pv.getName())) { this.propertyValueList.set(i, new PropertyValue(pv.getName(),pv.getRef(), pv.getValue())); return this; } } this.propertyValueList.add(pv); return this; } public boolean contains(String propertyName) { return getPropertyValue(propertyName) != null; } } 7.4.1.3 BeanDefinition类 BeanDefinition类用来封装bean信息的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。\npublic class BeanDefinition { private String id; private String className; private MutablePropertyValues propertyValues; public BeanDefinition() { propertyValues = new MutablePropertyValues(); } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getClassName() { return className; } public void setClassName(String className) { this.className = className; } public void setPropertyValues(MutablePropertyValues propertyValues) { this.propertyValues = propertyValues; } public MutablePropertyValues getPropertyValues() { return propertyValues; } } 7.4.2 定义注册表相关类 7.4.2.1 BeanDefinitionRegistry接口 BeanDefinitionRegistry接口定义了注册表的相关操作，定义如下功能：\n注册BeanDefinition对象到注册表中 从注册表中删除指定名称的BeanDefinition对象 根据名称从注册表中获取BeanDefinition对象 判断注册表中是否包含指定名称的BeanDefinition对象 获取注册表中BeanDefinition对象的个数 获取注册表中所有的BeanDefinition的名称 public interface BeanDefinitionRegistry { //注册BeanDefinition对象到注册表中 void registerBeanDefinition(String beanName, BeanDefinition beanDefinition); //从注册表中删除指定名称的BeanDefinition对象 void removeBeanDefinition(String beanName) throws Exception; //根据名称从注册表中获取BeanDefinition对象 BeanDefinition getBeanDefinition(String beanName) throws Exception; boolean containsBeanDefinition(String beanName); int getBeanDefinitionCount(); String[] getBeanDefinitionNames(); } 7.4.2.2 SimpleBeanDefinitionRegistry类 该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。\npublic class SimpleBeanDefinitionRegistry implements BeanDefinitionRegistry { private Map\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap = new HashMap\u0026lt;String, BeanDefinition\u0026gt;(); @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) { beanDefinitionMap.put(beanName,beanDefinition); } @Override public void removeBeanDefinition(String beanName) throws Exception { beanDefinitionMap.remove(beanName); } @Override public BeanDefinition getBeanDefinition(String beanName) throws Exception { return beanDefinitionMap.get(beanName); } @Override public boolean containsBeanDefinition(String beanName) { return beanDefinitionMap.containsKey(beanName); } @Override public int getBeanDefinitionCount() { return beanDefinitionMap.size(); } @Override public String[] getBeanDefinitionNames() { return beanDefinitionMap.keySet().toArray(new String[1]); } } 7.4.3 定义解析器相关类 7.4.3.1 BeanDefinitionReader接口 BeanDefinitionReader是用来解析配置文件并在注册表中注册bean的信息。定义了两个规范：\n获取注册表的功能，让外界可以通过该对象获取注册表对象。 加载配置文件，并注册bean数据。 public interface BeanDefinitionReader { //获取注册表对象 BeanDefinitionRegistry getRegistry(); //加载配置文件并在注册表中进行注册 void loadBeanDefinitions(String configLocation) throws Exception; } 7.4.3.2 XmlBeanDefinitionReader类 XmlBeanDefinitionReader类是专门用来解析xml配置文件的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。\npublic class XmlBeanDefinitionReader implements BeanDefinitionReader { private BeanDefinitionRegistry registry; public XmlBeanDefinitionReader() { this.registry = new SimpleBeanDefinitionRegistry(); } @Override public BeanDefinitionRegistry getRegistry() { return registry; } @Override public void loadBeanDefinitions(String configLocation) throws Exception { InputStream is = this.getClass().getClassLoader().getResourceAsStream(configLocation); SAXReader reader = new SAXReader(); Document document = reader.read(is); Element rootElement = document.getRootElement(); //解析bean标签 parseBean(rootElement); } private void parseBean(Element rootElement) { List\u0026lt;Element\u0026gt; elements = rootElement.elements(); for (Element element : elements) { String id = element.attributeValue(\u0026#34;id\u0026#34;); String className = element.attributeValue(\u0026#34;class\u0026#34;); BeanDefinition beanDefinition = new BeanDefinition(); beanDefinition.setId(id); beanDefinition.setClassName(className); List\u0026lt;Element\u0026gt; list = element.elements(\u0026#34;property\u0026#34;); MutablePropertyValues mutablePropertyValues = new MutablePropertyValues(); for (Element element1 : list) { String name = element1.attributeValue(\u0026#34;name\u0026#34;); String ref = element1.attributeValue(\u0026#34;ref\u0026#34;); String value = element1.attributeValue(\u0026#34;value\u0026#34;); PropertyValue propertyValue = new PropertyValue(name,ref,value); mutablePropertyValues.addPropertyValue(propertyValue); } beanDefinition.setPropertyValues(mutablePropertyValues); registry.registerBeanDefinition(id,beanDefinition); } } } 7.4.4 IOC容器相关类 7.4.4.1 BeanFactory接口 在该接口中定义IOC容器的统一规范即获取bean对象。\npublic interface BeanFactory { //根据bean对象的名称获取bean对象 Object getBean(String name) throws Exception; //根据bean对象的名称获取bean对象，并进行类型转换 \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;? extends T\u0026gt; clazz) throws Exception; } 7.4.4.2 ApplicationContext接口 该接口的所以的子实现类对bean对象的创建都是非延时的，所以在该接口中定义 refresh() 方法，该方法主要完成以下两个功能：\n加载配置文件。 根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。 public interface ApplicationContext extends BeanFactory { //进行配置文件加载并进行对象创建 void refresh() throws IllegalStateException, Exception; } 7.4.4.3 AbstractApplicationContext类 作为ApplicationContext接口的子类，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。\n声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。\nBeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。\npublic abstract class AbstractApplicationContext implements ApplicationContext { protected BeanDefinitionReader beanDefinitionReader; //用来存储bean对象的容器 key存储的是bean的id值，value存储的是bean对象 protected Map\u0026lt;String, Object\u0026gt; singletonObjects = new HashMap\u0026lt;String, Object\u0026gt;(); //存储配置文件的路径 protected String configLocation; public void refresh() throws IllegalStateException, Exception { //加载BeanDefinition beanDefinitionReader.loadBeanDefinitions(configLocation); //初始化bean finishBeanInitialization(); } //bean的初始化 private void finishBeanInitialization() throws Exception { BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry(); String[] beanNames = registry.getBeanDefinitionNames(); for (String beanName : beanNames) { BeanDefinition beanDefinition = registry.getBeanDefinition(beanName); getBean(beanName); } } } 注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。\n7.4.4.4 ClassPathXmlApplicationContext类 该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能：\n在构造方法中，创建BeanDefinitionReader对象。 在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。 重写父接口中的getBean()方法，并实现依赖注入操作。 public class ClassPathXmlApplicationContext extends AbstractApplicationContext{ public ClassPathXmlApplicationContext(String configLocation) { this.configLocation = configLocation; //构建XmlBeanDefinitionReader对象 beanDefinitionReader = new XmlBeanDefinitionReader(); try { this.refresh(); } catch (Exception e) { } } //根据bean的id属性值获取bean对象 @Override public Object getBean(String name) throws Exception { //return singletonObjects.get(name); Object obj = singletonObjects.get(name); if(obj != null) { return obj; } BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry(); BeanDefinition beanDefinition = registry.getBeanDefinition(name); if(beanDefinition == null) { return null; } String className = beanDefinition.getClassName(); Class\u0026lt;?\u0026gt; clazz = Class.forName(className); Object beanObj = clazz.newInstance(); MutablePropertyValues propertyValues = beanDefinition.getPropertyValues(); for (PropertyValue propertyValue : propertyValues) { String propertyName = propertyValue.getName(); String value = propertyValue.getValue(); String ref = propertyValue.getRef(); if(ref != null \u0026amp;\u0026amp; !\u0026#34;\u0026#34;.equals(ref)) { Object bean = getBean(ref); String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName); Method[] methods = clazz.getMethods(); for (Method method : methods) { if(method.getName().equals(methodName)) { method.invoke(beanObj,bean); } } } if(value != null \u0026amp;\u0026amp; !\u0026#34;\u0026#34;.equals(value)) { String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName); Method method = clazz.getMethod(methodName, String.class); method.invoke(beanObj,value); } } singletonObjects.put(name,beanObj); return beanObj; } @Override public \u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;? extends T\u0026gt; clazz) throws Exception { Object bean = getBean(name); if(bean != null) { return clazz.cast(bean); } return null; } } 7.4.5 自定义Spring IOC总结 7.4.5.1 使用到的设计模式 工厂模式。这个使用工厂模式 + 配置文件的方式。 单例模式。Spring IOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。 模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。 迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。 spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。\n7.4.5.2 符合大部分设计原则 7.4.5.3 整个设计和Spring的设计还是有一定的出入 spring框架底层是很复杂的，进行了很深入的封装，并对外提供了很好的扩展性。而我们自定义SpringIOC有以下几个目的：\n了解Spring底层对对象的大体管理机制。 了解设计模式在具体的开发中的使用。 以后学习spring源码，通过该案例的实现，可以降低spring学习的入门成本。 ","permalink":"http://answerkobe.github.io/posts/design-pattern/","summary":"黑马设计模式精讲 1，设计模式概述 1.1 软件设计模式的产生背景 \u0026ldquo;设计模式\u0026quot;最初并不是出现在软件设计中，而是被用于建筑领域的设计中。\n1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。\n1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。\n1.2 软件设计模式的概念 软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。\n1.3 学习设计模式的必要性 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。\n正确使用设计模式具有以下优点。\n可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 1.4 设计模式分类 创建型模式\n用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。\n结构型模式\n用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。\n行为型模式\n用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。\n2，UML图 统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。\nUML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。\n2.1 类图概述 类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。\n2.2 类图的作用 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解； 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。 2.3 类图表示法 2.3.1 类的表示方式 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。","title":"Java设计模式"},{"content":"Why compose Compose UI 的编写只需要 Kotlin，在遵循 Android 应用架构时，这样更有利于聚合 UI Elements 的代码，不需要去区分 Kotlin 代码和 xml 布局文件，在我看来这种方式更加容易采用 Android 架构指南去控制项目架构。\n但从另一方面来讲，Compose 这种嵌套的 UI 组合方式会加深代码层次，因此开发过程中需要对 UI 上各个元素做更细的区分，以增加代码的可读性。另外如果状态使用没有处理好，也会对 Compose 的重组性能带来影响。\n完善的声明式 UI Android View 系统设计的时候是遵循 OOP 的，虽然有 XML 可以帮我们减少下面这种命令式代码的使用，但这种声明式构建 + 命令式执行的缺点还是很明显，因为需要一个加载器把布局转化到业务逻辑代码中。\n// 命令式 val parent = ViewGroup(); val node = View(); parent.addView(node); 如果按照理想的声明式 UI 编写方式去改造传统 View 系统，那呈现出的代码可能会包括下面两个特点：\n节点的构建不应该有返回值 节点的连接不依赖于 API \u0026lt;LinearLayout\u0026gt; \u0026lt;TextView\u0026gt;Hello World\u0026lt;/TextView\u0026gt; \u0026lt;MaterialButton android:onCLick=\u0026#34;syaHi()\u0026#34;\u0026gt;hi\u0026lt;/MaterialButton\u0026gt; \u0026lt;/LinearLayout\u0026gt; 将上面的布局代码转换为 Java/Kotlin 理想的声明式代码\nLinearLayout { TextView(\u0026#34;Hello World\u0026#34;) MaterialButton(\u0026#34;Hi\u0026#34;) { syaHi() } } Compose 利用 Kotlin DSL 构建声明式 UI，一个 @Composable 相当于一个节点，在内部也可以调用其他 @Composable 函数构建子节点。\n@Composable fun Foo() { var text by remember { mutableStateOf(1) } Button(onClick = { text += 1 }) { Text(\u0026#34;$text\u0026#34;) } } @Composable fun Button() Compose Compiler 与 Kotlin 的版本是绑定的，对应的版本对照表可以参考官方文档： https://developer.android.com/jetpack/androidx/releases/compose-kotlin?hl=zh-cn\n节点与作用域 Compose 中节点分两种：\nGroup 代表一个组合范围，属于重组的最小单位，用于构建树的结构，识别结构的变化 LayoutNode 是最终组成渲染树的节点，可以完成测量布局绘制等渲染过程 Group 的创建是在执行 @Composable 函数的过程中进行。@Composable 函数编译时，会在签名中会插入一个 $composer 参数，并调用该对象的方法，我们可以使用 jadx 对 @Composable 函数代码生成的字节码进行反编译。\n// 上面的 Foo 函数签名经过 compose.compiler 编译后会变成这样 @Composable public static final void Foo1(@Nullable Composer $composer, int $changed) { Composer $composer2 = $composer.startRestartGroup(-1679608079); ComposerKt.sourceInformation($composer2, \u0026#34;C(Foo1)21@424L6:Foo.kt#a1gac0\u0026#34;); if ($changed != 0 || !$composer2.getSkipping()) { Foo2($composer2, 0); } else { $composer2.skipToGroupEnd(); } ScopeUpdateScope endRestartGroup = $composer2.endRestartGroup(); if (endRestartGroup != null) { endRestartGroup.updateScope(new Foo1.1($changed)); } } 参数中的 Composer 类似于上下文的东西，会贯穿 @Composable 函数的调用过程。Composer 大部分方法的调用，都是由 Compose 使用 KCP 解析 @Composable 注解对字节码进行修改时的结果。这一步由是 compose.compiler 完成，我们不应该自己创建 Composer 对象以及使用它的方法，不然可能会对 composition 过程造成影响。\nSlotTable 和 Applier Composer 在 Jetpack Compose 上实现类有一个 internal 的 ComposerImpl，它包含了两个操作节点的成员：\nApplier 负责 NodeLayout 操作，LayoutNode 树的根节点其实就包含在里面 SlotTable 负责存储 composition 过程的各种数据，包括 Group 和作用域对象，以及其他一些状态 internal class ComposerImpl( override val applier: Applier\u0026lt;*\u0026gt;, private val slotTable: SlotTable, private var changes: MutableList\u0026lt;Change\u0026gt;, ... ) : Composer SlotTable 中包含两个数组。\ngroups 存储 Group，Group 不以对象形式存在，在 groups 中每 5 数值代表一个 Group，其中偏移位为0的就是 startGroup 的时候传入的 key，一般由编译器生成 slots 用于存储相关的数据，包括作用域、内容体等 // Group layout // 0 | 1 | 2 | 3 | 4 | // Key | Group info | Parent anchor | Size | Data anchor | internal class SlotTable : CompositionData, Iterable\u0026lt;CompositionGroup\u0026gt; { var groups = IntArray(0) private set var slots = Array\u0026lt;Any?\u0026gt;(0) { null } private set } Composer 调用 startRestartGroup 会传入编译生成的 Key，通过识别当前 Group 的 key 是否匹配，来判断是否需要对树结构进行更改。 如果是创建一个新的 Group 或者当前位置结构发生变化时，会创建一个作用域对象 RecomposeScopeImpl 对象存到 slots 里，当结束一个 Group 的执行后会调用作用域对象的 updateScope 注册 @Composable 函数体，当作用域进行重组时会重新执行注册的 @Composable 函数。\ninternal class RecomposeScopeImpl( var composition: CompositionImpl? ) : ScopeUpdateScope, RecomposeScope { // ScopeUpdateScope override fun updateScope(block: (Composer, Int) -\u0026gt; Unit) // RecomposeScope override fun invalidate() } 延迟执行 SlotTable 的更新 SlotTable 的读写需要通过 SlotReader 和 SlotWriter 来完成，为了保证操作时不会发生冲突，两者只能打开一个，并且对 SlotTable 会把对应的更新操作不会马上执行，而是记录到 Change 列表中延迟执行。 composition 过程会把步骤拆分为2个：\n计算和记录 SlotTable 的变化 应用 SlotTable 的修改并使用 Applier 对 LayoutNode 树做对应的更新 // ComposerImpl private var changes: MutableList\u0026lt;Change\u0026gt; internal typealias Change = ( applier: Applier\u0026lt;*\u0026gt;, slots: SlotWriter, rememberManager: RememberManager ) -\u0026gt; Unit SlotTable 对 Group 的操作用了类似于 GapBuffer 的数据结构来完成。\nLayoutNode 的创建和插入 如果使用 androidx.compose.material 的组件会发生最终都是调用 Layout() 函数，Layout() 函数分两个主要的重载类型，一个有带 content 参数，一个没有，但里面会调用 ReusableComposeNode() 函数。\n@Composable inline fun Layout( modifier: Modifier = Modifier, // 样式修饰和行为定义 measurePolicy: MeasurePolicy // 定义布局的测量和布局行为 ) { ... ReusableComposeNode\u0026lt;ComposeUiNode, Applier\u0026lt;Any\u0026gt;\u0026gt;( ... ) } ReusableComposeNode 就是将 LayoutNode 作为节点加到当前位置，节点的创建和复用也是由当前的 Composer 执行的。节点的创建是在回调中使用 factory 去创建，同样该回调也是在最后应用更改的时候执行。\n@Composable inline fun \u0026lt;T : Any, reified E : Applier\u0026lt;*\u0026gt;\u0026gt; ReusableComposeNode( noinline factory: () -\u0026gt; T, // update: @DisallowComposableCalls Updater\u0026lt;T\u0026gt;.() -\u0026gt; Unit ) { if (currentComposer.applier !is E) invalidApplier() currentComposer.startReusableNode() // 如果当前作用于进行的组合正在调度插入树的节点，例如第一次组合或者节点重组 if (currentComposer.inserting) { currentComposer.createNode { factory() } } else { currentComposer.useNode() } currentComposer.disableReusing() Updater\u0026lt;T\u0026gt;(currentComposer).update() currentComposer.enableReusing() // 节点可复用 currentComposer.endNode() } val Constructor: () -\u0026gt; ComposeUiNode = LayoutNode.Constructor internal val Constructor: () -\u0026gt; LayoutNode = { LayoutNode() } NodeLayout 的节点操作都是交给 Applier 处理，AbstractApplier 中会存着 LayoutNode 树的根节点。 Applier 对节点的插入方式由两种，两种方式插入性能和节点的通知有关，具体可以看看源码的注释。\nabstract class AbstractApplier\u0026lt;T\u0026gt;(val root: T) : Applier\u0026lt;T\u0026gt; // 节点插入操作 fun insertTopDown(index: Int, instance: N) fun insertBottomUp(index: Int, instance: N) 响应式UI与快照 在 Compose 中，当 State 发生变化时，会自动进行重组，更新依赖了该 State 的 @Composable 函数的这种响应式布局本质也是基于观察订阅，但不需要开发者自己去做订阅和反订阅这些事情，而是交给 Snapshot 完成。Snapshot 相当于给当前程序的 State 拍个照做个记录，因此称为快照。 快照内部对 State 值的读取和修改，会触发 readobserver 和 writeObserver 回调，在快照内修改 State 的值不会影响到外部状态。\nval state = mutableStateOf(1) // 拍照 val snapshot = Snapshot.takeMutableSnapshot ( readObserver = { println(\u0026#34;read\u0026#34;) }, writeObserver = { println(\u0026#34;write\u0026#34;) } ) snapshot.enter { println(\u0026#34;enter state: ${state.value}\u0026#34;) state.value = 2 } println(\u0026#34;outer state: ${state.value}\u0026#34;) snapshot.apply() println(\u0026#34;apply state: ${state.value}\u0026#34;) // 打印 read enter state: 1 write outer state: 1 apply state: 2 mutableStateOf()返回的本质是一个 SnapshotMutableStateImpl 对象，它的 value 值都是交给 StateStateRecord 去维护。\noverride var value: T get() = next.readable(this).value set(value) = next.withCurrent { if (!policy.equivalent(it.value, value)) { next.overwritable(this, it) { this.value = value } } } private var next: StateStateRecord\u0026lt;T\u0026gt; = StateStateRecord(value) 当修改或读取 State 的值时，会获取当前的快照，并通知当前的 Snapshot 触发相关回调。\nCompose 读取 State 时会记录依赖了此状态的作用域 当 State 被修改时，会将依赖了该状态的作用域标记为 invalid，在重组的时候会重新执行这些作用域的组合函数 internal inline fun \u0026lt;T : StateRecord, R\u0026gt; T.overwritable( state: StateObject, candidate: T, block: T.() -\u0026gt; R ): R { var snapshot: Snapshot = snapshotInitializer return sync { // 获取当前线程快照/全局快照 snapshot = Snapshot.current this.overwritableRecord(state, snapshot, candidate).block() }.also { notifyWrite(snapshot, state) } } @PublishedApi internal fun notifyWrite(snapshot: Snapshot, state: StateObject) { snapshot.writeObserver?.invoke(state) } 全局快照 UI 的变化通常是在主线程，如果更新 State 的操作是在其它线程，那么获取到的当前快照将会是全局快照 GlobalSnapShot。 全局快照会在启动的时候就注册一个回调，通过 Kotlin 协程的 Channel 发送消息，这个消息的处理会切到主线程中进行，并 applyObservers 中的回调，其中有一个回调会执行performRecompose()执行重组。\nprivate val applyObservers = mutableListOf\u0026lt;(Set\u0026lt;Any\u0026gt;, Snapshot) -\u0026gt; Unit\u0026gt;() internal object GlobalSnapshotManager { private val started = AtomicBoolean(false) fun ensureStarted() { if (started.compareAndSet(false, true)) { val channel = Channel\u0026lt;Unit\u0026gt;(Channel.CONFLATED) CoroutineScope(AndroidUiDispatcher.Main).launch { channel.consumeEach { Snapshot.sendApplyNotifications() } } Snapshot.registerGlobalWriteObserver { channel.trySend(Unit) } } } } 重组在快照中执行 进行重组时会先拍一次快照，再让重组过程在快照中执行，此时在快照中 @Composable 函数中读取 State 的值时会触发读观察者，把 State 和当前的作用域绑定起来。\nprivate fun performRecompose(...){ return if ( composing(composition, modifiedValues) { composition.recompose() } ) composition else null } private inline fun \u0026lt;T\u0026gt; composing(...): T { val snapshot = Snapshot.takeMutableSnapshot( readObserverOf(composition), writeObserverOf(composition, modifiedValues) ) try { return snapshot.enter(block) } finally { applyAndCheck(snapshot) } } applyObservers 是一个静态变量，当主线程的 MutableSnapshot 触发写入通知的时候也会触发里面的回调进行重组。在 composition 是写入不会马上就通过写观察者进行重组，而是在 composition 过程结束后，apply 后再进行重组。\nCompose 性能优化 Compose 在更新帧的时候要经过3个阶段：\n组合：Compose 确定要显示的内容 - 运行可组合函数并构建界面树。 布局：Compose 确定界面树中每个元素的尺寸和位置。 绘图：Compose 实际渲染各个界面元素。 Compose 对这些阶段做了许多优化，例如在组合阶段使用 SoltTable 记录树结构，通过 diff 树结构的变化来更新 LayotNode 节点，还使用 RecomposeScope 作用域标记修改状态。在布局阶段使用了固有特性测量来解决布局嵌套问题。\n重组范围最小化 开头说过，Compose 中编写代码要尽量控制组件的细度，过多的嵌套调用这不会影响 Compose 测量效率（），但如果不控制好组件的细度，导致 Group 的范围过大，可能会影响重组效率。\n@Composable fun Foo() { var text by remember { mutableStateOf(1) } Log.d(TAG, \u0026#34;Foo\u0026#34;) Button( onClick = { text += 1 } ).also { Log.d(TAG, \u0026#34;Button\u0026#34;) }) { Log.d(TAG, \u0026#34;Button content lambda\u0026#34;) Text(\u0026#34;$text\u0026#34;).also { Log.d(TAG, \u0026#34;Text\u0026#34;) } } } 回到前面的例子，如果点击按钮改变状态，会发现发生重组的实际上是整个 Botton 内容体的 Lambda 表达式，如果在 Lambda 表达式中存在其它的组件，那么也会跟着重组。 如果不希望 Text 对状态的依赖影响到同级的其他 @Composable 组件，那么可以套一层非 inline 的函数。例如下面的例子，状态变化时，重组的就只有依赖了状态的 Text 了。\n@Composable fun RecomposeFoo() { var text by remember { mutableStateOf(0) } Log.d(TAG, \u0026#34;Foo\u0026#34;) Button(onClick = { text += 1 }.also { Log.d(TAG, \u0026#34;Button\u0026#34;) }) { Log.d(TAG, \u0026#34;Button content lambda\u0026#34;) ChangeableText { Text(\u0026#34;$text\u0026#34;).also { Log.d(TAG, \u0026#34;Text\u0026#34;) } // recompose }.also { Log.d(TAG, \u0026#34;ChangeableText call\u0026#34;) } } } @Composable fun ChangeableText(content: @Composable () -\u0026gt; Unit) { Log.d(TAG, \u0026#34;ChangeableText content\u0026#34;) content() Text(text = \u0026#34;Hi\u0026#34;).also { Log.d(TAG, \u0026#34;Hi\u0026#34;) } } inline 函数不能作为重组的最小范围 由于 inline 函数的特点，会共享调用方的 Group，因此 inline 函数不能作为组合的最小范围。 例如 Column、Row、Box 以及 Layout 这些容器类。 当然如果希望缩小范围提高性能，同样可以套一层非 inline 函数来缩小 Group 的范围。\n不做多余的重组 上面提到了，重组过程只会对 invalid 的作用域做重组。 例如下面的代码，当 num 发生变化时，Foo1 的内容会进行重组，Foo2 会被调用，但由于编译时 Foo2 的代码插入了 Group 的逻辑， Foo2 中的 Group 和作用域并没有发生修改，因此里面的内容并不会执行。\n@Composable fun Foo1(num: MutableState\u0026lt;Int\u0026gt;) { Log.d(TAG, \u0026#34;Foo1 content\u0026#34;) Text(text = \u0026#34;${num.value}\u0026#34;).also { Log.d(TAG, \u0026#34;Text\u0026#34;) } Foo2().also { Log.d(TAG, \u0026#34;call Foo2\u0026#34;) } } @Composable fun Foo2() { Log.d(TAG, \u0026#34;Foo2 content\u0026#34;) Text(text = \u0026#34;End\u0026#34;).also { Log.d(TAG, \u0026#34;End\u0026#34;) } } // Foo1 content // Text // call Foo2 但如果 Foo2 的有一个 Int 类型的参数，并且由 Foo1 读取后传入，那么Foo1和Foo2将会一起参与重组。\n@Composable fun Foo1(num: MutableState\u0026lt;Int\u0026gt;) { Log.d(TAG, \u0026#34;Foo1 content\u0026#34;) Foo2(num.value).also { Log.d(TAG, \u0026#34;call Foo2\u0026#34;) } } @Composable fun Foo2(num: Int) { Log.d(TAG, \u0026#34;Foo2 content\u0026#34;) Text(text = \u0026#34;$num\u0026#34;).also { Log.d(TAG, \u0026#34;Text\u0026#34;) } } // Foo1 content // Foo2 content // Text // call Foo2 因此我们需要做状态的延迟读取，以缩小读取状态的 Group 范围，避免不必要的重组参与。\n@Composable fun Foo1(num: MutableState\u0026lt;Int\u0026gt;) { Log.d(TAG, \u0026#34;Foo1 content\u0026#34;) Foo2 { num.value }.also { Log.d(TAG, \u0026#34;call Foo2\u0026#34;) } } @Composable fun Foo2(num: () -\u0026gt; Int) { Log.d(TAG, \u0026#34;Foo2 content\u0026#34;) Text(text = \u0026#34;${num()}\u0026#34;).also { Log.d(TAG, \u0026#34;Text\u0026#34;) } } // Foo2 content // Text 官方提出的最佳做法 官方在性能优化的一文中也提出了开发过程中的5个最佳做法 https://developer.android.com/jetpack/compose/performance#use-remember\n尽可能从组合函数中移除计算，或使用 remember 记住计算结果，降低计算开销 使用延迟布局 Key 使用 derivedStaeOf 限制重组 尽可能延迟读取 避免向后写入 ","permalink":"http://answerkobe.github.io/posts/jetpack-compose-explore/","summary":"Why compose Compose UI 的编写只需要 Kotlin，在遵循 Android 应用架构时，这样更有利于聚合 UI Elements 的代码，不需要去区分 Kotlin 代码和 xml 布局文件，在我看来这种方式更加容易采用 Android 架构指南去控制项目架构。\n但从另一方面来讲，Compose 这种嵌套的 UI 组合方式会加深代码层次，因此开发过程中需要对 UI 上各个元素做更细的区分，以增加代码的可读性。另外如果状态使用没有处理好，也会对 Compose 的重组性能带来影响。\n完善的声明式 UI Android View 系统设计的时候是遵循 OOP 的，虽然有 XML 可以帮我们减少下面这种命令式代码的使用，但这种声明式构建 + 命令式执行的缺点还是很明显，因为需要一个加载器把布局转化到业务逻辑代码中。\n// 命令式 val parent = ViewGroup(); val node = View(); parent.addView(node); 如果按照理想的声明式 UI 编写方式去改造传统 View 系统，那呈现出的代码可能会包括下面两个特点：\n节点的构建不应该有返回值 节点的连接不依赖于 API \u0026lt;LinearLayout\u0026gt; \u0026lt;TextView\u0026gt;Hello World\u0026lt;/TextView\u0026gt; \u0026lt;MaterialButton android:onCLick=\u0026#34;syaHi()\u0026#34;\u0026gt;hi\u0026lt;/MaterialButton\u0026gt; \u0026lt;/LinearLayout\u0026gt; 将上面的布局代码转换为 Java/Kotlin 理想的声明式代码\nLinearLayout { TextView(\u0026#34;Hello World\u0026#34;) MaterialButton(\u0026#34;Hi\u0026#34;) { syaHi() } } Compose 利用 Kotlin DSL 构建声明式 UI，一个 @Composable 相当于一个节点，在内部也可以调用其他 @Composable 函数构建子节点。","title":"Jetpack Compose 探索"},{"content":"Render Tree 的创建过程 RenderObject 的类型 我们知道 Element 主要分为负责渲染的 RenderObjectElement 和负责组合的 ComponentElement 两大类，而创建 RenderObject 节点的是前者 mount() 方法中调用的 RenderObjectWidget.createRenderObject() 方法。\n该方法是一个抽象方法，需要子类实现，对于不同的布局的 Widget 创建的 RenderObject 类型也不一样，在 Render Tree 中最主要的有两种 RenderObject：\n首先是在 RenderObject 注释说明中大量提到了一个类 RenderBox，它是大部分的 RenderObjectWidget 所对应的 RenderObject 的抽象类 /// A render object in a 2D Cartesian coordinate system. /// 一个在 2D 坐标系中的渲染对象 abstract class RenderBox extends RenderObject 以及 Render Tree 的根节点 RenderView /// The root of the render tree. /// Render Tree 的根节点，处理渲染管道的引导和渲染树的输出 /// 它有一个填充整个输出表面的 RenderBox 类型的唯一子节点 class RenderView extends RenderObject with RenderObjectWithChildMixin\u0026lt;RenderBox\u0026gt; 其他的类型的 RenderObject 基本是为了特定布局（如滑动、列表）的实现，但大部分都直接或间接集成自 RenderBox。\n通常一个 RenderBox 只有一个子节点（因为它只有一个 child 属性），这使得它整体更像是链表。 Flutter 提供了 ContainerRenderObjectMixin 用来给那些需要存储多个子节点的 RenderBox 进行扩展，多个子节点的组织方式也是采用链表来连接存储，下面列出常见的两种：\nRenderStack 实现了堆栈布局算法 RenderFlex 实现了 Flex 布局算法，Column 和 Row 都是属于 Flex 的变体 RenderView 如何创建 既然 Render Tree 的根节点是 RenderView，那么我们看 RenderView 是在哪被创建的。\n通过 IDE 的全局搜索我们可以找到对应的创建引用是在 RendererBinding 中。\n/// Flutter 引擎和 Render Tree 之间的一个绑定器 mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable 这个类建立了 Flutter Engine 和 Render Tree 之间的关联，注释中介绍，当 Binding 被创建的时候就会执行 initInstances() 进行初始化并创建 RenderView。\n/// RendererBinding @override void initInstances() { // ... 省略了 PipelineOwner 创建和 window 初始化代码 // 创建 RenderView initRenderView(); } /// Called automatically when the binding is created. void initRenderView() { // ... renderView = RenderView( configuration: createViewConfiguration(), window: window); // 初始化 RenderView renderView.prepareInitialFrame(); } 我们回到 Flutter App 启动时调用的函数 runApp。\nrunApp 会创建 WidgetsFlutterBinding，并执行 ensureInitialized() 方法。\nvoid runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() //初始化 ..scheduleAttachRootWidget(app) // 创建其他两棵树的根节点 ..scheduleWarmUpFrame(); } 而这个 WidgetsFlutterBinding 实际上由 7 个 mixin Binding 组合成，其中就包括了 RendererBinding，而调用这几个 mixin Binding 的 initInstances() 都是交给父类 BindingBase 在构造方法中执行。\n这种采用 mixin 组合 Binding 的设计可以方便后续接入新的 Binding。\nclass WidgetsFlutterBinding extends BindingBase with GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance!; } } abstract class BindingBase { /// Default abstract constructor for bindings. /// /// First calls [initInstances] to have bindings initialize their /// instance pointers and other state, then calls /// [initServiceExtensions] to have bindings initialize their /// observatory service extensions, if any. BindingBase() { initInstances(); initServiceExtensions(); developer.postEvent(\u0026#39;Flutter.FrameworkInitialization\u0026#39;, \u0026lt;String, String\u0026gt;{}); developer.Timeline.finishSync(); } } 三棵树的初始化关联 在ensureInitialized() 方法执行完成得到 Render Tree 根节点之后，就是调用 scheduleAttachRootWidget() 创建其他两棵树的根节点，然后和 Render Tree 进行关联。\n@protected void scheduleAttachRootWidget(Widget rootWidget) { Timer.run(() { attachRootWidget(rootWidget); }); } void attachRootWidget(Widget rootWidget) { final bool isBootstrapFrame = renderViewElement == null; _readyToProduceFrames = true; _renderViewElement = RenderObjectToWidgetAdapter\u0026lt;RenderBox\u0026gt;( container: renderView, debugShortDescription: \u0026#39;[root]\u0026#39;, child: rootWidget, ).attachToRenderTree( buildOwner!, renderViewElement as RenderObjectToWidgetElement\u0026lt;RenderBox\u0026gt;? ); if (isBootstrapFrame) { SchedulerBinding.instance!.ensureVisualUpdate(); } } 在这里attachRootWidget() 创建了 RenderObjectToWidgetAdapter，它的本质其实是 RenderObjectWidget，我们可以看到它声明了对应的 Render Tree 的节点类型为 RenderBox，并且指定了该 RenderBox 的父节点是 RenderView。\n最后调用 attachToRenderTree() 将 RenderObjectToWidgetAdapter 转化为 RootRenderObjectElement 并和 Render Tree 进行绑定。\nPipelineOwner 渲染管道管理 目前的 Render Tree 只是一个数据结构，并没有渲染操作。因此我们来研究一下从 Render Tree 到界面是一个什么样的过程。\n刚刚提到了 RenderBinding 建立了 Flutter Engine 和 Render Tree 之间的关联，在创建 RenderView 的过程中，我们可以注意到它还创建了一个 PipelineOwner 的对象，并且在设置 renderView 时还将 RenderView 赋值给了它的 rootNode。\n/// RendererBinding @override void initInstances() { _pipelineOwner = PipelineOwner( onNeedVisualUpdate: ensureVisualUpdate, onSemanticsOwnerCreated: _handleSemanticsOwnerCreated, onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed, ); } set renderView(RenderView value) { _pipelineOwner.rootNode = value; } PipelineOwner 其实渲染管道的管理者，它在渲染流程中有 3 个主要的方法：\nflushLayout 更新所有脏节点列表的布局信息 flushCompositionBits 对重新计算 needsCompositing 的节点进行更新 flushPaint 重绘所有脏节点 这 3 个方法通常是按顺序一起使用的，RenderBiding 会在 drawFrame() 方法中调用这 3 个方法\n/// RenderBiding @protected void drawFrame() { assert(renderView != null); pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); if (sendFramesToEngine) { renderView.compositeFrame(); // this sends the bits to the GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS. _firstFrameSent = true; } } 那么接下来我们就来研究一下这 3 个方法分别做了什么。\nflushLayout 我们知道当 RenderObject 有两个标识：\n_needsLayout 用于标识是否需要重新 Layout _needsPaint 用于标识是否需要重新绘制 这两个属性是保证 Render Tree 局部重绘的关键属性。\n当某个节点需要更新布局信息时，会调用 markNeedsLayout() 来重置 _needsLayout，但只这个过程还会将当前节点添加到 PipelineOwner 的 _nodesNeedingLayout 中（markNeedsPaint 则会添加到 _nodesNeedingPaint）。\n// 仅保留主要代码 void markNeedsLayout() { _needsLayout = true; if (owner != null) { owner!._nodesNeedingLayout.add(this); owner!.requestVisualUpdate(); } } flushLayout() 会将深度遍历这些节点，调用 RenderObject 的 _layoutWithoutResize() 方法来重新 Layout，最后将 _needsLayout 置为 false 并调用 markNeedsPaint() 让该节点需要重新绘制。\n/// PipelineOwner void flushLayout() { // 只保留主要逻辑 while (_nodesNeedingLayout.isNotEmpty) { final List\u0026lt;RenderObject\u0026gt; dirtyNodes = _nodesNeedingLayout; _nodesNeedingLayout = \u0026lt;RenderObject\u0026gt;[]; // 深度遍历 for (RenderObject node in dirtyNodes..sort( (RenderObject a, RenderObject b) =\u0026gt; a.depth - b.depth) ) { if (node._needsLayout \u0026amp;\u0026amp; node.owner == this) node._layoutWithoutResize(); } } } /// RenderObject @pragma(\u0026#39;vm:notify-debugger-on-exception\u0026#39;) void _layoutWithoutResize() { try { performLayout(); // 布局测量 markNeedsSemanticsUpdate(); } catch (e, stack) { _debugReportException(\u0026#39;performLayout\u0026#39;, e, stack); } _needsLayout = false; markNeedsPaint(); // 让节点需要重新绘制 } Layout 是通过 performLayout() 方法完成的，这个方法是 RenderObject 预留给子类实现自身 Layout 逻辑的抽象方法，例如在 RenderView 中的实现如下\n/// RenderView @override void performLayout() { // RenderView 需要占满整个屏幕 // 使用 ViewConfiguration 的 size _size = configuration.size; if (child != null) // 让子节点在父节点的布局约束下进行 Layout child!.layout(BoxConstraints.tight(_size)); } 要注意的是，自定义的 RenderBox 如果要放在能包含多个子节点的 RenderBox 中，例如 RenderFlex 和 RenderStack，那么需要重写 performLayout() 来确定布局大小，当然我们也可以利用另外一种方式，使用父节点的提供的约束来调整自己的大小：\n@override bool get sizedByParent =\u0026gt; true; @override Size computeDryLayout(BoxConstraints constraints) { return constraints.smallest; } 这个方式在我们下面的实验🧪会用到。\nflushCompositingBits 在 flushLayout() 方法后紧接着会被调用的方法是 flushCompositingBits()。这个方法会进行深度遍历更新 _nodesNeedingCompositingBitsUpdate 列表中节点的 needsCompositing，它会调用节点的 _updateCompositingBits() 方法对 RenderObject 节点的一些属性进行更新，包括：\n_needsCompositing 是否需要合成 layer _needsCompositingBitsUpdate 是否需要更新 _needsCompositing /// PipelineOwner void flushCompositingBits() { // 只保留主要逻辑 _nodesNeedingCompositingBitsUpdate.sort( (RenderObject a, RenderObject b) =\u0026gt; a.depth - b.depth); for (final RenderObject node in _nodesNeedingCompositingBitsUpdate) { if (node._needsCompositingBitsUpdate \u0026amp;\u0026amp; node.owner == this) node._updateCompositingBits(); } _nodesNeedingCompositingBitsUpdate.clear(); if (!kReleaseMode) { Timeline.finishSync(); } } flushPaint flushPaint() 是第 3 个调用的，对 _nodesNeedingPaint 中的节点进行深度遍历，然后调用节点的 PaintingContext 的静态方法 repaintCompositedChild() 重新绘制 RenderObject 的视图。\n/// PipelineOwner void flushPaint() { // 只保留主要逻辑 final List\u0026lt;RenderObject\u0026gt; dirtyNodes = _nodesNeedingPaint; _nodesNeedingPaint = \u0026lt;RenderObject\u0026gt;[]; // Sort the dirty nodes in reverse order (deepest first). for (final RenderObject node in dirtyNodes..sort( (RenderObject a, RenderObject b) =\u0026gt; b.depth - a.depth)) { if (node._needsPaint \u0026amp;\u0026amp; node.owner == this) { if (node._layerHandle.layer!.attached) { PaintingContext.repaintCompositedChild(node); } else { node._skippedPaintingOnLayer(); } } } } 该方法中通过层层调用最终会到达，传入节点的 paint() 方法。paint() 方法也是 RenderObject 提供给子类实现绘制逻辑的抽象方法。同样以 RenderView 为例子：\n/// RenderView @override void paint(PaintingContext context, Offset offset) { if (child != null) context.paintChild(child!, offset); } 由于 RenderView 是整颗树的根节点，因此没有什么绘制逻辑，但所有的 RenderObject 都一样，如果有子节点都会通过 PaintingContext 继续调用子节点的 paint() 方法并将 PaintingContext 传递下去，直到整颗树的节点都完成绘制。\n场景合成与界面刷新渲染 我们知道 Widget 最终都是通过 Canvas 进行绘制的，因此我们以一个自定义 View 的例子来做分析。\n在 《Flutter 实战·第二版》 这本书中，是使用 CustomPainter 来编写自定义 View，通过重写 void paint(Canvas canvas, Size size); 方法来获得一个 Canvas 对象，因此可以往这个方法的源码翻阅，查看这个 Canvas 对象的来源。\n// custom_paint.dart abstract class CustomPainter extends Listenable /// Provides a canvas on which to draw during the paint phase. /// 提供了在绘图阶段要进行绘制的 Canvas class RenderCustomPaint extends RenderProxyBox { void _paintWithPainter(Canvas canvas, Offset offset, CustomPainter painter) { // ... // 在这里调用 CustomPainter 的 paint，并提供一个 Canvas 对象 painter.paint(canvas, size); } @override void paint(PaintingContext context, Offset offset) { if (_painter != null) { // 这里提供 canvas _paintWithPainter(context.canvas, offset, _painter!); _setRasterCacheHints(context); } super.paint(context, offset); if (_foregroundPainter != null) _paintWithPainter(context.canvas, offset, _foregroundPainter!); _setRasterCacheHints(context); } } } 在这里我们可以看出，我们自定义 View 的绘制操作，是由 RenderCustomPaint 执行，它的本质其实是一个 RenderBox，而其中传入的 Canvas 对象是由它在 paint() 中的 PaintingContext 提供的。\nCanvas 与绘制存储 在 PaintingContext 中是采用懒加载的方式来创建 Canvas 对象，PaintingContext 一般创建于 Render Tree 的单独子树开始绘制时，创建时会附带创建另外两个对象：\nPictureLayer 图层 PictureRecorder 图像记录者 // object.dart class PaintingContext extends ClipContext { Canvas? _canvas; /// 获取 Canvas 对象， /// 当 _canvas 没有创建时调用 [_startRecording] 方法创建 @override Canvas get canvas { if (_canvas == null) _startRecording(); assert(_currentLayer != null); return _canvas!; } /// 创建 Canvas 对象 /// - 创建 PictureLayer 图层对象 /// - 创建 PictureRecorder 图像记录者 /// - 创建 Canvas 对象 /// - 将 PictureLayer 添加到 ContainerLayer 容器层 void _startRecording() { assert(!_isRecording); _currentLayer = PictureLayer(estimatedBounds); _recorder = ui.PictureRecorder(); _canvas = Canvas(_recorder!); _containerLayer.append(_currentLayer!); } } 创建 Canvas 时必须传入一个 PictureRecorder 对象，这个对象会记录 Canvas 的绘制操作，当完成记录时，可通过调用 PictureRecord.endRecording 来结束记录，并得到一个 Picture 对象，由于 Canvas 的绘制是由 Engine 层中的 Skia 引擎提供，因此 Picture 对象也是存储在 Engine 层。\n/// PictureRecorder Picture endRecording() { if (_canvas == null) throw StateError(\u0026#39;PictureRecorder did not start recording.\u0026#39;); final Picture picture = Picture._(); _endRecording(picture); _canvas!._recorder = null; _canvas = null; return picture; } void _endRecording(Picture outPicture) native \u0026#39;PictureRecorder_endRecording\u0026#39;; Layer Tree _startRecording() 除了创建 Canvas 和 PictureRecorder 外，还创建了一个 PictureLayer 对象并将它加入到了 _containerLayer 中。这个 _containerLayer 其实是 RenderObject 中的一个 Layer。\nLayer 是用于缓存绘图操作结果（Picture）的图层，图层可以按照规则进行排列得到图像。每个 RenderObject 中会都有一个 Layer，存储在 LayerHandle 中，Render Tree 执行 flushPaint 完成绘制后，会形成一颗 Layer Tree，Layer Tree 的节点数量会比 Render Tree 少，几个 RenderObject 节点只对应一个 Layer 节点。\nLayer 节点也有多种，但用的最多的是以下两种：\n使用 PictureRecorder 记录绘图操作的节点使用 PictureLayer，PictureLayer 不具有子节点，这是最常用的叶子节点类型 当需要和 Layer 子节点进行叠加来得到图像时，可使用 ContainerLayer，它提供了 append 方法来连接 Layer，以形成一颗 Layer Tree。 ContainerLayer 可以有多个子节点，它们以链表的方式连接在一起，一般不会直接使用 ContainerLayer，而是使用它的子类 OffsetLayer。\n使用 prepareInitialFrame() 方法初始化 RenderView 创建的 Layer 类型是 TransformLayer ，它也是 OffsetLayer 的子类。\n当创建 PaintingContext 时提供的 Layer 节点不属于 OffsetLayer 时 ，会创建一个 OffsetLayer 来代替原本的 Layer，作为当前子树的根节点。 PaintingContext 创建新的 PictureLayer 时将会使用 append 方法将新的 Layer 节点添加到这个 OffsetLayer 中。\n/// PaintingContext static void _repaintCompositedChild( RenderObject child, { bool debugAlsoPaintedParent = false, PaintingContext? childContext, }) { OffsetLayer? childLayer = child._layerHandle.layer as OffsetLayer?; if (childLayer == null) { final OffsetLayer layer = OffsetLayer(); child._layerHandle.layer = childLayer = layer; } else { childLayer.removeAllChildren(); } // 在这里创建 PaintingContext childContext ??= PaintingContext(childLayer, child.paintBounds); child._paintWithContext(childContext, Offset.zero); // 完成绘制结束记录 childContext.stopRecordingIfNeeded(); } 上面提到如果节点有孩子，会通过 context.paintChild() 让子节点也调用 _paintWithContext() 方法将 PaintingContext 向下传递，继续执行子节点的 paint() 方法进行绘制。\n当目前的图层绘制完成时，绘制完成时会调用 stopRecordingIfNeeded() 来结束记录绘制，并将 PictureRecord 生成的 Picture 对象缓存到 PictureLayer 中。\n/// PaintingContext @protected @mustCallSuper void stopRecordingIfNeeded() { if (!_isRecording) return; _currentLayer!.picture = _recorder!.endRecording(); _currentLayer = null; _recorder = null; _canvas = null; } /// PictureLayer set picture(ui.Picture? picture) { markNeedsAddToScene(); _picture?.dispose(); _picture = picture; } 节点的绘制分离 Render Tree 的绘制是采用深度遍历自顶向下绘制的，即当前节点绘制完调用子节点的绘制方法。\nRenderObject 提供了 isRepaintBoundary 属性来判断当前子树是否需要与父节点分开绘制，该属性默认为 false，并且没有 setter 来进行修改，因此默认情况下一颗 Render Tree 可能只会生成 2 个 Layer 节点（根节点的 TransformLayer 和存储绘制结果的 PictureLayout）。\n但其实我们可以在 RenderBox 的子类重写该属性，或者使用 RenderRepaintBoundary（它的 isRepaintBoundary 被重写为 true），来分离父子节点的绘制，从达到分开绘制生成不同 Layer 节点形成一颗 Layer Tree。\n该属性在 markNeedsPaint()方法中也有使用，相关源码如下：\nvoid markNeedsPaint() { if (_needsPaint) return; _needsPaint = true; markNeedsPaintCout++; if (isRepaintBoundary) { if (owner != null) { owner!._nodesNeedingPaint.add(this); owner!.requestVisualUpdate(); } } else if (parent is RenderObject) { final RenderObject parent = this.parent! as RenderObject; parent.markNeedsPaint(); } } 如果 isRepaintBoundary 为 true 则表示和父节点分开绘制，将自己添加到 _nodesNeedingPaint 列表中，在下一次更新时就只会重绘当前子树，不会污染到父节点。 如果 isRepaintBoundary 为 false 则调用父节点的 markNeedsPaint()来让父节点处理，下一次更新由父节点重绘时执行自己的绘制方法进行重绘。 而在绘制流程中，如果子节点的 isRepaintBoundary 为 true，代表需要分开绘制，会结束当前 PictureRecorder 的记录并将生成的 Picture 存到 Layer 中，然后开始子节点的绘制。\n子节点绘制时由于 PaintingContext 的 Layer 已经被设置为 null 了，所以会创建新的 PictureLayer 并添加到根 Layer 的子节点列表，如果子节点不需要重新绘制，就直接将子节点的 Layer 添加到根 Layer 的子节点列表。\n这里添加时使用的 appendLayer() 会先将当前的 Layer 节点从原本的父节点中移除，再进行添加，因此不用当心会出现重复添加的情况，由于子节点列表的本质是链表，而且创建后添加与再添加之间通常不会有其它 Layer 节点介入，因此也不需要当心该方法添加时的移动和查找效率。\n/// PaintingContext void paintChild(RenderObject child, Offset offset) { if (child.isRepaintBoundary) { stopRecordingIfNeeded(); // 结束当前树的绘制 _compositeChild(child, offset); } else { child._paintWithContext(this, offset); } } /// 省略了很多代码 void _compositeChild(RenderObject child, Offset offset) { // Create a layer for our child, and paint the child into it. if (child._needsPaint) { repaintCompositedChild(child, debugAlsoPaintedParent: true); } final OffsetLayer childOffsetLayer = child._layerHandle.layer! as OffsetLayer; childOffsetLayer.offset = offset; appendLayer(childOffsetLayer); } @protected void appendLayer(Layer layer) { layer.remove(); // 从父节点中移除当前节点 _containerLayer.append(layer); } 场景渲染 我们回到 RenderBinding 的 drawFrame() 方法中，看一下 Render Tree 完成绘制后，是如何渲染到界面的。\n/// RenderBiding @protected void drawFrame() { pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); if (sendFramesToEngine) { renderView.compositeFrame(); // this sends the bits to the GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS. _firstFrameSent = true; } } /// RenderView void compositeFrame() { final ui.SceneBuilder builder = ui.SceneBuilder(); // 将图层添加到 scene final ui.Scene scene = layer!.buildScene(builder); // 发送 scene 给 GPU 进行渲染 _window.render(scene); scene.dispose(); } /// Layer ui.Scene buildScene(ui.SceneBuilder builder) { updateSubtreeNeedsAddToScene(); addToScene(builder); // 抽象方法，由子类实现 _needsAddToScene = false; final ui.Scene scene = builder.build(); return scene; } 当需要发送帧图像给 GPU 时，会调用 compositeFrame() 方法，在这个方法中会构建一个 SceneBuilder，然后通过 ContainerLayer.buildScene() 将 Layer Tree 的 Picture 合成一个 Scene。\nScene 可理解为场景，是存储 GPU 绘制的像素信息的图像对象，当添加的是 OffsetLayer 会设置图层的偏移量，当添加的是 ContanierLayer 时会遍历子节点进行添加，当添加的是 PictureLayer 会调用 native 方法在 Engine 添加 Picture 到图像中，当我们调用 build 方法时也是从 Engine 得到 Scene 对象。\nvoid _addPicture(double dx, double dy, Picture picture, int hints) native \u0026#39;SceneBuilder_addPicture\u0026#39;; void _build(Scene outScene) native \u0026#39;SceneBuilder_build\u0026#39;; Layer 中有两个属性 _needsAddToScene 和 _subtreeNeedsAddToScene 来表示自己和子树是否需要被添加到 Scene 中，当 Layer 被脏了则需要合成到 Scene，一个 Layer 或者其子树被合成到 Scene 后，对应的属性会被设置为 false。\nScene 合成完成后，接着调用 render 方法将 Scene 发送给 GUP 渲染到界面上。\n/// FlutterView void render(Scene scene) =\u0026gt; _render(scene, this); void _render(Scene scene, FlutterView view) native \u0026#39;PlatformConfiguration_render\u0026#39;; 界面刷新 现在我们知道 Flutter 是调用 drawFrame() 方法，来做 Render Tree 的绘制，那么 drawFrame() 什么时候执行呢？我们阅读一下这个方法的注释。\n/// This method is called by [handleDrawFrame], which itself is called /// automatically by the engine when it is time to lay out and paint a frame. 注释中说明 drawFrame() 会在 Engine 需要提供一帧新图像时，自动被 handleDrawFrame() 方法调用，实际上在 RenderBinding 初始化的时候，会把这个方法添加到 persistentCallbacks 回调列表中。\n/// RenderBinding void initInstances() { // window 的初始化时会设置一些状态改变的回调 window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; // RenderView 初始化创建 initRenderView(); // 在这里添加了一个回调 addPersistentFrameCallback(_handlePersistentFrameCallback); } void _handlePersistentFrameCallback(Duration timeStamp) { drawFrame(); // 在这个回调里调用帧绘制 _scheduleMouseTrackerUpdate(); } /// SchedulerBinding /// 该列表中的回调方法会被 handleDrawFrame 依次拿出来执行 final List\u0026lt;FrameCallback\u0026gt; _persistentCallbacks = \u0026lt;FrameCallback\u0026gt;[]; /// 将回调添加到 _persistentCallbacks 中 void addPersistentFrameCallback(FrameCallback callback) { _persistentCallbacks.add(callback); } handleDrawFrame() 被执行时，会从回调列表里面取出这个回调，从而屏幕刷新的时候都会调用 drawFrame() 将 Render Tree 绘制到界面上。\n/// Engine 调用这个方法来提供新的一帧图像 void handleDrawFrame() { // PERSISTENT FRAME CALLBACKS _schedulerPhase = SchedulerPhase.persistentCallbacks; for (final FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp!); // ... 只保留关键代码 } 也就是说，我们界面刷新时，相关的回调工作会交给 handleDrawFrame() 去执行，而这个方法除了在 APP 启动的时候，会先在 scheduleWarmUpFrame() 的定时器中执行一次进行首次展示外，在 scheduleAttachRootWidget() 方法执行的时候，就会被注册到 window.onDrawFrame了作为界面刷新的回调了。 我们采用断点调试的方式，可以看到 APP 启动的时候这个方法的注册调用链如下：\nvoid runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() ..scheduleAttachRootWidget(app) // 提前注册回调 ..scheduleWarmUpFrame(); } void attachRootWidget(Widget rootWidget) { // 如果是引导帧，则进行视觉更新 if (isBootstrapFrame) { SchedulerBinding.instance!.ensureVisualUpdate(); } } void ensureVisualUpdate() { switch (schedulerPhase) { case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: scheduleFrame(); // \u0026lt;- 帧任务 return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; } } /// 以下都是 SchedulerBinding 中的方法 void scheduleFrame() { ensureFrameCallbacksRegistered(); // \u0026lt;- 确定回调的注册 window.scheduleFrame(); // 请求回调的执行，进行界面更新 _hasScheduledFrame = true; } @protected void ensureFrameCallbacksRegistered() { window.onBeginFrame ??= _handleBeginFrame; window.onDrawFrame ??= _handleDrawFrame; // \u0026lt;- 注册回调 } 注册的这个回调其实就是对 handleDrawFrame 包了一层壳。\nvoid _handleDrawFrame() { if (_rescheduleAfterWarmUpFrame) { _rescheduleAfterWarmUpFrame = false; addPostFrameCallback((Duration timeStamp) { _hasScheduledFrame = false; scheduleFrame(); }); return; } handleDrawFrame(); } window.scheduleFrame() 会向 Engine 层发起一个请求，在下一次合适的时机调用window.onDrawFrame和 window.onBeginFrame注册的回调，从而刷新界面。\n最后我们采用断点调试的方式，看界面刷新时 drawFrame 的完整调用链是什么样，绿框中的就是我们刚刚所讲到的那些方法了。\n到这里，知识就串起来了～\n整理图 我们画张图整理一下，为了让图更加简单易看，我们省略掉亿点点细节🤏。\nFramework 项目代码实验 当然了解完相关流程，我们直接在 Flutter Framework 的项目中进行实验，按照流程自己写一遍从 Render Tree 到界面刷新的代码，证明、也是熟悉这个流程。\n首先根据官方说明配置一个 Framework 开发环境，然后进入到 hello_world 项目中： https://github.com/flutter/flutter/wiki/Setting-up-the-Framework-development-environment\n实验项目和平时开发一样依旧采用 Flutter APP 的方式启动，但不同的是我们不调用 runApp() 方法，而是直接创建一颗 Render Tree 和使用 Canvas，采用上面讲的流程来执行我们的 APP。\n我们先尝试使用 Canvas 绘制一条直线，然后生成 Picture 添加到 Sence 中，然后发送给 GPU 进行渲染。\nimport \u0026#39;dart:ui\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; void main() { final PictureRecorder pictureRecorder = PictureRecorder(); drawLine(pictureRecorder); final Picture picture = pictureRecorder.endRecording(); final SceneBuilder sceneBuilder = SceneBuilder(); sceneBuilder.addPicture(Offset.zero, picture); final Scene scene = sceneBuilder.build(); window.render(scene); } void drawLine(PictureRecorder recorder) { final Canvas canvas = Canvas(recorder); final Paint paint = Paint() ..color = Colors.white ..strokeWidth = 10; canvas.drawLine(Offset(300, 300), Offset(800, 300), paint); } 上面的代码会在界面绘制一条白线，由于这里只 render 了一次，因此在绘制完这条白线后，界面就不会有任何变化了。 现在我们尝试让线条动起来，通过上面的讲解，我们知道 Flutter 是使用 window.scheduleFrame()来请求屏幕的刷新，因此我们将渲染放到 window.onDrawFrame中，并不断改变线条位置。\nimport \u0026#39;dart:ui\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; void main() { double dy = 300.0; window.onDrawFrame = () { final PictureRecorder pictureRecorder = PictureRecorder(); drawLine(pictureRecorder, dy); if (dy \u0026lt; 800) dy++; final Picture picture = pictureRecorder.endRecording(); final SceneBuilder sceneBuilder = SceneBuilder(); sceneBuilder.addPicture(Offset.zero, picture); final Scene scene = sceneBuilder.build(); // 不断刷新界面 window.render(scene); window.scheduleFrame(); }; window.scheduleFrame(); } void drawLine(PictureRecorder recorder, double dy) { final Canvas canvas = Canvas(recorder); final Paint paint = Paint() ..color = Colors.white ..strokeWidth = 10; canvas.drawLine(Offset(300, dy), Offset(800, dy), paint); } 这样就得到了一条会移动的直线。\n接下来我们将上面的直线封装为一个自定义的 RenderObject，然后自己创建一颗 Render Tree，并使用 drawFrame() 方法中的流程：使用 PipelineOwner 来重新绘制被污染的节点。\nvoid main() { // 构建根节点 final PipelineOwner pipelineOwner = PipelineOwner(); final RenderView renderView = RenderView(configuration: const ViewConfiguration(), window: window); pipelineOwner.rootNode = renderView; // 初始化 renderView.prepareInitialFrame(); renderView.child = MyRenderNode(); window.onDrawFrame = () { callFlush(pipelineOwner); renderView.compositeFrame(); window.scheduleFrame(); }; window.scheduleFrame(); } void callFlush(PipelineOwner pipelineOwner) { pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); } class MyRenderNode extends RenderBox { double _dy = 300; final Paint _paint = Paint() ..color = Colors.white ..strokeWidth = 10; void _drawLines(Canvas canvas, double dy) { canvas.drawLine(Offset(300, dy), Offset(800, dy), _paint); } @override void paint(PaintingContext context, Offset offset) { _drawLines(context.canvas, _dy); _dy++; markNeedsLayout(); } } 这份代码运行的效果和上面的是一样的，但只有一个节点并不能看出转化为 Layer Tree 的优势，我们来构建一颗多个节点的 Render Tree。我们采用 RenderFlex 来存储多个节点，并和上面讲解 flushLayout()时所说的一样交由父节点来决定布局大小。\nvoid main() { // 构建根节点 final PipelineOwner pipelineOwner = PipelineOwner(); final RenderView renderView = RenderView(configuration: const ViewConfiguration(), window: window); pipelineOwner.rootNode = renderView; // 初始化 renderView.prepareInitialFrame(); final RenderFlex flex = RenderFlex(textDirection: TextDirection.ltr); // 从 301 开始移动到 500 一共绘制了 200 次 double dy = 301; // 创建两个叶子节点 final MyRenderNode node1 = MyRenderNode(dy, Colors.white); final MyRenderNode node2 = MyRenderNode(dy, Colors.blue); renderView.child = flex; // 注意这里是往前插入 flex.insert(node1); flex.insert(node2); window.onDrawFrame = () { callFlush(pipelineOwner); renderView.compositeFrame(); if (dy \u0026lt; 500) { node1.dy = ++dy; window.scheduleFrame(); } else { print(\u0026#39;node1 paint count: ${node1.paintCount}\u0026#39;); print(\u0026#39;node2 paint count: ${node2.paintCount}\u0026#39;); } }; window.scheduleFrame(); } void callFlush(PipelineOwner pipelineOwner) { pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); } class MyRenderNode extends RenderBox { MyRenderNode(this._dy, Color color) { _paint = Paint() ..color = color ..strokeWidth = 10; } double _dy; int paintCount = 0; set dy(double dy) { _dy = dy; markNeedsLayout(); } double get dy =\u0026gt; _dy; late Paint _paint; void _drawLines(Canvas canvas, double dy) { canvas.drawLine(Offset(300, dy), Offset(800, dy), _paint); } @override void paint(PaintingContext context, Offset offset) { _drawLines(context.canvas, dy); paintCount++; } @override bool get sizedByParent =\u0026gt; true; @override Size computeDryLayout(BoxConstraints constraints) { return constraints.smallest; } } 这份代码比较长，对于 MyRenderNode的修改：\n首先我们重写了 sizedByParent和 computeDryLayout()，用于在布局测量时决定大小 _dy 属性添加了 setter 方法，在每次修改 _dy 的值时调用 markNeedsLayout() 来让下一次界面刷新时重新绘制节点 另外我们还添加了一个 piantCount 属性来记录节点绘制了几次 接着是 main 方法中：\n使用 RenderFlex 作为 RenderView 的子节点 创建了两个子节点插入到 RenderFlex 中 每次渲染时，都会修改 node1 的 dy，让他进行重绘，node2 则不做修改 当 dy 的值达到了 500 的时候停止界面刷新并打印两个节点的绘制次数 效果如上，会有一根不动的蓝线，和一根移动的白线。 我们再看看控制台打印的信息。\n我们发现两个节点的绘制次数都是 200，这意味着每次渲染两个节点都进行了重新绘制，根据上面我们讲到的 PaintingContext 和 Layer 的特点，我们可以很快判断出，这是由于 node1 和 node2 没有分开绘制，使用同一个 Layer 节点所造成的。\n由于 node1 被污染后也会调用父节点 flex 的 markNeedsPaint()，因此绘制操作时由父节点向下绘制的，而 node2 也是 flex 的子节点，整棵子树都会重新绘制，这就是 node2 污染时 node1 也跟着重绘的原因。 ​\n我们在自定义的 RenderBox 里重写 isRepaintBoundary 属性，并在 framework 层为 ContainerLayer 添加一个节点计数方法。\n/// ContainerLayer int layerCount() { int count = 1; // 算上当前节点 Layer? child = firstChild; while (child != null) { if(child is OffsetLayer) count += child.layerCount(); else count += 1; child = child.nextSibling; } return count; } void main() { window.onDrawFrame = () { if (dy \u0026lt; 500) { node1.dy = ++dy; window.scheduleFrame(); } else { print(\u0026#39;node1 paint count: ${node1.paintCount}\u0026#39;); print(\u0026#39;node2 paint count: ${node2.paintCount}\u0026#39;); // 在结束时打印 Layer 的数量 print(\u0026#39;layer count: ${renderView.layer?.layerCount()}\u0026#39;); } }; } class MyRenderNode extends RenderBox { bool _isRepaintBoundary = false; @override bool get isRepaintBoundary =\u0026gt; _isRepaintBoundary; /// 添加设置方法 set isRepaintBoundary(bool v) { _isRepaintBoundary = v; } } 我们先来演示两种情况：\n不对两个叶子节点的 isRepaintBoundary 进行修改 将 node1 单独绘制：node1.isRepaintBoundary = false; 可以看到 node1 的 isRepaintBoundary 设置为 true 时， node2 只绘制了 1 次，现在 node2 的污染就不会导致 node1 重绘制了。\n另外我们看到第二种情况的 Layer 节点数量分是 4，为什么会是 4 呢？\n回想一下介绍 PaintingContext 创建时提供 Layout 的要求：\n当提供给 PaintingContext 的 Layer 节点不属于 OffsetLayer 时 ，会创建一个 OffsetLayer 来代替原本的 Layer，作为当前子树的根节点。\n如果我们对程序进行调试，就可以发现，虽然是以 node1、node2 的顺序插入，但实际 insert() 方法是往前插入，在 flex 中 node2 是处于 node1 的前面，因此 node2 会先进行绘制。\n由于 node2 并没有设置单独绘制，因此会按照正常流程和 flex 绘制在同一个 PictureRecorder 中生成一个 PictureLayer 并添加到 TransformLayer 中。\nnode2 绘制完成之后开始绘制 node1。由于我们将 node1 设置为单独绘制，那么绘制 node1 的时候将会作为一个子树重新开始绘制，这时会重新调用 _repaintCompositedChild()方法，创建一个新的 PaintingContext 来传递，此时由于 node1 是一个叶子结点，本身并不附带 OffsetLayer 节点，因此会创建一个新的 OffsetLayer 给 PaintingConext，再进行绘制。\n绘制 node 1 时生成的 PictureLayer 添加到这个 OffsetLayout 中，完成绘制之后再将 OffsetLayout 添加到 RenderView 的 TransformLayer 中。\n因此第 2 种情况会得到 4 个 Layer 节点，对应的 Layer 图示如下：\n我们修改一下计数方法，让它打印当前遍历的层次和节点类型。\nint layerCount() { int deep = 0; print(\u0026#39;$deep ==\u0026gt; root is [${this.runtimeType}]\u0026#39;); return _layerCount(deep + 1); } int _layerCount(int deep) { int count = 1; // 算上当前节点 Layer? child = firstChild; while (child != null) { print(\u0026#39;$deep ==\u0026gt; child is [${child.runtimeType}]\u0026#39;); if(child is OffsetLayer) count += child._layerCount(deep + 1); else count += 1; child = child.nextSibling; } return count; } 可以看到和我们画的转化图是一样的。如果我们将 node1 和 node2 交换一下，先添加 node2 再添加 node1，使 node1 先进行绘制，那么结果会是什么样呢？\nflex.insert(node2); flex.insert(node1); 可以看到依旧是 4 个 Layer 节点，node2 生成的 PictureLayer 依旧是 TransformLayer 的子节点。\n我们看一下 RenderFlex 是如何绘制子节点的，我们通过调试进入 RenderFlex 的 paint() 方法，可以看到它调用的是 paintDefault()，也就是进行遍历依次调用当前 PaintingContext 的 paintChild() 绘制子节点。\nvoid defaultPaint(PaintingContext context, Offset offset) { ChildType? child = firstChild; // 遍历子节点进行绘制 while (child != null) { final ParentDataType childParentData = child.parentData! as ParentDataType; context.paintChild(child, childParentData.offset + offset); child = childParentData.nextSibling; } } RenderFlex 循环绘制时，父节点和下面的子节点用的都是同一个 PaintingContex。由于 node1 是单独绘制，因此会创建一个新的 PaintingContext 和 OffsetLayer，但绘制 node2 时还是使用父节点的 PaintingContext，所以 flex 和 node2 会一起生成一个 PictureLayer 添加到根节点中。\n结语 本文到这里就结束了，我们现在可以看到，Flutter 性能高的一个很重要的原因，就是它在资源复用和避免不必要计算等方面，做了很多思考。\n之所以研究这部分，是因为这部分是 Flutter Framework 层最贴近 Engine 层的内容，对以后研究 Flutter 和 Android 两者在 Engine 层的异同点会有很大帮助。\n由于涉及到的东西特别多，因此并没办法讲的很全面，本文所要介绍的内容也可能存在遗漏，但按照本文讲解的流程去阅读源码进行扩展，并不难弄懂，有问题可在评论区留言。\n","permalink":"http://answerkobe.github.io/posts/analysis-flutter-paint-process/","summary":"Render Tree 的创建过程 RenderObject 的类型 我们知道 Element 主要分为负责渲染的 RenderObjectElement 和负责组合的 ComponentElement 两大类，而创建 RenderObject 节点的是前者 mount() 方法中调用的 RenderObjectWidget.createRenderObject() 方法。\n该方法是一个抽象方法，需要子类实现，对于不同的布局的 Widget 创建的 RenderObject 类型也不一样，在 Render Tree 中最主要的有两种 RenderObject：\n首先是在 RenderObject 注释说明中大量提到了一个类 RenderBox，它是大部分的 RenderObjectWidget 所对应的 RenderObject 的抽象类 /// A render object in a 2D Cartesian coordinate system. /// 一个在 2D 坐标系中的渲染对象 abstract class RenderBox extends RenderObject 以及 Render Tree 的根节点 RenderView /// The root of the render tree. /// Render Tree 的根节点，处理渲染管道的引导和渲染树的输出 /// 它有一个填充整个输出表面的 RenderBox 类型的唯一子节点 class RenderView extends RenderObject with RenderObjectWithChildMixin\u0026lt;RenderBox\u0026gt; 其他的类型的 RenderObject 基本是为了特定布局（如滑动、列表）的实现，但大部分都直接或间接集成自 RenderBox。","title":"Flutter 绘制流程分析与代码实践"},{"content":"Kotlin 泛型基础 泛型可以让我们在代码中声明类型参数，Kotlin 泛型最基本的使用和 Java 一样，可以声明在类上和函数上，用法也都差不多。\n声明在函数上时，可将类型参数作为参数或返回值的类型，该函数为泛型函数 声明在类上时，可以用在任意一处类型声明处，该类为泛型类 class GenericsDemo\u0026lt;T\u0026gt;(t: T) { val value = t } fun \u0026lt;T\u0026gt; invoke(t: T) : T { return t } 我们可以在声明了类型参数的类中，声明一个泛型方法，但如果内部方法所声明的类型参数名称和类上所声明的相同，那么会覆盖类上所声明的类型参数。下面的代码不会报错，并会打印 Hello 字符串。\nclass GenericsDemo\u0026lt;T\u0026gt;() { fun \u0026lt;T\u0026gt; invoke(t: T) : T { return t } } val demo = GenericsDemo\u0026lt;Int\u0026gt;() println(demo.invoke(\u0026#34;Hello\u0026#34;)) 此外，我们知道在类中可通过重载来定义同名方法，但这在泛型中并不起作用，如果类中拥有以下两个方法，那么将会报错。\nclass GenericsDemo\u0026lt;T\u0026gt;() { // 泛型来自类 fun invoke(t: T) : T { return t } // 泛型来自方法本身 fun \u0026lt;S\u0026gt; invoke(s: S) : S { return s } } 上诉代码报错原因是因为两个方法拥有相同的 signature，也就是在 JVM 看来这两个方法的方法名和参数都是一样的，报错信息如下：\nPlatform declaration clash: The following declarations have the same JVM signature (invoke(Ljava/lang/Object;)Ljava/lang/Object;):\n造成上诉参数类型覆盖和重载签名相同的原因是在编译成 .class 文件后，类型参数会被擦除。\n泛型擦除 Java 和 Kotlin 的泛型都是伪泛型，泛型所进行的类型安全检查仅在编译器进行，在进入 JVM 时这些类型参数都会被移除，运行时不会保留和类型参数相关的信息，我们称这种机制为泛型擦除。\n由于泛型是在 JDK 1.5 才引入，为了兼容之前的版本，因此采用泛型擦除来移除运行时的类型参数\n泛型擦除时，被擦除的类型参数都会被替换成 Object，这也是为什么上述 invoke() 方法的 signature 为 invoke(Ljava/lang/Object;)Ljava/lang/Object;。\n如果该报错来自 IDEA，它可能会提示采用 @JvmName 注解来处理这个问题，这可以改变编译成字节码后该方法的名称。\n@JvmName(\u0026#34;invoke1\u0026#34;) fun \u0026lt;S\u0026gt; invoke(s: S) : S { return s } 使用 IDEA \u0026gt; Tools \u0026gt; Kotlin \u0026gt; Decompile Kotlin to Java 工具可以看到反编译后的 Java 代码如下。\npublic final class GenericsDemo { public final Object invoke(Object t) { return t; } @JvmName( name = \u0026#34;invoke1\u0026#34; ) public final Object invoke1(Object s) { return s; } } 泛型约束 在 Java 中声明类型参数时，可使用 extends 关键字来指定泛型上界，在 Kotlin 中指定上界的方式如下：\nclass Demo\u0026lt;T : Number\u0026gt;() {...} 在 Kotlin 中如果没有指定，那么会有一个默认上界 Any?，在尖括号中我们只能指定一个上界，如果类型参数需要指定多个上界，那么可以使用单独的 where 子句。\n此外，如果类型参数有多个约束，它们都需要放在\u0026rsquo;where\u0026rsquo;子句中。\nclass Demo\u0026lt;T\u0026gt; where T : CharSequence, T : Comparable\u0026lt;T\u0026gt; 协变性和逆变性 型变是指复杂类型（组合类型）根据组成类型的子类型关系，所确定子类型关系的相关性\n序关系：子类型 \u0026lt;= 基类型\n协变性（covariance）：保持了子类型的序关系 逆变性（contravariance)：逆转了子类型的序关系 不变性（invariance）：不存在子类型关系 泛型类是多个类型组合的复杂类型，在代数数据类型中（ADT）中属于积类型。在编译时期，泛型类指定不同类型参数时代表了不同类型，例如 List\u0026lt;String\u0026gt; 和 List\u0026lt;Integer\u0026gt; 不是并同一个类型。\nJava 和 Kotlin 的简单泛型是不型变的，也就是 List\u0026lt;Integer\u0026gt; 不属于 List\u0026lt;Number\u0026gt; 的子类型，下面的操作将会在编译时期就报错。\nList\u0026lt;Integer\u0026gt; integerList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Number\u0026gt; numberList = integerCollection; // error 造成这种错误的原因，是一个能存放 Number 类型对象的 List，既可以存放 Integer 对象也可以存放 Double 对象，因为这些都是 Number 的子类，如果可以将 List\u0026lt;Integer\u0026gt; 赋值给 List\u0026lt;Number\u0026gt;，意味我们可能将一个 Double 类型的对象放到 List\u0026lt;Integer\u0026gt; 里，这将会出现 ClassCastException，因此 List\u0026lt;Number\u0026gt; 无法作为 List\u0026lt;Integer\u0026gt; 的超类。\nJava 的使用处型变 如果我们要让 Java 泛型支持型变，那么需要使用通配符类型参数：\n? extends E 定义了一个上界，代表类型参数为 E 的子类 ? super E 定义了下界，代表类型参数为 E 的超类 ? extends E 和直接指定为 E 不同，List\u0026lt;? extends Number\u0026gt; 指定了 List 所存的对象类型是 Number 的某个子类型，因此 Java 也不清楚 List 具体是哪个子类型，为了安全，? extends E 类型并不能作为方法参数类型（我们无法传入一个符合 capture of ? extends Number 的类型），但可以将 Number 作为返回值类型。\n这其实解决了上面 List\u0026lt;Number\u0026gt; 无法作为 List\u0026lt;Integer\u0026gt; 超类的问题，由于 List\u0026lt;? extends Number\u0026gt; 无法使用 add 添加元素，因此不用担心将其他子类型的对象添加到 List\u0026lt;Integer\u0026gt; 容器中，那么就不用担心会产生 ClassCastException，因此 List\u0026lt;? extends Number\u0026gt; 可以作为 List\u0026lt;Integer\u0026gt; 的一个超类。\nList\u0026lt;Integer\u0026gt; integerList = new ArrayList\u0026lt;\u0026gt;(); // List\u0026lt;? extends Number\u0026gt; 属于 List\u0026lt;Integer\u0026gt; 的一个超类 List\u0026lt;? extends Number\u0026gt; list1 = integerList; list1.add(1) // error Number number = list1.get(0); 而对于 ? super Integer，Integer 可以向上转型成任意父类，所以可以作为方法的参数类型。但由于无法确定通配符 ? 代表的是哪个父类，向下转型为总是有风险，因此它无法将 Integer 作为返回值的类型，但如果我们试图去获取 capture of ? super Number 返回值类型的对象，则会得到一个 Object，因为 Object 是所有类的超类。\n这代表 List\u0026lt;? super Integer\u0026gt; 则是可以添加 Integer 对象，但只能获得 Object 对象，因此它可以作为 List\u0026lt;Number\u0026gt; 的超类。\nList\u0026lt;Number\u0026gt; numberList = new ArrayList\u0026lt;\u0026gt;(); // List\u0026lt;? super Integer\u0026gt; 属于 List\u0026lt;Number\u0026gt; 的一个 超类 List\u0026lt;? super Integer\u0026gt; list2 = numberList; list2.add(1); // Object 是所有类的超类，可作为 capture of ? super Number 类型 Object object = list2.get(0); 对于 Java 这种在使用类型参数时，通过通配符类型来支持型变的方式，称为使用处型变。\nList\u0026lt;? extends Number\u0026gt; 可以作为 List\u0026lt;Integer\u0026gt; 超类，称 List\u0026lt;? extends Number\u0026gt; 是协变的（covariant） List\u0026lt;? super Integer\u0026gt; 可以作为 List\u0026lt;Number\u0026gt; 超类，称为 List\u0026lt;? super Integer\u0026gt; 是逆变的（contravariant） 在 《Effective Java》中，Joshua Bloch 称那些只能从中读取的对象为生产者，那些只能写入的对象为消费者。\n并提出了以下助记符： PECS（Producer Extends, Consumer Super） 生产者 -Extends、消费者 -Super\nKotlin 的声明处型变 interface Source\u0026lt;T\u0026gt; { T nextT(); } 在 Kotlin 团队认为 Source\u0026lt;Object\u0026gt; 类型变量存储 Source\u0026lt;String\u0026gt; 实例引用是安全的，但在 Java 中必须要声明对象的类型为 Source\u0026lt;? extends Object\u0026gt;，这毫无意义，因此官方提供了 out 和 in 两个修饰符来向编译器解释这种情况。\nout 标注的类型参数将只能从类的成员中返回，即被作为生产，并不被消费。\n可用于类成员 out 位置 不可用在类成员 in 位置 class OutDemo\u0026lt;out T\u0026gt;(t: T) { // 作为生产者 fun get(): T = t // 方法参数为 `in` 位置，即生产者位置 // error：类型参数 T 为 `out`，不可出现在 `in` 位置 fun set(t: T) { this.t = t } } out 修饰符可以使得类型参数是协变的（convariant）\ninterface Source\u0026lt;out T\u0026gt; { fun nextT(): T } val source : Source\u0026lt;Any\u0026gt; = Source\u0026lt;String\u0026gt;() // success 而 in 修饰符可以使得类型参数是 逆变的（contravariant），in 标注的类型参数将只能被消费，而不能生产，这和 Java 的 ? super E 相对应\nclass InDemo\u0026lt;in T\u0026gt;(t: T) { // error：类型参数 T 为 `in`，不可出现在 `out` 位置 fun get(): T = t // 作为消费者 fun set(t: T) { this.t = t } } 此外，成员变量会提供 getter 和 setter 使得外部可读 / 写（拥有消费或者生产功能），因此 使用 out 或 in 修饰的类型参数的泛型成员需要声明为 private\nout 和 in称为型变注解，因为是在类型声明处提供，因此称为声明处型变。\n类型投影 如果只是为了使得泛型支持型变，那么声明处型变可以满足大部分要求，但有些类我们不能限制其类型参数为只消费或返回，例如 ArrayList 需要同时具有消费和生产。\nKotlin 除了提供声明处型变，也保留了使用处型变，即类型投影。我们可以在声明变量时使用 out 和 in，这与 Java 中的 ? extends E 与 ? super E 相对应。\nval intList = ArrayList\u0026lt;Int\u0026gt;() var outList: ArrayList\u0026lt;out Number\u0026gt; = ArrayList() var inList: ArrayList\u0026lt;in Int\u0026gt; = ArrayList() outList = intList inList = intList 投影除了可以作为使用处型变，也可以让我们保证方法内不会对参数接收的对象做坏事，以下是来自 Kotlin 官网的一个例子：\n将一个 Array 对象的数据复制到另一个 Array 对象中，在方法参数中将 Array 的参数类型标注为 out，可使得 form 中的元素不会被修改，以保证原数组对象中数据的安全。\nfun copy(from: Array\u0026lt;out Any\u0026gt;, to: Array\u0026lt;Any\u0026gt;) { …… } 星投影 星投影语法可以让我们在不确定泛型参数的时候仍然安全地使用它。\nclass Foo\u0026lt;T\u0026gt; // 星投影 val foo: Foo\u0026lt;*\u0026gt; = Foo\u0026lt;Number\u0026gt;() 星投影会对定义泛型类型进行投影，该泛型类型的每个具体实例都将会是该投影的子类型。\n对于 Foo\u0026lt;T\u0026gt;，定义的 Foo\u0026lt;*\u0026gt; 等价于 Foo\u0026lt;out Any?\u0026gt; 对于 Foo\u0026lt;out T\u0026gt;，T 是一个协变类型参数，Foo\u0026lt;*\u0026gt; 等价于 Foo\u0026lt;out Any?\u0026gt;，由于这里的 out 投影是冗余的，对应的类型参数方差相同，因此也可以等价于 Foo\u0026lt;Any?\u0026gt; 对于 Foo\u0026lt;in T\u0026gt;，T 是一个逆变类型参数，Foo\u0026lt;*\u0026gt; 等价于 Foo\u0026lt;in Nothing\u0026gt; 或 Foo\u0026lt;Nothing\u0026gt;，这将无法进行写入 Foo\u0026lt;*\u0026gt;，因为 T 未知时，没有安全的方式可以进行写入 对于 Foo\u0026lt;T : TUpper\u0026gt;，T 是一个具有上界 TUpper 的不型变类型参数，Foo\u0026lt;*\u0026gt; 在读取值时等价于 Foo\u0026lt;out TUpper\u0026gt;，而对于写值时等价于 Foo\u0026lt;in Nothing\u0026gt; 对于 Foo\u0026lt;out T : TUpper\u0026gt;，T 是一个具有上界 TUpper 的协型变类型参数，Foo\u0026lt;*\u0026gt; 等价于 Foo\u0026lt;out TUpper\u0026gt; 或 Foo\u0026lt;TUpper\u0026gt; 如果泛型类型具有多个类型参数，每个类型参数都可以单独投影。\n具体化类型参数 我们知道 JVM 运行时会进行泛型擦除，所有使用泛型的位置都会被替换成 Object，因此我们没办法将泛型当作一个具体类型使用\n但 Kotlin 中的内联函数可以将函数体的代码复制替换到相应的调用位置，Kotlin 提供了 reified 关键字，可以具体化内联函数的类型参数。\ninline fun \u0026lt;reified T\u0026gt; nameOf(): String = T::class.java.name fun main() { println(nameOf\u0026lt;Int\u0026gt;()) // java.lang.Integer } 我们查看反编译后的代码，可以看到 main() 方法中调用 nameOf() 函数的地方被替换成了 nameOf() 函数内的代码，而使用泛型的地方被替换成了符合上文的实际类型。\n// 简化了代码，留下关注的部分 public static final void main() { // 泛型 T 被替换为 Integer String var1 = Integer.class.getName(); System.out.println(var2); } public static final String nameOf() { // 泛型 T 被替换为 Object String var1 = ((Class)Object.class).getName(); return (String)var1; } 具体化类型参数可以让我们在函数中，将泛型当作一个具体的类型来使用，以支持使用类型判断、类型转换等操作来编写更优雅的代码。\nif (p is T) {...} // 具体化类型参数后这是支持的 // 不需要 @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) 来忽略类型转换警告 return p as T 参考 泛型：in、out、where - Kotlin 语言中文站 (kotlincn.net) 内联函数与具体化的类型参数 - Kotlin 语言中文站 (kotlincn.net) Generics: in, out, where | Kotlin (kotlinlang.org) Inline functions | Kotlin (kotlinlang.org) Java 不能实现真正泛型的原因是什么？ | RednaxelaFX 的回答 - 知乎 (zhihu.com) ","permalink":"http://answerkobe.github.io/posts/explore-the-kotlin-generics/","summary":"Kotlin 泛型基础 泛型可以让我们在代码中声明类型参数，Kotlin 泛型最基本的使用和 Java 一样，可以声明在类上和函数上，用法也都差不多。\n声明在函数上时，可将类型参数作为参数或返回值的类型，该函数为泛型函数 声明在类上时，可以用在任意一处类型声明处，该类为泛型类 class GenericsDemo\u0026lt;T\u0026gt;(t: T) { val value = t } fun \u0026lt;T\u0026gt; invoke(t: T) : T { return t } 我们可以在声明了类型参数的类中，声明一个泛型方法，但如果内部方法所声明的类型参数名称和类上所声明的相同，那么会覆盖类上所声明的类型参数。下面的代码不会报错，并会打印 Hello 字符串。\nclass GenericsDemo\u0026lt;T\u0026gt;() { fun \u0026lt;T\u0026gt; invoke(t: T) : T { return t } } val demo = GenericsDemo\u0026lt;Int\u0026gt;() println(demo.invoke(\u0026#34;Hello\u0026#34;)) 此外，我们知道在类中可通过重载来定义同名方法，但这在泛型中并不起作用，如果类中拥有以下两个方法，那么将会报错。\nclass GenericsDemo\u0026lt;T\u0026gt;() { // 泛型来自类 fun invoke(t: T) : T { return t } // 泛型来自方法本身 fun \u0026lt;S\u0026gt; invoke(s: S) : S { return s } } 上诉代码报错原因是因为两个方法拥有相同的 signature，也就是在 JVM 看来这两个方法的方法名和参数都是一样的，报错信息如下：","title":"探索 Java \u0026 Kotlin 泛型"},{"content":"Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。\n// ThreadDemo.java static int v = 0; static void autoAdd(){ for (int i = 0; i \u0026lt; 10000; i++) { v++; } } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); System.out.println(v); } 上面代码变量 v 的打印结果可能会小于 20000，随着 v 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。\n要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。\n局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。\n虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。\nThreadLocal 的使用 ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。\nThreadLocal\u0026lt;Integer\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); System.out.println(threadLocal.get()); 我们使用 new 创建的 ThreadLocal 本身是一个对象，如果要获取数据的话，需要调用 get() 方法，上面的代码会得到一个 null，正确的使用方法应当重写 initialValue() 方法，来创建我们需要的初始化值。\nstatic ThreadLocal\u0026lt;Integer\u0026gt; threadLocal = new ThreadLocal\u0026lt;Integer\u0026gt;() { @Override protected Integer initialValue() { return 0; } }; static void autoAdd() { for (int i = 0; i \u0026lt; 10000; i++) { int v = threadLocal.get(); threadLocal.set(v + 1); } System.out.println(Thread.currentThread().getName() + \u0026#34; --\u0026gt; \u0026#34; + threadLocal.get()); } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); } 上面的代码执行结果将会如下\nThread-0 --\u0026gt; 10000 main --\u0026gt; 10000 可以看到两个线程获取到的值都是独享的，彼此间不会相互干扰，因为破坏了同一资源这一要素，因此也不需要考虑线程安全的问题。\nThreadLocal 如何存储各个线程独享的数据 我们知道，变量所存储的是引用，那么简单地通过变量来实现线程独占是比较困难的，如果我们能理解在 ThreadLocal 是用什么结构来存储这些数据，那么就能理解它是怎么做到线程独享的。\npublic T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T result = (T)e.value; return result; } } return setInitialValue(); } 我们使用 ThreadLocal 是通过 get() 方法来获取独享的值的，这个方法会先获取当前线程的 Thread 对象，再根据当前线程去获取一个 ThreadLocalMap，这是一个结构类似于 Java Map 的类，但它并没有实现 Map 接口。\n利用 IDEA 整理一下相关的类可以得到下面的类图\nJava 中每个 Thread 都有一个 ThreadLocalMap 类型的成员变量 threadLocals，这个变量默认为 null。当 ThreadLocal 调用 getMap(Thread t) 的时候，其实只是获取对应 Thread 中的这个 threadLocals，并没有什么复杂的操作。\n// Thread.java ThreadLocal.ThreadLocalMap threadLocals = null; // ThreadLocal.java ThreadLocalMap getMap(Thread t) { return t.threadLocals; } 而 ThreadLocalMap 和 HashMap 类似，都用一个 Entry 数组作为哈希表来存储元素，每一个 Entry 代表一个键值对元素，其中 Entry 的成员变量 value 就是各个线程独享的值，而对应的 key，是一个 ThreadLocal 对象，它使用 WeakReference 来存储。\n按照注释说明，之所以使用 WeakReference 来引用键，是因为方便处理比较大又需要长时间使用的空间。\n/** * To help deal with very large and long-lived usages, * the hash table entries use WeakReferences for keys. */ static class ThreadLocalMap { static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } private Entry[] table; // ... } 到这里可以整理出一个关系链，Thread 中有一个 ThreadLocalMap 成员 threadLocals，它存储各个 ThreadLocal 对应的值，由于不同的线程的 threadLocals 不同，因此相同的 ThreadLocal 在不同线程中获取到的值是不同的，这就是 ThreadLocal 中的值线程独享的原理。\nThreadLocal 的初始化 前面提到 ThreadLocal 的使用需要重写 initialValue() 方法，这是因为并没有办法在创建 ThreadLocal 变量时直接为它赋值一个初始值。\n当调用 get() 方法时，当前线程的 threadLocals 为 null，或者在 threadLocals 中获取不到当前 ThreadLocal 对应的值时，则会调用 setInitialValue() 方法来设置初始值存储到 threadLocals 中，而这个初始值就是通过 initialValue() 方法生成的，如果不重写该方法，默认得到的初始值将会是 null。\nprivate T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } // 初始化值 protected T initialValue() { return null; } 由于线程中的 threadLocals 默认为 null，因此这一步如果得到的 ThreadLocalMap 为 null 的话则会调用 createMap() 方法来创建一个 ThreadLocalMap 对象，并提供第一个元素的 key 和 value 给 ThreadLocalMap。\nvoid createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } ThreadLocalMap(ThreadLocal\u0026lt;?\u0026gt; firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode \u0026amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } ThreadLocal 修改数据 修改 ThreadLocal 中的值可以像上面的例子一样使用 set(T value) 方法，当调用 set() 方法时，如果 threadLocals 还没创建则调用 createMap() 创建并存储新值，否则调用 ThreadLocalMap.set(ThreadLocal\u0026lt;?\u0026gt; key, Object value)。\npublic void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } 需要注意的是，set() 方法并不能用来代替 initialValue() 来对 ThreadLocal 的值进行初始化。因为这需要在每个线程的第一次使用 ThreadLocal 之前都调用一次 set，这会很麻烦。\n另外即便使用了 ThreadLocal，对应的值依旧是一个对象，存放在堆内存中。也就是任何线程其实都有访问该对象的权限。当我们在不同线程调用 set() 存放一个相同的对象时，那么 ThreadLocal 将失去线程独享的副本。\nstatic class Demo { int v = 0; } static ThreadLocal\u0026lt;Demo\u0026gt; threadLocal = new ThreadLocal\u0026lt;Demo\u0026gt;() { @Override protected Demo initialValue() { return new Demo(); } }; public static void main(String[] args) throws Exception { Demo demo = threadLocal.get(); new Thread(() -\u0026gt; { threadLocal.set(demo); threadLocal.get().v = 100; }).start(); Thread.sleep(100); System.out.println(threadLocal.get().v); // 100 } 执行上面代码的输出结果将会是 100。这很好理解，因为两个线程中 ThreadLocal 对应的 value 是同一个对象，因此其中一个线程的修改操作将会影响到其它线程。\nThreadLocalMap 的一些细节 ThreadLocalMap 和 HashMap 不同，获取 Entry 下标使用的不是 ThreadLocal 对象的 hashCode，而是 threadLocalHashCode。\n// ThreadLocalMap 中获取对应 Entry 下标 // key 是一个 ThreadLocal 对象 int i = key.threadLocalHashCode \u0026amp; (table.length - 1); 这个值由 ThreadLocal 一个 AtomicInteger 类型的静态成员 nextHashCode 的 getAndAdd() 方法生成。\n// ThreadLocal private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } 另外，哈希表可能会发生哈希冲突，ThreadLocalMap 处理哈希冲突采用的是闭散列，没有采用哈希桶可能是我们代码中的 ThreadLocal 并不会很多，发生冲突的概率比较小。\nprivate void set(ThreadLocal\u0026lt;?\u0026gt; key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode \u0026amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal\u0026lt;?\u0026gt; k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) \u0026amp;\u0026amp; sz \u0026gt;= threshold) rehash(); } 内存溢出问题 static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } 内存溢出是使用 ThreadLocal 需要注意的一个问题，但使用 ThreadLocal 时发生内存泄露的不是 ThreadLocal 对象，而是存储在 Entry 中对应的 value。\nThreadLocal 对象并不会发生内存泄露，当我们将 ThreadLocal 引用置为 null 时，由于在 Thread 中的 ThreadLocalMap 中的 Entry，对 ThreadLocal 是一个弱引用，因此发生 GC 时就会被回收。\n所以在 ThreadLocalMap 中可能存在 key 为 null 的 Entry，但由于这个 Entry 以及存储的 value 本身是一个强引用，因此不会被回收，这才发生了内存泄露。\n其实 ThreadLocalMap 的生命周期线程相同，当线程运行结束，线程将会被销毁，那么 ThreadLocalMap 对象、存储的 Entry 对象以及 value 引用的对象也会被回收。\n但如果使用的是线程池，线程执行完任务并不会被销毁，而是放回线程池，那么对应的 value 会一直存在，这才发生了内存泄露。\nThreadLocal 提供了 remove() 方法，可将当前线程对应 ThreadLocal 的 Entry 中 WeakReference 对 ThreadLocal 的引用和 value 对 Object 的引用都设置为 null，同时移除该 Entry 对象。\n当 ThreadLocal 使用完后，在将引用设置为 null 前，应当调用 remove() 来防止内存泄露。\n// ThreadLocal public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } // ThreadLocalMap private void remove(ThreadLocal\u0026lt;?\u0026gt; key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode \u0026amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // ... } // WeakReference --\u0026gt; Reference public void clear() { this.referent = null; } ThreadLocal 使用小技巧 ThreadLocal 尽量声明为静态 对于一个 ThreadLocal 变量而言应当声明为静态的，因为每个线程访问该变量时应该是同一个 ThreadLocal 对象，如果不声明为静态的话，需要创建对应 ThreadLocal 所在类的对象来使用它，如果我们创建多个对象将会拥有多个相同作用的 ThreadLocal，这只是在增加内存的消耗。\nwithInitial() 配合 Lambda 表达式 定义 ThreadLocal 初始化也可以通过调用 withInitial() 方法传入 Supplier 对象来实现，Supplier 是一个接口，需要重写的方法只有 get()，因此我们可以配合 Lambda 表达式或者 Method Reference 来使用。\nstatic ThreadLocal\u0026lt;Integer\u0026gt; threadLocal1 = ThreadLocal.withInitial(() -\u0026gt; 0); static ThreadLocal\u0026lt;Demo\u0026gt; threadLocal2 = ThreadLocal.withInitial(Demo::new); withInitial() 方法会返回一个 SuppliedThreadLocal 对象，SuppliedThreadLocal 的大部分功能继承自 ThreadLocal，但它帮我们重写了 initialValue() 方法，通过调用传入的 Supplier 对象的 get() 方法来获取初始化值。\npublic static \u0026lt;S\u0026gt; ThreadLocal\u0026lt;S\u0026gt; withInitial(Supplier\u0026lt;? extends S\u0026gt; supplier) { return new SuppliedThreadLocal\u0026lt;\u0026gt;(supplier); } static final class SuppliedThreadLocal\u0026lt;T\u0026gt; extends ThreadLocal\u0026lt;T\u0026gt; { private final Supplier\u0026lt;? extends T\u0026gt; supplier; SuppliedThreadLocal(Supplier\u0026lt;? extends T\u0026gt; supplier) { this.supplier = Objects.requireNonNull(supplier); } @Override protected T initialValue() { return supplier.get(); } } 参考 理解Java中的ThreadLocal Red Rose - ThreadLocal 内存泄漏问题深入分析 ","permalink":"http://answerkobe.github.io/posts/threadlocal-usage-and-source/readme/","summary":"Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。\n// ThreadDemo.java static int v = 0; static void autoAdd(){ for (int i = 0; i \u0026lt; 10000; i++) { v++; } } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); System.out.println(v); } 上面代码变量 v 的打印结果可能会小于 20000，随着 v 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。\n要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。\n局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。\n虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。\nThreadLocal 的使用 ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。\nThreadLocal\u0026lt;Integer\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); System.","title":"从源码角度分析 ThreadLocal 的使用"},{"content":"Java 的 HashMap 可以说是用的最多、问的最多的一个 Map Collection 了。HashMap 是非同步的，即线程不安全。HashMap 允许存放的 key 为 null，但并不保证映射的顺序，也不保证这个顺序随时间保持不变。\n本文对 HashMap 的代码分析基于 JDK 1.8\npublic class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable 我们可以先从 HashMap 底层使用的数据结构了解 HashMap。\n哈希表 + 链表 / 红黑树 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; // ... } /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node\u0026lt;K,V\u0026gt;[] table; /** * The number of key-value mappings contained in this map. */ transient int size; HashMap 最基本的数据结构是哈希表 table（一个 Node 数组）。在 HashMap 中，把数组每个下标对应的空间称为 bucket（哈希桶），bucket 的数量就是数组的长度。\nHashMap 的 table 是懒加载的，当我们创建 HashMap 实例的时候并不会马上创建 table 数组实例，而是在第一次向 HashMap 实例添加元素的时候，才会进行初始化。\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 初始化 table if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { /* 发生哈希碰撞时的处理 */ } // ... return null; } HashMap 存放和获取数据时，都需要通过计算 key 的 hash 值来并映射为 bucket 的下标。不同的 key 得到的下标可能相同，在存放新数据时，计算出来的下标对应的 bucket 中如果已经存在其它节点，这种情况称为哈希碰撞 / 哈希冲突。\n在 HashMap 中采取的是开散列的方式来处理哈希碰撞，当发生碰撞时，通过链表的方式，将新的节点连接在已有节点的后面，当链表长度超过规定的阈值时，将会把链表转换为红黑树来进行存储（红黑树是在 JDK 1.8 才引入的）。\nstatic final int TREEIFY_THRESHOLD = 8; for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } 链表转换为红黑树的阈值为 TREEIFY_THRESHOLD，该值固定是 8，当链表长度达到这个值时，会调用 treeifyBin() 方法尝试转换为红黑树，最终是否转换为树还要根据当前 table 容量决定。\nstatic final int MIN_TREEIFY_CAPACITY = 64; final void treeifyBin(Node\u0026lt;K,V\u0026gt;[] tab, int hash) { int n, index; Node\u0026lt;K,V\u0026gt; e; if (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) \u0026amp; hash]) != null) { // ... } } MIN_TREEIFY_CAPACITY 是 bucket 结构树形化 table 要求的最小容量，当 table 太小没有达到这个值时（固定是 64），HashMap 会采用扩容的方式来重新打散这些节点的分布。\n从 HashMap 使用的数据结构，我们可以分析出它对应的查找时间复杂度：\n当没有发生碰撞时，那么通过计算下标直接命中对应节点，时间复杂度为 O(1) 当下标位置是发生碰撞 bucket 时，如果起连接作用的数据结构是链表的话，那么时间复杂度为 O(n)，n 是链表长度 当链表过长转换为红黑树时，时间复杂度为 O(log(n))，n 是树的节点个数。 因此，HashMap 发生碰撞的次数越少，查找效率也会越高。\nhash 与 下标计算 添加节点所调用的 putVal 方法第一个参数就是 key 的 hash 值，hash 值通过 (n - 1) \u0026amp; hash 这一运算，映射为 table 中存放位置的下标。在 HashMap 中通过 hash() 方法来获得 key 对应的 hash 值。\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 当 key 为 null 的时候，该方法直接返回的 hash 值是 0，因此在 HashMap 中，是允许 key 为 null 的，并且它只能拥有一个 null 的 key。\n当 key 不为 null 的时候，那么获取 key 的 hashCode 赋值为 h，hashCode 是将对象的内部地址转换为 int 类型的整数（这是一个 native 方法，具体看 JVM 如何实现）。\n计算下标使用的是将 hash 值和 table 数组下标的最大取值 n - 1 进行 \u0026amp; 运算（与运算），这个过程是将 hash 值高位归 0，保留 n - 1 取值范围内的低位，从而转换为 table 数组可取的下标。\n对于 32 位的 hashCode 而言，一般是不会发生碰撞的，但由于位运算会忽略高位的数值，实际参与运算的只有低位，这就增加了碰撞的概率，运气不好的话，出现高位不同而低位相同的情况，那么碰撞将会比较严重。\n因此在 HashMap 中不直接拿 hashCode 来作为 hash 值进行下标运算，而是使用了一个将高位影响向下传播的变换方案，对 hashCode 的高 16 位和低 16 位进行一次异或操作，来将高位的特征混合到低位中，使得高位的影响也可以参与下标计算的 \u0026amp; 运算中。\nHashMap 对这个扰乱操作是从实用性、速度、质量方面考虑的，关于这方面的说明，JDK 1.8 源码中一段注释我没完全看懂，这里贴在下面，或者可以自己去源码阅读完整的说明。\nThere is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don\u0026rsquo;t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.\n此外，每个 Node 节点在创建时就会保存对应的 hash 值，后续扩容迁移节点时计算下标，不需要重新计算 key 的 hash 值。\nresize() 扩容机制 我们知道发生冲突时，会使用链表或者树来处理 bucket 的碰撞集，那么 table 将不会发生溢出的情况。当 table 大部分 bucket 存有节点的时候，那么此时碰撞率将会非常高，碰撞会降低 HashMap 的查找效率，因此需要给 table 设置一个容纳极限 threshold。\n添加节点时，除了链表转换为红黑树时 table 容量没有达到 64 会进行扩容外，如果完成节点的添加后，当前 table 存储的节点超过了容纳极限 threshold，也会进行扩容操作，调整节点的分布情况。\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; int threshold; final float loadFactor; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // ... if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 当 table 存储的节点数量超过目前的 threshold，那么对 table 进行扩容操作，并重新分配已有的节点，通常 threshold 的值是 table.length * loadFactor。除非超出规定大小，否则初始化时和每一次扩容后 threshold 的值都会更新。\nloadFactor 称为负载因子，默认是使用 DEFAULT_LOAD_FACTOR 的值 0.75，这代表在碰撞次数为 0 的情况下，有超过 75% 的 bucket 被使用就会进行扩容操作。0.75 是从时间和空间上进行权衡得出的值，当负载因子更大时，会减少空间的开销，因为扩容所要求的 threshold 会更高，但这也可能会增加查询的时间成本，因为每个 bucket 发生哈希冲突的次数和概率会变得更高。\n/** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // aka 16 final Node\u0026lt;K,V\u0026gt;[] resize() { Node\u0026lt;K,V\u0026gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap \u0026gt; 0) { if (oldCap \u0026gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap \u0026lt;\u0026lt; 1) \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; oldCap \u0026gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr \u0026lt;\u0026lt; 1; // double threshold } else if (oldThr \u0026gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] newTab = (Node\u0026lt;K,V\u0026gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { /* 扩容后迁移节点 */ } return newTab; } 初始化与自定义 在 resize() 中会根据 table 原本的容量大小 oldCap 是否为空来判断进行初始化还是扩容，如果进行初试化，则根据原本的容纳极限 oldThr 来决定初始化容量。\n当我们使用无参数构造方法创建 HashMap 对象时，threshold 默认为 0，也就是 oldThr == 0，此时使用 DEFAULT_INITIAL_CAPACITY 来作为初始化容量，其大小为 16，初始化后 threshold 的新值为 DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY。\npublic HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;Illegal initial capacity: \u0026#34; + initialCapacity); if (initialCapacity \u0026gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\u0026#34;Illegal load factor: \u0026#34; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } 我们可以使用 HashMap 的有参构造方法指定 initialCapacity 来自定义初始化容量，也可以通过有参构造方法指定 loadFactor 的值。\n在 HashMap 中规定初始化容量必须时 2 的幂，并且规定 table 最大长度为 MAXIMUM_CAPACITY，因此会调用 tableSizeFor() 方法来获得符合要求的目标容量，并赋值给 threshold。\ntableSizeFor() 通过一系列右移和或运算的结合，来保证得到的值是一个 2 的幂，并且保证该值不会超过 HashMap 限制的最大容量 MAXIMUM_CAPACITY。\n/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two \u0026lt;= 1\u0026lt;\u0026lt;30. */ static final int MAXIMUM_CAPACITY = 1 \u0026lt;\u0026lt; 30; static final int tableSizeFor(int cap) { int n = cap - 1; n |= n \u0026gt;\u0026gt;\u0026gt; 1; n |= n \u0026gt;\u0026gt;\u0026gt; 2; n |= n \u0026gt;\u0026gt;\u0026gt; 4; n |= n \u0026gt;\u0026gt;\u0026gt; 8; n |= n \u0026gt;\u0026gt;\u0026gt; 16; return (n \u0026lt; 0) ? 1 : (n \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 当初始化 table 时原本 threshold 的值 oldThr 不为 0，则用该值作为初始化容量进行初始化，newThr 为负载因子（创建对象时可能指定了 loadFactor）和新容量的积 newCap * loadFactor。\n在 HashMap 中有规定 table 的最大容量 MAXIMUM_CAPACITY，我们自己指定的容量可能达到这一大小，当新容量的大小或新容纳极限达到或超过这个限制时，将会使用 int 类型的最大值 Integer.MAX_VALUE 作为新的容纳极限。\n扩容与节点迁移 HashMap 扩容时，新容量为旧容量的两倍，如果扩充出来的新容量比限制的最大容量 MAXIMUM_CAPACITY 大，那么将会使用最大容量作为新容量，如果原本的容量就已经达到限制的最大容量，那么不进行扩容，直接将原本的 table 返回，而 table 的容纳极限 threshold 变为 int 类型的最大值。\n在扩容后，需要将节点迁移到新的 table 里面，迁移时需要根据节点的 hash 值重新计算下标。\nif (oldTab != null) { for (int j = 0; j \u0026lt; oldCap; ++j) { Node\u0026lt;K,V\u0026gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash \u0026amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node\u0026lt;K,V\u0026gt; loHead = null, loTail = null; Node\u0026lt;K,V\u0026gt; hiHead = null, hiTail = null; Node\u0026lt;K,V\u0026gt; next; do { next = e.next; if ((e.hash \u0026amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } 对于只有单个节点的 bucket，直接计算这个节点在新 table 的位置并插入 对于链表和树，则是通过查看新增加的一位二进制来决定在新 table 的位置，再和已经存在的节点组合起来 我们知道下标的计算采用 \u0026amp; 运算，而新的容量是旧容量的 2 倍，也就是对应的二进制左移了一位，那么下标的取值范围相比原本，从二进制数上看，就是增加了一位，因此我们只需要看新增加的那一位二进制数是 0 还是 1，就能确定节点的新位置。\n实际上增加的那一位在数值上大小就是原本 table 的容量大小，如果新增加的那一位是 1，那么代表新的下标为当前的下标加上原本的容量大小 j + oldCap，这也是为什么 HashMap 规定 table 的长度必须是 2 的幂。\n在发生冲突的 bucket 中查找节点 public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } HashMap 的查找操作使用 get(Object key) 来获取对应 Key 的 Node 节点，并返回节点中的 value 值。查找时需要获取对应的 key 的 hash 值，查找时需要获取到 key 的 hash 值来计算对应 Node 节点所在的 bucket 的下标。\nfinal Node\u0026lt;K,V\u0026gt; getNode(int hash, Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; hash]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 我们知道 bucket 可能发生哈希碰撞，因此在 bucket 可能存在多个节点（以链表或树的结构组织起来），此时如果要找到对应 key 的节点，则需要对 bucket 中存放的节点逐个对 key 进行匹配。\n在 HashMap 匹配 key 的方式，是先判断两个对象是否相同，如果不同再使用 equals() 方法来判断两个对象的内容是否相等。当节点中的 key 与我们查找的 key 相同时，则返回该节点，如果所有节点的 key 都不匹配时，则返回 null。\n这个操作不仅仅存在于查找元素，也存在于 put() 方法进行元素的存放，当发生碰撞后，新存放的元素对应的 key 在 bucket 中已经存在对应的 Node 节点时，将会用新节点覆盖原有节点的。\n// putVal 发生碰撞的 else 块中 if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; 因此，无论是 put() 或是 get()，第一步都是需要通过 hashCode() 进行运算来获得 hash 值，并找到对应 bucket 的下标，发生哈希碰撞时需要使用 equals() 来判断两个 key 是否相等，这也是为什么我们在编写类时，如果重写了 hashCode() 需要重写 equals() 方法。\n参考 JDK 1.8 源码\n不按套路出牌，HashMap负载因子超过1会怎样？\n","permalink":"http://answerkobe.github.io/posts/the-principle-of-hashmap/","summary":"Java 的 HashMap 可以说是用的最多、问的最多的一个 Map Collection 了。HashMap 是非同步的，即线程不安全。HashMap 允许存放的 key 为 null，但并不保证映射的顺序，也不保证这个顺序随时间保持不变。\n本文对 HashMap 的代码分析基于 JDK 1.8\npublic class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable 我们可以先从 HashMap 底层使用的数据结构了解 HashMap。\n哈希表 + 链表 / 红黑树 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; // ... } /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two.","title":"基于 JDK 1.8 分析 HashMap 的底层原理"},{"content":"红黑树（Red-Black Tree）是一种自平衡的二叉查找树（Binary Search Tree, BST），由于基于二叉查找树（并不是基于 AVL 树），因此它是有序的。它出现于 1978 年 Leo J. Guibas 和 Robert Sedgewick 的一篇论文。\n红黑树和 AVL 树很像，都是为了让二叉查找树能保持平衡，不会退化成链表，让查找时间复杂度能够稳定在 O(log(n))。\n相比 AVL 树，红黑树牺牲了部分平衡性来，来减少插入 / 删除操作的旋转次数。因此插入性能红黑树会比 AVL 树快，但由于平衡性不如 AVL 树，当拥有相同数量的节点时，树的层数可能会比 AVL 树高，查询效率也不如 AVL 树。\n由于红黑树的结构比较复杂，因此它也比较难理解，但我们可以借助 2-3-4 树来理解它。\nPerfect Balance 的 2-3-4 树 介绍 2-3-4 树的资料可能比较少，由于 2-3-4 树的图画起来比较麻烦，为了偷懒本文选取了 Sedgewick 介绍 LLRB Tree（左倾红黑树） 的 PPT 中的一些图来做说明，该 PPT 链接放在本文末尾参考部分。\n2-3-4 树也是一颗自平衡的树，但它的节点比较特殊，可以分为以下 3 种节点：\n2-node：普通的树节点，可存放一个数据，最多有两个子节点 3-node：能存放两个数据的节点，最多能有三个子节点 4-node：能存放三个数据的节点，最多能有四个子节点 它们的结构图示如下（该图来自 Sedgewick 的 PPT 第 12 页）：\n该图中对子节点的连接位置进行描述的只有 3 节点，不过 4 节点与子节点连接方式其实也是一样的，子节点的连接决定于子节点存放的数据的大小范围和父节点的存放的数据的大小。\n2-3-4 树的结构是 Perfect Balance（完美的平衡）的，不同分支的高度都是一样的。\n在 2-3-4 树中，添加数据与普通的树不同，并不会在树根直接创建新的子节点进行插入，而是放入插入位置的父节点中，成为 3-node 或 4-node。\n以上面图示的 2-3-4 树插入数据 B 为例子，插入位置如下图所示（该图来自 Sedgewick 的 PPT 第 15 页）：\n可以看到，B 并不是直接插入到 Node(A) 的下面作为子节点，而是将 B 放进 Node(A)，使得该节点成为了 3-node Node(A B)，从而使得树的高度并没有变化。\n如果该节点原本是 4-node，将无法放入新的数据时。在 Sedgewick 的 PPT 中也有该情景的介绍，这是一个插入数据是 H 的例子：\n首先寻找插入位置，H 应该插入的地方是 Node(F G J) 的下面，由于 2-3-4 树并不会直接创建新节点进行插入，因此 H 应该添加到 Node(F G J) 的 G 和 J 之间，但此时的 Node 已经是一个 4-node，无法放入新的数据。因此，需要进行如下的 4-node 拆分操作：\n将中间的数据放到父节点中，父节点从 3-node Node(C E) 变成了 4-node Node(C E G) 将其它两个数据拆分成两个节点 2-node Node(F) 和 Node(J)，并按照规则和 Node(C E G) 进行连接 将 H 放到对应的节点 Node(J) 中，成为 3-node Node(H J) 这里有需要考虑的问题，如果父节点也是 4-node 怎么办？\n如 PPT 所说明的一样，解决的方案有两种：\n自底向上的解决方案：使用相同的方法对父节点进行拆分操作，不断向上处理，直到拆分的节点的父节点不是 4-node 为止 自顶向下的解决方案：先从上往下拆分 4-node，最后再进行添加操作 对于第一种方案，可能有这样一个问题，如果 4-node 是根节点，它没有父节点，应该怎么处理。\n实际按照 2-3-4 树的插入流程，根节点将会创建一个新的节点作为根节点。\n从这可以看出，2-3-4 树通过创建根节点来增加新的节点，这样就可以避免因为创建子节点造成某个分支的高度发生变化，而破坏树的平衡。2-3-4 树这种节点增加方式可以保证树的 Perfect Balance。\n第二种方案由于是自顶向下，因此可以在对插入位置查找时顺便完成路径上 4-node 的拆分操作。\n在从上往下时，首先要确保当前节点不是一个 4-node。当下一个节点是 4-node 的时候，进行拆分操作。由于当前节点不是 4-node，因此当前节点不会出现溢出，只会变成 3-node 或 4-node，而下一个节点将会变成 2-node。\n这样就可以保证，路径上不会有两个连续的 4-node，并且到达底部时，一定是一个 2-node 或者 3-node（因为如果是 4-node 的话会被拆分成 2-node），此时进行插入操作时，就可以直接进行添加，不需要再进行拆分操作。\n将 2-3-4 树转化成红黑树 其实红黑树是 2-3-4 树的一种抽象表示，由于 2-3-4 树的实现较为困难，因此一般可以直接使用红黑树来当作 2-3-4 树使用。\n将 2-3-4 树转换成红黑树的关键点在与 3-node 和 4-node 的转换。我们现在已经知道了 2-3-4 树的节点有 3 种，而红黑树其实只有 2-node。\n我们可以将 3-node 和 4-node 拆分成多个 2-node，为了表示它们原本是 3-node 或者 4-node，需要为它们建立一种特殊的关联，这种特殊的关联就是红黑树中的颜色。\n在红黑树中有红、黑两种颜色（当然并不规定一定是红和黑，可以是其它颜色），两个节点之间是黑色的连接代表两个 2-node 节点的普通连接，两个节点之间是红色的连接代表一个 3-node，当一个节点与两个子节点都是红色连接，说明是一个 4-node。\n从树的平衡角度思考，使用 4-node 中间的节点来作为父节点，其它两个节点作为子节点，那么在局部将会形成一个稳定的二叉树。如果从两侧开始建立父节点，用连续的红连接来代表 4-node，那么从局部上看将会退化成长度为 3 的链表，导致红黑树整体的平衡性非常差。\n2-3-4 树节点之间原本连接使用黑连接，因此转换成红黑树后，一条路径上不存在两条连续的红连接，连续的两个红连接代表一个节点同时与其它节点构成两个 3-node 或 4-node，这是一个矛盾的存在。\n我们实际编写代码的时候，在树这种结构中，只会定义节点，而连接是通过指向来完成的，因此并不存在连接这种抽象的东西。那么，如果希望两个节点的连接具有颜色，我们可以把颜色存放在节点上面。对于一个普通的 2-node，它可以有一个父节点和两个子节点。因此使用红色连接的两个父子节点，颜色应当存放在子节点，而父节点为黑色。\n此时，我们可以定义红黑树去代表 2-3-4 树：\n使用黑色节点去表示 2-3-4 树的所有节点 使用红色的子节点来让该节点代表 3-node 和 4-node 一个 2-3-4 树转换成红黑树的例子如下：\n根据 2-3-4 树的性质，以及我们转换成红黑树时的规则，我们可以得到红黑树的以下 5 条性质：\n每个节点都有颜色，要么是黑的（代表一个 2-3-4 树节点），要么是红的（代表 2-3-4 树 3-node 或 4-node 的其它元素）； 由于每个 2-3-4 树的节点都是黑色，而 3-node 或者 4-node 的其它元素使用红色节点表示，代表红色节点无法作为根节点，根节点只能是黑色； 不能有连续的两个红色节点，也就是红色节点的两个子节点都是黑色的 叶子节点为黑色（叶子节点为树尾端的节点，为空指针，由于性质 1 和 4，其颜色不能为红色） 由于 2-3-4 树是一个 Perfect Balance 的树，因此每个节点下各个路径包含的节点数都相同，因此红黑树每个节点的各个路径到树尾包含的黑色节点数目也都相同 只要红黑树满足这 5 条性质，那么就可以保证其结构相对平衡。\n为什么不是 Perfect Balance？\n因为红黑树引入了红色节点来表示 2-3-4 树中的 3-node 和 4-node 的其它元素，因此红黑树的节点数会比原本 2-3-4 树的节点树要多，破坏了原本 2-3-4 树节点的 Perfect Balance。但根据性质 3 和 性质 4，最不平衡的情况为最长路径上的节点为全黑，最短路径上的节点为一半黑一半红，此时红黑树的各个路径的高度还是不会超过最短的路径的 2 倍。\n红黑树的插入 红黑树与 AVL 树的区别就是它牺牲了一部分平衡性来换取插入 / 删除的性能，因此它的平衡判断条件要比 AVL 树宽松。对于红黑树和 AVL 树，两者的自平衡操作都是通过旋转操作完成，因此我们需要先了解树的旋转操作。\n左旋和右旋 树的旋转操作分为左旋和右旋，两个其实是对称的操作，因此只需要理解一个就可以了。\n我们先从右旋来开始理解，首先在进行旋转时，我们需要选取一个节点作为旋转点，下图旋转节点 E 作为旋转点。\n进行右旋时，将左子节点 C 提升到旋转点的位置，选择点的节点 E 成为左子节点 C 的右子节点。由于节点 C 原本的父节点 E 成为了它的右子节点，因此节点 C 多出了一个右节点，此时需要将节点 C 原本的右子节点 D 变成节点 E 左子节点。\n这就是右旋的过程，左旋的过程其实是右旋的过程的镜像操作，如下图。\n节点插入情况 在红黑树中，所有新插入的节点颜色都是红色（因为它可能会成为 3-node 或者 4-node 的附属节点），因此在插入节点时，我们需要判断插入时是否会破坏红黑树的性质，如果破坏了红黑树的性质，代表需要进行调整。\n我们可以把插入时情况根据父节点的颜色分为以下 3 类：\n父节点是空节点； 父节点是黑色； 父节点是红色，叔叔节点为黑色； 父节点是红色，叔叔节点是红色。 父节点是黑色或为空 如果父节点是黑色，代表在对应的 2-3-4 树中，新节点插入前父节点代表的是一个 2-node 或者 3-node（4-node 的两个子节点都是红色），插入后父节点和其子节点可以变成 3-node 或者 4-node。\n这种情况下新节点可以直接插入，不需要做调整。如果原本的树是空树，当前节点插入后将会成为根节点，此时只需要将该节点颜色变为黑色就可以了，由于只有一个节点，同意不需要做调整。\n父节点是红色，叔叔节点是黑色 当父节点是红色时，代表父节点与祖父节点（祖父节点必然为黑色）构成 3-node 或者 4-node。当叔叔节点为空时，代表父节点与祖父节点构成的是一个 3-node。\n因为根据红黑树的性质 5，祖父节点下各个路径的黑色节点数都是相同的，因此对于新插入在树尾的情况，叔叔节点只能是空节点或红色节点，不能是实际存在的黑色节点。但在下方有一种情况需要往上继续判断树的平衡，这种时候向上转移的红色节点，其叔叔节点才有可能是一个存在的黑色节点，由于红黑树规定空节点也是黑树，因此我们可以把它们归为同一类情况。\n由于红黑树不允许同一路径上拥有两个连续的红色节点，因此需要对祖父节点下的局部子树进行调整。在 2-3-4 树中，当一个节点插入到 3-node 下方时，将会直接将该节点的值放到 3-node 中，形成 4-node。\n我们可以通过上面所提到的旋转操作以及对节点适当的变色来完成局部的平衡调整。\n进行旋转时，我们需要将情况分为两种：\n祖父节点和父节点和新节点在同一方向的路径上。 祖父节点和父节点和新节点不处于同一方向的路径上。 当 3 个节点都在同一个方向的路径上，此时 3 个节点按顺序其实可以形成一个 4-node，而父节点代表对应 4-node 中间节点，因此我们的需要做的是将父节点变成代表 4-node 的黑色节点，祖父节点和新节点变成两个红色的附属节点。\n以 3 个节点都在右斜线的方向上为例，我们可以将祖父节点的颜色变成红色，把父节点的颜色变成黑色，然后对祖父节点进行左旋操作，这样就可以得到一个符合规定的 4-node 了。当然，如果是在左斜线上，那么进行右旋就可以了。\n当 3 个节点不在同一个方向的路径上时，我们可以对父节点进行旋转，让 3 个节点变成同一方向路径上的节点。进行旋转操作时，以祖父节点和父节点的方向为基准，将子节点旋转到该方向的路径上。\n这样就可以转换成同一方向路径上的情况来解决了。\n父节点是红色，叔叔节点也是红色 当父节点和叔叔节点都是红色时，代表祖父节点是一个 4-node，按照 2-3-4 树的插入操作，当一个新的节点需要插入到 4-node 下面时，由于 4-node 无法添加新的数据，需要进行拆分操作。\n拆分时，4-node 的中间节点将会提升到父节点中，在红黑树中对应操作则是变成一个红色的节点，而其它两个节点则拆分成两个 2-node。\n因此我们在红黑树中对应的操作应当是将祖父节点的颜色变成红色，两个子节点（父节点和叔叔节点）的颜色变成黑色，此时由于新节点的父亲节点是黑色，因此可以直接进行插入操作。\n在 2-3-4 树讨论 4-node 拆分操作时讨论过一个问题：如果 4-node 的父节点也是 4-node 的话应该如何处理？\n在红黑树中我们也需要考虑这个问题，因为祖父节点的父节点也可能是红色（黑色的话代表不是 4-node，红色代表可能是 3-node 或者 4-node），当我们完成对新节点的平衡操作后，需要将操作节点指向祖父节点，对祖父节点的父节点的颜色进行判断，并进行必要的平衡调整。这里使用的是上面讨论 2-3-4 树的 4-node 拆分时提到的自底向上的解决方案，它比自顶向下的解决方案要好理解，实际代码实现时也比较方便，并且大部分文章插入和删除使用的也是该方法，但该方法有个缺点，它需要在节点中维护一个父节点指针，并且在删除操作中会变得非常复杂。\n节点删除 删除节点和添加节点一样可能会破坏红黑树的性质，因此根据情况在删除时也需要对红黑树进行必要的平衡调整。\n在进行节点删除时，我们需要删除的节点可能是叶子节点，也可以是树某个路径上的其中一个节点，如果我们需要删除路径上的一个节点，那么为了保证树的结构，我们需要找其它节点来顶替删除的节点。\n如果待删除的节点的子节点也有 2 个子节点，那么选取子节点来替换删除的节点显然不合适，因为会出现多余的分支无法插入到树中。因此最好的方式是选择最接近删除节点值的叶子节点，这通常是左子节点中序遍历最后一个节点或者右子节点中序遍历的第一个节点。\n现在我们可以将删除节点的问题转变为删除叶子节点了，我们可以对删除的叶子节点的情况进行分类，我们知道在 2-3-4 树中，在树尾部删除一个存在于 3-node 或者 4-node 的数据并不会产生节点数量的变化，因此在红黑树中我们可以直接删除红色的叶子节点，因为这并不会破坏红黑树的性质。\n自顶向下合并 2-node 实际上，我们可能会遇到需要删除黑色节点的情况，该操作对应 2-3-4 树中删除 2-node 的操作，这将会破坏树的平衡性，因此我们需要保证我们所删除的节点是红色的。\n在讨论 2-3-4 树 4-node 拆分的解决方案时，除了自底向上的解决方案外（这方案已经被我们应用到了上面红黑树的插入中），我们还讲过自顶向下的解决方案，他在寻找新节点插入位置时，将下方路径上的 4-node 进行拆分，以便最后插入节点时不会遇到 4-node。\n我们也可以将这一方法的思路应用到删除操作中，我们只要在寻找删除节点时，将节点下方路径的 2-node 逐个合并为 3-node 或者 4-node，就可以避免删除的节点是一个 2-node。\n这一方法与大部分文章所使用的方法并不同，该方法来自 Robert Sedgewick 在 Left-leaning Red-Black Trees 这一篇论文中，这里没有选择大部分文章所使用的自底向上的方案，而选择使用自顶向下的方案的原因，是因为它不需要去对各种情况产生的平衡问题进行分析，以及对不同场景的解决方案进行区分，并且也不会出现遗漏的修复或者为了实际不存在的情况而编写多余的代码。\n该方法的实现思路，在进行操作时，要确保当前搜索到的 current 节点不是一个 2-node 节点。根据下一个查找节点 next 的兄弟节点的情况，可分为 2 种操作：\ncombine siblings：next 节点的兄弟节点也是 2-node，那么需要将 current 节点中分离一个节点出来，和兄弟节点一起形成一个 4-node； borrow from sibling：next 节点的兄弟节点是 3-node 或者 4-node，那么只需要向兄弟节点借一个节点形成 3-node。 完成合并操作后，将当前搜索到的节点 current 指向 next，相关图示如下（该图来自 Sedgewick 的 PPT 第 55 页）：\n在红黑树中的实现方式 上面的 2 种操作对应到红黑树中，实现流程如下图所示：\nborrow from sibling 的操作比较麻烦，因为兄弟节点中的数据整体都要比 current 节点的小 / 大，因此 next 节点并不是直接在兄弟节点中取一个进行合并，而是在 current 节点中取一个节点进行合并，父节点再从兄弟节点中拿一个进行补充。\n对于兄弟节点是 4-node 的情况，需要将代表 4-node 的三个节点旋转到与父节点同一斜线上，并改变当前节点和父节点的颜色，让父节点成为一个 4-node，再对父节点进行旋转操作。\n对于兄弟节点是 3-node 的情况，也是将 current 节点变成 3-node，再从兄弟节点拿一个上去顶替。当兄弟节点的红色子节点与兄弟节点和父节点（current）在同一斜线上时，只需要交换兄弟节点和红色子节点的颜色，如果不在同一斜线，就和 4-node 一样进行一次旋转操作。\n当在寻找删除节点和替换节点的过程中往下不断对 2-node 完成上述操作，就可以保证在最后删除的叶子节点是一个红色的节点，此时直接删除就不会破坏树的平衡，该方法在左倾红黑树 (Left-leaning Red-Black Trees, LLRB) 中实现更加简单。\n解决根节点是 2-node 由于是自顶向下进行查找和合并，因此除了根节点，current 节点一定是一个 3-node 或者 4-node，因此该方案才能正常使用。如果根节点是一个 2-node，根据情况我们需要考虑是否需要对根节点进行操作。\n如果作为 2-node 的根节点的两个子节点也是 2-node，由于作为父节点的根节点不能转变成红色，没办法使用 combine siblings 操作，来让 next 节点变成 4-node，我们依旧可以让根节点和子节点合并成 4-node，由于该操作是根节点进行，因此不会破坏树整体的平衡。\n如果根节点中有一个节点是 3-node 或者 4-node，那么我们不能直接去改变两个子节点的颜色，但如果此时已经有一个节点是 3-node 或者 4-node，而另一个节点是 2-node，那么我们依旧可以使用 borrow from sibling 的操作，向兄弟节点借一个来让 2-node 变成 3-node。此时，对于 borrow from sibling 操作，current 不再是红色，因此我们可以对该操作的算法进行改进，让它同时支持 current 是黑色和红色，我们使用绿色来表示未知的颜色，改进后的过程如下图所示。\n此时，对于根节点是 2-node 的两种情况，我们都有对应的解决方案，那么红黑树的相关操作我们就讲完了。那么现在我们可以开始使用代码来实现红黑树了。\n代码实现（Kotlin） 在实现红黑树之前，我们应该了解一下，红黑树适合存放什么类型的数据，个人观点，二叉查找树应当是作为加速链表查询速度的一种替换方案，因此对于使用专门的字段来查找数据的场景，才更加适合使用红黑树这一类二叉查找树的结构。\n因此在代码中，我采用了 key 作为存储和查找依据，使用泛型来让创建者自定义红黑树的存放的数据。这和 Java 中的 HashMap 和 TreeMap 中的实现是相对应的，但为了简化操作，这里的 key 直接定义为 Int 类型，而不是使用对象的 Hash 值。\n源码地址：https://github.com/korilin/DSA-kt/blob/main/src/main/kotlin/data_structure/RBTree.kt\n参考 30张图带你彻底理解红黑树 - 安卓大叔 | 简书 算法 理解红黑树 - Ruby China @join Left-Leaning Red-Black Trees (PPT) - Robert Sedgewick | Princeton University Left-leaning Red-Black Trees (Paper) - Robert Sedgewick | Princeton University 红黑树深入剖析及Java实现 - 美团技术团队 The-Art-Of-Programming-By-July - github/julycoding 通俗易懂的红黑树图解(下) - 政采云前端团队 | SegmentFault ","permalink":"http://answerkobe.github.io/posts/red-black-tree/","summary":"红黑树（Red-Black Tree）是一种自平衡的二叉查找树（Binary Search Tree, BST），由于基于二叉查找树（并不是基于 AVL 树），因此它是有序的。它出现于 1978 年 Leo J. Guibas 和 Robert Sedgewick 的一篇论文。\n红黑树和 AVL 树很像，都是为了让二叉查找树能保持平衡，不会退化成链表，让查找时间复杂度能够稳定在 O(log(n))。\n相比 AVL 树，红黑树牺牲了部分平衡性来，来减少插入 / 删除操作的旋转次数。因此插入性能红黑树会比 AVL 树快，但由于平衡性不如 AVL 树，当拥有相同数量的节点时，树的层数可能会比 AVL 树高，查询效率也不如 AVL 树。\n由于红黑树的结构比较复杂，因此它也比较难理解，但我们可以借助 2-3-4 树来理解它。\nPerfect Balance 的 2-3-4 树 介绍 2-3-4 树的资料可能比较少，由于 2-3-4 树的图画起来比较麻烦，为了偷懒本文选取了 Sedgewick 介绍 LLRB Tree（左倾红黑树） 的 PPT 中的一些图来做说明，该 PPT 链接放在本文末尾参考部分。\n2-3-4 树也是一颗自平衡的树，但它的节点比较特殊，可以分为以下 3 种节点：\n2-node：普通的树节点，可存放一个数据，最多有两个子节点 3-node：能存放两个数据的节点，最多能有三个子节点 4-node：能存放三个数据的节点，最多能有四个子节点 它们的结构图示如下（该图来自 Sedgewick 的 PPT 第 12 页）：\n该图中对子节点的连接位置进行描述的只有 3 节点，不过 4 节点与子节点连接方式其实也是一样的，子节点的连接决定于子节点存放的数据的大小范围和父节点的存放的数据的大小。","title":"基于 2-3-4 树理解红黑树的性质与操作"},{"content":"在 Java Collections Framework 中有两个被遗弃的 List 实现类 —— Vector 和 Stack。\nVector 通过实现 AbstractList\u0026lt;E\u0026gt; 接口来成为 Java Collections Framework List 接口的一员，而 Stack 直接继承于 Vector。\npublic class Vector\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable public class Stack\u0026lt;E\u0026gt; extends Vector\u0026lt;E\u0026gt; 与 ArrayList 类似的 Vector 如果希望了解 ArrayList 的底层结构可阅读另一篇文章 ArrayList 与 LinkedList 底层结构\n与 ArrayList 一样，Vector 的底层结构也是 Object 数组 elementData，通过 elementCount 来表示 Vector 存储的元素个数，但与 ArrayList 不同的是，ArrayList 创建时不指定容器个数时，elementData 是一个长度为 0 的数组，只有在第一次添加元素的时候才会创建一个长度为 10 的数组，而 Vector 则是在构造方法中调用另一个构造方法直接为 elementData 创建一个长度为 10 的数组。\nprotected Object[] elementData; protected int elementCount; protected int capacityIncrement; public Vector() { this(10); } public Vector(int initialCapacity) { this(initialCapacity, 0); } public Vector(int initialCapacity, int capacityIncrement) { super(); if (initialCapacity \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; } 最终为 elementData 创建数组对象的构造函数为 Vector(int initialCapacity, int capacityIncrement)，这里传入的第二个参数是容量增值，当我们不直接调用该构造方法去指定它的值时，默认为 0。\nVector 也有与 ArrayList 类似的扩容机制来增加 elementData 的容量，但 Vector 扩容时增加的大小与 ArrayList 不同，它所增加的大小与 Vector 中的容量增值 capacityIncrement 与当前容量有关。\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement \u0026gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } 当我们创建 Vector 指定了 capacityIncrement 的值时（capacityIncrement \u0026gt; 0），将会直接以该值作为容量的增加值，否则直接使用当前 elementData 的大小作为容量增值，相当于新容量为旧容量的两倍，因此 Vector 每一次扩容容量的增幅比 ArrayList 的增幅要大。\npublic synchronized void ensureCapacity(int minCapacity) { if (minCapacity \u0026gt; 0) { modCount++; ensureCapacityHelper(minCapacity); } } 对于 Vector，其对外提供的方法都是同步的，因此我们可以说 Vector 是线程安全的。Vector 中的同步方法可以调用 ensureCapacityHelper 不产生额外的同步成本来确保容量。但也可能有需要外部进行容量确认的情况，因此在 Vector 中提供了同步的 ensureCapacity 方法来间接执行 ensureCapacityHelper 方法。\n通过 Vector 实现的 Stack Stack 在 List 接口中算一个特别的类型，它在数据结构上代表的是 last-in-first-out (LIFO) 的栈结构。\n由于 Vector 提供了一系列元素的操作方法，Stack 元素的进出操作的实现基本上都是使用父类 Vector 的方法来完成，因此 Stack 的源码相比其它 Collection 十分简短。..\n因为需要确认每个元素的进出顺序，因此 Stack 只提供了一个无参构造方法来获得一个空栈。\nStack 提供了栈操作的 3 个基本操作，入栈、出栈、查看栈顶元素。\n// 源码就长这个样子... public E push(E item) { addElement(item); return item; } public synchronized E pop() { E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; } public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); } 由于 Vector 底层是一个 Object 数组，因此入栈的元素会被添加到末尾，栈顶元素为数组最后一个元素，栈底元素为数组第一个元素。\n因此 Stack 入栈操作调用了 Vector 的 addElement(E obj) 方法（该方法与 add(E e) 方法作用一致，add 方法为 List 接口的一部分）来添加元素。\n相应的，出栈调用 peek() 来获取栈顶元素，之后通过 removeElementAt(int index) 来移除栈顶元素，再将 peek() 获取到的元素放回。当栈为空时会抛出异常 EmptyStackException。\n被遗弃 Vector 与 Java Collections Framework 中的新成员相比，它的 public 方法都使用了 synchronized 关键字修饰，也就是说相比其它 Collection 类，它的效率比较低，因此在不需要同步的场景，JDK 更加推荐使用 ArrayList，当有多个线程修改 ArrayList 时，我们可以在同步代码块中完成操作，或者通过 Collections 工具类提供的方法来生成一个同步的 List。\nList list = Collections.synchronizedList(new ArrayList(...)); 对于 Stack 由于继承与 Vector，因此它也产生了额外的同步成本，Java Collections Framework 的 Deque 接口提供了更加完整、更一致的 LIFO 操作的栈操作，因此 JDK 推荐优先使用 Deque 接口以及它的实现类。例如：\nDeque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;Integer\u0026gt;(); 参考 JDK 1.8 源码\nhttps://docs.oracle.com/javase/8/docs/api/java/util/List.html\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Vector.html\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Stack.html\n","permalink":"http://answerkobe.github.io/posts/vector-and-stack/","summary":"在 Java Collections Framework 中有两个被遗弃的 List 实现类 —— Vector 和 Stack。\nVector 通过实现 AbstractList\u0026lt;E\u0026gt; 接口来成为 Java Collections Framework List 接口的一员，而 Stack 直接继承于 Vector。\npublic class Vector\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable public class Stack\u0026lt;E\u0026gt; extends Vector\u0026lt;E\u0026gt; 与 ArrayList 类似的 Vector 如果希望了解 ArrayList 的底层结构可阅读另一篇文章 ArrayList 与 LinkedList 底层结构\n与 ArrayList 一样，Vector 的底层结构也是 Object 数组 elementData，通过 elementCount 来表示 Vector 存储的元素个数，但与 ArrayList 不同的是，ArrayList 创建时不指定容器个数时，elementData 是一个长度为 0 的数组，只有在第一次添加元素的时候才会创建一个长度为 10 的数组，而 Vector 则是在构造方法中调用另一个构造方法直接为 elementData 创建一个长度为 10 的数组。","title":"被遗弃的 Vector 和 Stack"},{"content":"在 Java 中，数组可用来存储相同类型的多个数据，但由于长度不可变，在某些场景下使用比较局限。当我们希望使用类似数组的结构来存储未知个数的元素时，可以使用 ArrayList\u0026lt;E\u0026gt; 和 LinkedList\u0026lt;E\u0026gt;，它们都是 Java Collection Framework 的成员，相比普通的数组，它们提供了更多的操作来方便我们开发。由于底层使用的数据结构不同，它们也经常被拿来做比较。\n继承关系 ArrayList 属于 List\u0026lt;E\u0026gt; 接口中的一个 可变长数组 实现，直接 extends AbstractList\u0026lt;E\u0026gt; abstract 类。其继承关系如下：\npublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable LinkedList 直接 extends AbstractSequentialList\u0026lt;E\u0026gt; abstract 类，间接 extends AbstractList\u0026lt;E\u0026gt;，由于 LinkedList 也实现了 Deque\u0026lt;E\u0026gt; 接口，所以它属于 List\u0026lt;E\u0026gt; 和 Queue\u0026lt;E\u0026gt; 接口的实现。\npublic class LinkedList\u0026lt;E\u0026gt; extends AbstractSequentialList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable ArrayList 底层结构 对于 ArrayList，Java API 对它的第一句描述为 “Resizable-array implementation of the List interface”。其底层存储元素的结构为 Object 数组。\nprivate static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; ArrayList 存储元素的数组对象变量名为 elementData，在使用 new ArrayList() 创建对象时使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA（一个长度为 0 的数组）来对 elementData 进行初始化。\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } ArrayList 有一个构造方法 ArrayList(int initialCapacity) 让我们传入一个 int 类型的参数，这可以让我们在创建 ArrayList 对象时对 elementData 进行自定义的初始化，ArrayList 会将传入的 initialCapacity 参数来作为初始化 elementData 的长度。当 initialCapacity 是 0 时，使用 EMPTY_ELEMENTDATA 以一个长度为 0 的数组来初始化 elementData。\nprivate static final Object[] EMPTY_ELEMENTDATA = {}; public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } 可变长原理 ArrayList 使用数组来存储元素，而数组长度是固定的，添加的元素数量可能会超过数组容量，并且如果我们创建 ArrayList 对象时不指定 initialCapacity 或指定为 0 的话，那么 elementData 的长度是 0，无法放入元素。因此如果希望 ArrayList 是可变长的，需要有一个扩容机制。\n在 ArrayList 中，每次添加元素都会先调用 ensureCapacityInternal(int minCapacity) 方法，之后才会进行添加操作，只要完成了添加操作，add(E e) 方法总是会返回 true 来表示添加成功。那么关键的代码就在于 ensureCapacityInternal 这个方法做了哪些操作。\npublic boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } private static final int DEFAULT_CAPACITY = 10; private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } ensureCapacityInternal 方法传入的参数 minCapacity 为进行添加操作时 elementData 所需的最小容量，方法内可以分为两步操作：\n第一步调用 calculateCapacity(Object[] elementData, int minCapacity) 来计算 elementData 所需容量。\n当 elementData 为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，代表 elementData 需要进行初始化扩容。ArrayList 中有一个默认的数组初始化容量大小 DEFAULT_CAPACITY = 10，ArrayList 添加第一个元素时，以该值作为数组长度进行初始化扩容。 由于 ArrayList 中有 addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 方法来添加多个元素，添加的元素个数可能比 DEFAULT_CAPACITY 的值要大，因此需要比较 minCapacity 与 DEFAULT_CAPACITY 的大小，取大的一个作为 elementData 所需容量进行返回。 当 elementData 已经进行过初始化扩容时，直接将 minCapacity 作为所需容量返回。 第二步调用 ensureExplicitCapacity(int minCapacity) 方法根据所需容量大小来判断是否需要进行扩容，如果所需容量大于当前 elementData 的容量，则调用 grow(int minCapacity) 方法进行扩容操作。\n扩容方式 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } grow 方法中扩容方式为使用 Arrays.copyOf(T[] original, int newLength) 方法来生成一个包含原数组元素的新数组，而新数组容量 newCapacity 取决于 oldCapacity（原本 elementData 的容量），在原本 elementData 的容量上增加一半，这个操作通过对 oldCapacity 进行右移完成。\n当得到的 newCapacity 比所需的最小容量小时，将会直接使用 minCapacity 作为 newCapacity 的值。\n当 elementData 为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，代表原本长度为 0，则 newCapacity 的值也为 0，那么 newCapacity - minCapacity 将会小于 0，此时新数组容量将会变成 minCapacity，也就是 DEFAULT_CAPACITY，从而初步扩容出一个容量为 10 的 elementData。\n最大容量 ArrayList 存放元素的结构为数组，因此 ArrayList 的最大容量也取决于数组的最大容量。\n在 ArrayList 中使用 MAX_ARRAY_SIZE 来代表数组最大长度，数组的长度定义为非负的 int 类型，因此数组的最大长度为 int 类型的最大值。由于在一些虚拟机中，一个数组还包括头部等内容，因此最大长度可能会比 int 的最大值要小，所以 ArrayList 的 MAX_ARRAY_SIZE 的值为 Integer.MAX_VALUE - 8；\n当通过计算得出的 newCapacity 大小比 MAX_ARRAY_SIZE 大时，将会调用 hugeCapacity(int minCapacity) 来尝试获取数组的可能的最大值来作为 newCapacity 的值。\n当 minCapacity 的值为负数时，代表所需最小容量超过了 int 类型最大值，发生了溢出，此时将会在 hugeCapacity 方法内主动抛出 OutOfMemoryError。如果不为负数时，当 minCapacity 比 MAX_ARRAY_SIZE 大的话，则尝试使用 Integer.MAX_VALUE 来作为容量大小，否则使用 MAX_ARRAY_SIZE。\nLinkedList 链表结构 LinkedList 的底层使用的结构是双向 Node 链表，在 LinkedList 中有 first 和 last 两个变量，分别指向链表的第一个节点和最后一个节点，默认为 null，并用 size 来存储链表的长度。Node 节点创建时，必须传入节点值和前后节点，因此 Node 类中没有无参构造方法。\ntransient int size = 0; transient Node\u0026lt;E\u0026gt; first; transient Node\u0026lt;E\u0026gt; last; private static class Node\u0026lt;E\u0026gt; { E item; Node\u0026lt;E\u0026gt; next; Node\u0026lt;E\u0026gt; prev; Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; this.next = next; this.prev = prev; } } 头尾操作 private void linkFirst(E e) { final Node\u0026lt;E\u0026gt; f = first; final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; } void linkLast(E e) { final Node\u0026lt;E\u0026gt; l = last; final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } LinkedList 中使用 linkFirst 和 linkLast 来将节点添加到首部和尾部，当我们使用添加方法来添加节点时，都是使用这几个方法完成。\npublic boolean add(E e) { linkLast(e); return true; } public void addFirst(E e) { linkFirst(e); } public void addLast(E e) { linkLast(e); } 此外还有一个 linkBefore 来将节点插入到指定位置，但它并不是总被调用，当添加的位置刚好在链表末尾时，则使用 linkLast 来完成插入操作。\nvoid linkBefore(E e, Node\u0026lt;E\u0026gt; succ) { // assert succ != null; final Node\u0026lt;E\u0026gt; pred = succ.prev; final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); } 作为队列使用 由于实现了 Deque\u0026lt;E\u0026gt; 接口，LinkedList 也可以作为队列来使用，我们可以同时使用 Queue 的方法来操作元素。但当一个 LinkedList 具有特定的含义并明确为一个队列时，应当声明为 Deque 类型，避免使用链表操作干扰队列正常的进出流程。\nclass E { /* Deque Element Type */ } Deque\u0026lt;E\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); 区别和使用场景 ArrayList 由于其底层结构为数组这一特点，在使用 get 通过获取元素时，可以通过下标直接映射到相对应的元素，随机访问时所需时间复杂度为 O(1)。但在插入时，需要对插入位置和后面的元素进行移动，在 ArrayList 的 size 比较大时，这可能需要花费较多的时间。\npublic void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 在 ArrayList 中，这一操作使用 System.arraycopy() 来对需要移动的元素进行复制，从而提高元素移动操作的效率，但每次添加或插入元素时，不可避免地需要调用 ensureCapacityInternal 来判断所需容量是否足够，当不充足时需要进行扩容操作。\nArrayList 使用数组来存储元素，在扩容时会出现没有使用的空间，造成空间浪费，在数据量越大的情况下，造成的空间浪费可能会越大。\nLinkedList 底层的数据结构为链表，每次查询元素时，需要移动指针来查找对应元素，随机访问时的时间复杂度为 O(n)，要比 ArrayList 慢的多，但在顺序访问的情况下，两者并没有太大区别。而插入时只需要修改前后节点指向，不需要直接移动链表中的元素，效率比 ArrayList 要高。\n由于链表需要为每一个节点创建一个 Node 对象，来存储数据的引用和前后节点的引用，因此每一个节点所占用的内存会比 ArrayList 一个元素占用的多。大部分情况下，或在不考虑 ArrayList 空间浪费的情况下，LinkedList 的开销会比 ArrayList 大。\n因此，ArrayList 更适合于简单的存储、随机访问对应位置数据的场景，如果需要频繁对容器的元素进行增删操作，那么可以使用 LinkedList 来提高代码的性能。\n参考 JDK 1.8 源码 与 Java API 文档：\nhttps://docs.oracle.com/javase/8/docs/api/java/util/List.html\nhttps://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html\nhttps://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html\n","permalink":"http://answerkobe.github.io/posts/arraylist-and-linkedlist-principle/","summary":"在 Java 中，数组可用来存储相同类型的多个数据，但由于长度不可变，在某些场景下使用比较局限。当我们希望使用类似数组的结构来存储未知个数的元素时，可以使用 ArrayList\u0026lt;E\u0026gt; 和 LinkedList\u0026lt;E\u0026gt;，它们都是 Java Collection Framework 的成员，相比普通的数组，它们提供了更多的操作来方便我们开发。由于底层使用的数据结构不同，它们也经常被拿来做比较。\n继承关系 ArrayList 属于 List\u0026lt;E\u0026gt; 接口中的一个 可变长数组 实现，直接 extends AbstractList\u0026lt;E\u0026gt; abstract 类。其继承关系如下：\npublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable LinkedList 直接 extends AbstractSequentialList\u0026lt;E\u0026gt; abstract 类，间接 extends AbstractList\u0026lt;E\u0026gt;，由于 LinkedList 也实现了 Deque\u0026lt;E\u0026gt; 接口，所以它属于 List\u0026lt;E\u0026gt; 和 Queue\u0026lt;E\u0026gt; 接口的实现。\npublic class LinkedList\u0026lt;E\u0026gt; extends AbstractSequentialList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable ArrayList 底层结构 对于 ArrayList，Java API 对它的第一句描述为 “Resizable-array implementation of the List interface”。其底层存储元素的结构为 Object 数组。","title":"ArrayList 与 LinkedList 底层结构"},{"content":"字节码（Byte Code） 学习 Java 的都知道，我们所编写的 .java 代码文件通过编译将会生成 .class 文件，最初的方式就是通过 JDK 的 javac 指令来编译，再通过 java 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。\n对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。\n字节码文件结构 public class Hello { public static void main(String[] args) { int a = 1; int b = 1; int c = add(a, b); System.out.println(c); } public static int add(int a, int b) { return a + b; } } 首先我们先编写一个简单的 Java 代码作为演示例子，然后编译这个 Hello.java 文件得到 Hello.class 文件。我们知道 .class 是二进制文件，它无法被直接查看，当然我们可以通过一些二进制文件查看工具来阅读里面的内容。\n一个符合标准的 .class 文件是以 CA FE BA BE 开头，这个四个字节均为魔数，JVM 根据这个开头来判断一个文件是否可能为 .class 文件，如果是才会继续执行。\n魔数后面四个字节 00 00 00 34 是版本号，前两个字节为次版本号，后两个字节为主版本号，在对主版本号进行转换可以得到 52，该序号对应的 Java 版本为 1.8。\n如果需要查阅最新的 Java 版本对应的版本号，可以在官方查看 Java SE 最新版本的文档\nOracle Java SE Specifications：https://docs.oracle.com/javase/specs/index.html\n在版本号后面则是常量池，它包含常量池计数器（constant_pool_count）和常量池数据区两个部分。前面两个字节 00 28 是计数器，用于表示常量池的容量计数值，代表常量池数据区有 constant_pool_count - 1 个常量。\n在常量池后面还有访问标志，很显然这个文件对于我们来说阅读起来并不方便，但是我们可以转换为助记符来帮助我们阅读。\n使用 javap 命令 当我们拥有一个 .class 文件时，我们可以通过 javap 来将字节码指令转换为助记符，这个命令有一些参数，你可以通过 javap -help 来查看所有参数的说明，这里为了显示尽量详细的内容，使用 javap -verbose Hello，其效果如下，但由于内容太长，我们不一次性展示所有内容，而是分区域来进行阅读。\nClassfile /F:/project/java/JavaMain/out/production/JavaMain/Hello.class Last modified 2021-3-26; size 645 bytes MD5 checksum ca1b2193159aece89c05c7f9d3b54c7b Compiled from \u0026#34;Hello.java\u0026#34; public class Hello minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER 最开始几行是关于这个文件的基本信息，之后是类的信息，我们的关注点从类这里开始。\n在类里面，它包含了主版本号（major version），次版本号（minor version），访问标志（flags）。\n对于版本号，和我们上面所讲的一样，因此这里不再重复。而 flags 是关于这个类的相关修饰符，根据官方文档，它可能拥有的值如下：\n常量池 在类信息的下面，则是常量池，它类似一个表，每个常量由编号、类型、值，这 3 个部分组成。我们列出一小部分来了解它的结构。\nConstant pool: #1 = Methodref #6.#26 // java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #2 = Methodref #5.#27 // Hello.add:(II)I #3 = Fieldref #28.#29 // java/lang/System.out:Ljava/io/PrintStream; #4 = Methodref #30.#31 // java/io/PrintStream.println:(I)V #5 = Class #32 // Hello #6 = Class #33 // java/lang/Object #7 = Utf8 \u0026lt;init\u0026gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 LHello; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V 在这里列出了前 15 个常量，每个常量都有一个编号，编号以符号 # 开头，编号后面是 = 加上该常量的类型，具体类型说明请参考官方 jvms 文档的 The Constant Pool 的解释。这里我们从中挑选几个常量来进行说明。\n由于我们使用的命令是 javap -verbose 因此它会给我们加上一些注释说明，我们可以看到 #2 常量后面的注释是 Hello.add:(II)I，那么我们可以猜测它应该是我们代码中所编写的 add() 方法，由于这个方法是静态，因此它被加入到这个类中的常量区。那么这个常量的值呢？\n对于 Methodref 类型，它的值是该方法的名称，对于一个方法而言，它的名称是一个字符串，因此构成方法名称的字符串也会被添加到常量池中，#2 这个方法，它的名称引用了常量池中其它的两个常量，也就是 #5 和 #27，而这两个常量以及与它们相关的其它常量在常量池中的值如下：\n#2 = Methodref #5.#27 // Hello.add:(II)I #5 = Class #32 // Hello #22 = Utf8 add #23 = Utf8 (II)I #27 = NameAndType #22:#23 // add:(II)I #32 = Utf8 Hello 在常量池中我们可以看到，#5 是一个类，它的值和方法一样都是名称，因此它引用了常量 #32，对于 Utf8 类型的常量，其值则是一个字符串，也就是常量 #32 的值就是字符串 Hello。因此 #5 的值就是 Hello。同样的 #27 的值是 add:(II)I，将它们组合起来 #2 的值就是 Hello.add:(II)I 了。\n包含的方法 与 Java 代码一样，我们所定义的方法在类里面，而在字节码中我们定义在类中的方法也放在大括号里面，而这个大括号就在常量池下方。\n对于每个方法，都包含首行的声明，以及紧接在后面的 descriptor（描述符号），flags（访问标识），Code（代码），我们把 Code 部分的内容先省略，先看一下类中所拥有的所有方法。\n{ public Hello(); descriptor: ()V flags: ACC_PUBLIC Code: // 省略 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: // 省略 public static int add(int, int); descriptor: (II)I flags: ACC_PUBLIC, ACC_STATIC Code: // 省略 } 可以看到，我们并没有给类写构造方法，但这里却生成了 public Hello();，这也说明了为什么我们在 Java 中不给类写构造方法，默认会有一个无参的构造方法。\n另外我们可以看到到 add(int, int) 方法的 descriptor 为 (II)I，这与我们上面观察常量池时 Hello.add:(II)I 冒号后面带的字符是一样的，这其实是这个方法的参数以及返回值的缩写。当我们在 Java 中编写重载方法时，由于方法名一样，JVM 可以通过 descriptor 来区分所调用的方法是哪一个。\n而 flags 与 Class 的 flags 类似，用于声明方法所拥有的修饰符。而最后的 Code 中包含的则是该方法的代码所执行的指令。\nCode 的结构 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: iconst_1 1: istore_1 2: iconst_1 3: istore_2 4: iload_1 5: iload_2 6: invokestatic #2 // Method add:(II)I 9: istore_3 10: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 13: iload_3 14: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 3: 0 line 4: 2 line 5: 4 line 6: 10 line 7: 17 LocalVariableTable: Start Length Slot Name Signature 0 18 0 args [Ljava/lang/String; 2 16 1 a I 4 14 2 b I 10 8 3 c I 以 main 方法为例子，在 Code 中可以分为 3 个部分，第一个部分是代码的指令表，该部分第一行是该方法的指令以及执行过程的相关信息，这一行信息包括：\nargs_size 是参数数量，在主函数中，因为有 args 这个参数，所以在这里 args_size 为 1； locals 是该方法中的本地变量有多少个，在我们的主函数里面有定义了 3 个变量，加上一个参数，因此有 4 个变量； stack 是方法在执行过程中，操作数栈中最大深度，这个在之后讲解指令执行过程时可以看出。 在这一行信息之后是字节码指令，一条指令包括偏移量以及执行的指令码，PC Register 利用偏移量来判断指令执行位置。\n第二部分是 LineNumberTable，它是一个代码行对照表，用于标识我们 Java 代码中对应的行数的代码在 Code 中从哪个位置开始。\nLineNumberTable: line 3: 0 line 4: 2 line 5: 4 line 6: 10 line 7: 17 line 3: 0 代表 Java 源码文件中的第三行代码从偏移量为 0 的位置开始，而继续往下看可以看到第四行代码从偏移量为 2 的位置开始，也就是说第三行代码所对应的字节码指令有 iconst_1 和 istore_1 两条。这也可以让 JVM 执行指令出现错误时，帮助我们定位到对应的源码位置。\n第三部分为 LocalVariableTable，调试器可以使用它在方法执行的过程中确定局部变量的值，它是一个可选的属性，在程序执行的时候并不需要它。\n第一个属性 start 为这个变量可见的起始偏移位置，它的值必须是在 Code 中存在的偏移量值。 第二个属性 length 为该变量的有效长度，在这个例子中，我们的变量直到方法末尾都有效，因此你会发现 start + lenth 的值都是 18 （方法中执行的指令数）。当我们在一个局部的代码块里面声明一个变量，那么它的有效期长度将会更短。 Slot 为变量在 local variable 中的位置，这可以帮助我们在指令中确定对应的变量，而 Name 则是变量名，Signature 为该变量的类型。 当我们初步了解了 Code 属性的格式后，我们就可以对其中的指令执行进行分析了，但在此之前，我们需要先有一点 JVM 内存布局的基础知识，这对于我们之后了解指令的执行过程非常重要。\nJVM 内存结构 我们的 Java 程序在运行时是通过 main() 方法启动，它是程序的入口，我们的进程在启动时会为该方法创建一个主线程来执行代码。当我们使用多线程时，那么程序的进程将会拥有多个线程。每个线程的资源都拥有独自的资源，当然它们也可以共享进程的资源，那么在 JVM 中，根据资源的可用范围，可将内存区域分为线程独占和线程共享两个类别。\n对于每一个线程，都可将其拥有的内存空间分为 PC Register、Native Method Stack、JVM Stack 这 3 个区域，这 3 个区域对于线程来说都是独占的，其它线程无法进行访问。\nPC Register 用于记录当前线程指令的执行位置。由于一个进程可能有多个线程，而 CPU 会在不同线程之间切换，为了能够记录各个线程的当前执行的指令，每个线程都需要有一个 PC Register，来保证各个线程都可以进行独立运算。 JVM Stack 用于存放调用方法时压入栈的栈帧。相信学过数据结构的对栈应该不陌生，JVM Stack 压入的单位为栈帧（Frame），用于存储数据、动态链接、方法返回值和调度异常等。每次调用一个方法都会创建一个新的栈帧压入 JVM Stack 来存储该方法的信息，当该方法调用完成时，对应的栈帧也会跟着被销毁。一个栈帧都有自己的局部变量数组、操作数栈、对当前方法类的运行常量池的引用。 Native Method Stack 则是用于调用操作系统本地方法时使用的栈空间。 每个线程都可用访问的内存空间为线程共享区域，它包含 Head 和 Method Area 两个部分，Head 用于存放实例对象，也是 GC 回收的主要区域，而 Method Area 用于存放类结构与静态变量。\n现在我们初步了解了 JVM 内存的布局，那么接下来可以继续看指令的执行过程了。\n指令的执行过程 由于 Java 程序从 main() 方法开始，我们也是从这个方法的指令开始进行分析。\n假设程序运行 0 号指令前的状态如下，在 mian 方法栈帧里面，有着 operand stack（操作数栈），它的最大长度为 2（与 Code 下的 stack 的值一致），此外还有一个 local variable（本地变量表）来存放变量的值，其中下标为 0 的变量为主方法的参数 args，我们直接用这个字符串填充在那里来做一个标识（实际的值可能是一个空数组）。\n接下来我们一步步执行方法中的指令，在这里我们先对出现的几个指令做一个简单的介绍：\niconst_\u0026lt;i\u0026gt; 放一个 int 常量（-1, 0, 1, 2, 3, 4 or 5) 到 operand stack 中 istore_\u0026lt;n\u0026gt; 从 operand stack 中获取一个 int 到 local variable 的 n 中 iload_\u0026lt;n\u0026gt; 从 local variable 中读取 int 变量 n 的值到操作数栈中 invokestatic 调用一个 class 的 static 方法 getstatic 从 class 中获取一个 static 字段 invokevirtual 调用一个实例方法，基于类的调度 return 从方法中返回一个 void，ireturn 从方法中返回 operand stack 栈顶的 int 更多的指令与详细的说明请查看文章最后参考中的官方指令文档\n现在我们开始分析指令的执行，我们在上面知道了，我们的 Java 代码所对应的指令分别是偏移量为 0 和 1 的两个，最开始执行的是 0: iconst_1，该指令会把 int 常量 1 放置到 operand stack 中，之后执行的是 1: istore_1，把 operand stack 栈顶的 int 常量取出放到 local variable 下标为 1 的变量中，该过程图示如下。\n我们可以通过查看 LocalVariableTable 得知下标为 1 的变量在我们的 Java 程序中是 int 变量 a，因此上面这两条指令常量 1 赋值给变量 a。同样的，后面两条指令则是将常量 1 赋值给变量 b。这里要注意，操作数栈的数是被取出操作，被取出的数将不会继续在 operand stack 里面。\n执行完 0~3 这 4 条指令后，就来到了本例中最为关键的方法调用了。在执行 iload_1 和 iload_2 后，operand stack 中将会存放着变量 a 和 b 的值，作为 invokestatic 调用函数时传入的参数。\n而执行到 invokestatic #2 这个指令的时候，该指令为调用一个 class 的 static 方法，也就是调用常量池中 #2 的方法，该方法为 Hello.add:(II)I。\n当执行 invokestatic 时会依次读取 operand stack 的数据作为方法的参数，并创建一个新的栈帧来执行方法，将数据放到 local variable 对应变量位置。\n之后开始执行 add() 方法中的指令，首先执行的是两个 iload 指令，将 loca variable 对应下标的变量的值放到 operand stack 中，之后执行 iadd 取出 operand stack 中的值并进行加法运算，再把结果放到，最后执行 ireturn 取出 operand stack 顶部的 int 值进行返回。\n当执行完 ireturn 后，add 方法也就执行完成了，对应的栈帧也会跟着销毁。之后回到 main 方法中继续往下执行，到 istore_3 指令，该指令将栈顶的 int 值取出放到了 local variable 中 Solt 为 3 的地方，这样执行完 4~9 这几条指令后就完成了我们代码中的 int c = add(a, b); 这一行代码。那么接下来就是执行 System.out.println(c); 对应的指令将 2 打印到控制台了。\n到这里其实我们就已经知道如何去阅读我们代码生成的 Byte Code 了，这里我就不继续往下分析本文例子的代码了，阅读过程中如果遇到了没见过的指令，我们可以在 Oracle 官方指令文档里面查阅对应的说明。\n那可能有人会觉得，如果每次查看一个类都需要去 command line 执行 javap 来查看对应的助记符，这样非常麻烦呀。那么接下来我们讲一下如何在 IntelliJ IDEA 里面直接阅读 Byte Code。\n在 IntelliJ IDEA 阅读 如果你希望在 IntelliJ IDEA 里阅读 Byte Code，那么可以按照 Bytecode Viewer 这一个插件，只需要在 Plugins 里面查找就能找到。\n安装完这个插件，在顶部菜单栏的 View 中将会多出一个 Show Bytecode 按钮选项，我们可以在对应的 .java 文件中点击 View -\u0026gt; Show Bytecode，展示出该文件的 Byte Code。\n在这里所展示的 Byte Code 格式与我们上面使用 javap 显示出来的不一样。首先在这里我们看不到常量池，因此在指令里也不会用引用的方式来表示常量池的内容。\n在这里它会将每一行 Java 代码的指令都区分开。例如 main 方法中的第一行指令对应的就是 L0 那一块，第一行的 LINENUMBER 对应上面 javap 中的 LineNumberTable，直接在这里描述当前 L0 这一块的指令对应的代码在文件中的位置。也因此我们不会在生成的这个 Byte Code 里面看到 LineNumberTable，因为它直接分布在各个指令块中了。\n在方法的最后，会多出一块内容来描述方法的信息，在这里会将 LocalVariableTable 里的变量都列出来，但格式与 javap 的 LocalVariableTable 中的描述格式不一样，每一行 LOCALVARIABLE 代表一个变量，描述格式从左到右依次为变量名、类型、开始可见时的指令块、最后有效的位置、Solt。除了描述方法中出现的变量外，操作数栈最大深度和本地变量个数也在放在这里。\n由于该插件主要是为了阅读 Byte Code 中的指令，因此是以一种更加方便阅读指令的方式展示 Byte Code，例如对指令根据源码做分块，并把对应代码行数放在指令块的第一行，这样我们就不需要去对照 LineNumberTable 寻找当前指令的代码所在的位置了，反过来由于进行了分块查询对应代码的指令也很方便。但这个插件显示的内容也少了很多东西，如果需要查看初始常量池的内容，那就需要使用 javap 了。\n参考 字节码增强技术探索：https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html\n一文看懂 JVM 内存布局及 GC 原理：https://www.infoq.cn/article/3wyretkqrhivtw4frmr3\nOracle 官方说明文档：https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jvms-4.10\nOracle 官方指令文档：https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html\n","permalink":"http://answerkobe.github.io/posts/how-to-read-java-byte-code/","summary":"字节码（Byte Code） 学习 Java 的都知道，我们所编写的 .java 代码文件通过编译将会生成 .class 文件，最初的方式就是通过 JDK 的 javac 指令来编译，再通过 java 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。\n对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。\n字节码文件结构 public class Hello { public static void main(String[] args) { int a = 1; int b = 1; int c = add(a, b); System.","title":"如何阅读 Java 字节码（Byte Code）"}]