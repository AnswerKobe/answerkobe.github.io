<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.121.0"><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="upgrade-insecure-requests"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Iverson's blog</title>
<meta name=description content="Iverson's blog"><meta name=author content><link rel=canonical href=http://answerkobe.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.81e9c84b86321fe9cfdf9f01a2f8060920d09e0fec45cb91f131cfed0284007e.css integrity="sha256-genIS4YyH+nP358BovgGCSDQng/sRcuR8THP7QKEAH4=" rel="preload stylesheet" as=style><link rel=icon href=http://answerkobe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://answerkobe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://answerkobe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://answerkobe.github.io/apple-touch-icon.png><link rel=mask-icon href=http://answerkobe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://answerkobe.github.io/index.xml><link rel=alternate type=application/json href=http://answerkobe.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4112QEXZJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4112QEXZJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Iverson's blog"><meta property="og:description" content="Iverson's blog"><meta property="og:type" content="website"><meta property="og:url" content="http://answerkobe.github.io/"><meta property="og:site_name" content="Iverson"><meta name=twitter:card content="summary"><meta name=twitter:title content="Iverson's blog"><meta name=twitter:description content="Iverson's blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Iverson's blog","url":"http://answerkobe.github.io/","description":"Iverson\u0026#39;s blog","thumbnailUrl":"http://answerkobe.github.io/favicon.ico","sameAs":["https://github.com/answerkobe"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://answerkobe.github.io/ accesskey=h title="Iverson's blog (Alt + H)">Iverson's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://answerkobe.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=http://answerkobe.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=http://answerkobe.github.io/profile title=Profile-X><span>Profile-X</span></a></li><li><a href=http://answerkobe.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi There 👋 ~I&rsquo;m Iverson.</h1></header><div class=entry-content>Less is More.</div><footer class=entry-footer><div class=social-icons><a href=https://github.com/answerkobe target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2>神经网络基础理论与简单实践</h2></header><div class=entry-content><p>机器学习（Machine Learning, ML） 在了解神经网络之前，我们需要先知道机器学习和神经网络之间的关系。
机器学习是人工智能中的一个分支， 主要研究如何让计算机模拟人类的学习行为来获得知识和技能，在实践上就是通过让泛型算法（Generic Algorithm，和 C/C++ 中的泛型算法不是一个东西）自己在输入的数据上建立逻辑模型，并通过该模型来得到目标结论。
泛型算法能处理的问题取决于我们所定义好的输入/输出的数据格式，而处理问题的条件和逻辑，则由泛型算法通过对输入数据进行分析学习构建处理逻辑参数，构建后的逻辑也能适应非预设数据的处理。神经网络属于机器学习泛型算法中的一种实现方案。
根据泛型算法的学习方式，也可以将机器学习分为监督式学习、弱监督学习、半监督学习、非监督式学习、迁移学习、强化学习等。 人工智能中许多维度的分类都存在交叉关系，因此通常不会为任何一个方法论进行确切的归类。 神经网络结构 【概念】机器学习中的神经网络模型是一种模仿生物神经网络结构和功能的模型，因此也被称为人工神经网络或类神经网络。人工神经网络由多个人工神经元（处理单元）以及传递信号的链接形成拓扑结构，由于泛型算法能处理的问题取决于输入/输出的数据格式，因此神经网络基本会分为3个层：
Input Layer：输入层，用于接收外界数据，节点数量根据输入的数据类型决定 Hidden Layer：隐含层，负责对输入层提供的数据进行信息处理、信息转化，通常这一层会有多个层次，每层会将处理结果向后面传递。 Output Layer：输出层，将隐含层提供的输出信息转化层最终结果，节点数量根据输出的结构类型决定 【生物知识点复习】生物神经元通常具有多个树突，树突用于接收信号，接收的信号在细胞体内整合产生阶梯性生电，而轴突用于传递信号，当细胞体的电位影响达到一定的阈值，则代表这个神经元被激活，激活的神经元会产生神经冲动（电脉冲），通过轴突传导出去，轴突尾端有许多和其他神经元树突产生连接的突触，电信号会通过这些突触传递给其他神经元，突触在一次突触事件中产生的电位幅度与突触的强度有关。
人工神经元也是模拟生物神经元的结构和特性，下面是一个典型的人工神经元结构，以及人工神经元和生物神经元中各个行为的对照表。
生物神经元 人工神经元 输入，即上一个神经元轴突传递过来的电信号 x𝑖 也就是下一个神经元的输出 y 突触强度 w𝑗 权重 树突接收到的电信号 x𝑖 * w𝑗 信号积累，阶段性生电 ∑(x𝑖 * w𝑗) 神经元激活 𝑓(·) 激活函数 轴突电信号传递 y 也就是下一个神经元的输入 x𝑖 线性回归 从上面的对照表可以看出，一个神经元对上一层的输入处理其实就是将各个输入值加权求和，本质上就是一个线性回归 𝑓(𝑥;𝑤) = 𝑤1𝑥1 + 𝑤2𝑥2 + ⋯ + 𝑤D𝑥D + 𝚋。线性回归模型是机器学习中最基础最广泛的模型，主要用于分析自变量和因变量之间的关系。 为什么使用的是线性回归呢？ 线性回归可以用来描述自变量和因变量之间的关系，机器学习中大部分问题都是分析数据里特征的关系来建立模型，因此在机器学习中很多问题都可以转换为线性回归问题来处理。 例如我们有如下左图关于面积和房价关系的数据，那么可以用一个一元线性回归模型来拟合这些数据，从而得到一个可以根据面积来预估房价的模型。当房屋特征变多时，也可以根据回归函数的参数建立一个没有 Hidden Layer 的神经网络。
面积和房价的线性拟合 多个房屋特征的神经网络 有时候特征向量与因变量并不是简单的线性关系，例如我们给的不是面积，而是房子的长宽，那么将会存在特征之间相乘的计算逻辑。或者有时候特征向量之间可能也存在关系，例如加上时间维度来预测未来的房价，那么其他特征带来的效果可能会跟着时间变化发生变化。如果我们在各个线性回归的关系上再次建立回归模型，那么工作量和计算量将会特别高，但多层的神经网络来处理这个问题就非常方便。
神经网络本身是由许多节点组成的，每个节点的输入输出都可以认为是一次线性转化，因此可以认为神经网络会将问题分为多个子问题来处理，不同纬度的问题会被分到各个层级，同一纬度的子问题会被分到各个神经元。每个神经元利用线性回归来对输入数据的特征进行线性转换（这个过程也称为特征提取），将子问题分析结果反馈给下一层级（父问题）继续处理。
没有 Hidden Layer 的神经网络只能用于表示线性回归函数，但多层的网络则可以在线性回归上建立更高纬度的模型。下面是 The Number of Hidden Layers 中总结的常见层数体系结构的功能：...</p></div><footer class=entry-footer><span title='2023-04-13 00:00:00 +0000 UTC'>April 13, 2023</span></footer><a class=entry-link aria-label="post link to 神经网络基础理论与简单实践" href=http://answerkobe.github.io/posts/basic-theory-and-simple-practice-of-neural-network/></a></article><article class=post-entry><header class=entry-header><h2>Java设计模式</h2></header><div class=entry-content><p>黑马设计模式精讲 1，设计模式概述 1.1 软件设计模式的产生背景 “设计模式"最初并不是出现在软件设计中，而是被用于建筑领域的设计中。
1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。
1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。
1.2 软件设计模式的概念 软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。
1.3 学习设计模式的必要性 设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。
正确使用设计模式具有以下优点。
可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 1.4 设计模式分类 创建型模式
用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
结构型模式
用于描述如何将类或对象按某种布局组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
行为型模式
用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。
2，UML图 统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。
UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。
2.1 类图概述 类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。
2.2 类图的作用 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解； 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。 2.3 类图表示法 2.3.1 类的表示方式 在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。...</p></div><footer class=entry-footer><span title='2023-02-10 00:00:00 +0000 UTC'>February 10, 2023</span></footer><a class=entry-link aria-label="post link to Java设计模式" href=http://answerkobe.github.io/posts/design-pattern/></a></article><article class=post-entry><header class=entry-header><h2>Jetpack Compose 探索</h2></header><div class=entry-content><p>Why compose Compose UI 的编写只需要 Kotlin，在遵循 Android 应用架构时，这样更有利于聚合 UI Elements 的代码，不需要去区分 Kotlin 代码和 xml 布局文件，在我看来这种方式更加容易采用 Android 架构指南去控制项目架构。
但从另一方面来讲，Compose 这种嵌套的 UI 组合方式会加深代码层次，因此开发过程中需要对 UI 上各个元素做更细的区分，以增加代码的可读性。另外如果状态使用没有处理好，也会对 Compose 的重组性能带来影响。
完善的声明式 UI Android View 系统设计的时候是遵循 OOP 的，虽然有 XML 可以帮我们减少下面这种命令式代码的使用，但这种声明式构建 + 命令式执行的缺点还是很明显，因为需要一个加载器把布局转化到业务逻辑代码中。
// 命令式 val parent = ViewGroup(); val node = View(); parent.addView(node); 如果按照理想的声明式 UI 编写方式去改造传统 View 系统，那呈现出的代码可能会包括下面两个特点：
节点的构建不应该有返回值 节点的连接不依赖于 API &lt;LinearLayout> &lt;TextView>Hello World&lt;/TextView> &lt;MaterialButton android:onCLick="syaHi()">hi&lt;/MaterialButton> &lt;/LinearLayout> 将上面的布局代码转换为 Java/Kotlin 理想的声明式代码
LinearLayout { TextView("Hello World") MaterialButton("Hi") { syaHi() } } Compose 利用 Kotlin DSL 构建声明式 UI，一个 @Composable 相当于一个节点，在内部也可以调用其他 @Composable 函数构建子节点。...</p></div><footer class=entry-footer><span title='2022-07-08 00:00:00 +0000 UTC'>July 8, 2022</span></footer><a class=entry-link aria-label="post link to Jetpack Compose 探索" href=http://answerkobe.github.io/posts/jetpack-compose-explore/></a></article><article class=post-entry><header class=entry-header><h2>Flutter 绘制流程分析与代码实践</h2></header><div class=entry-content><p>Render Tree 的创建过程 RenderObject 的类型 我们知道 Element 主要分为负责渲染的 RenderObjectElement 和负责组合的 ComponentElement 两大类，而创建 RenderObject 节点的是前者 mount() 方法中调用的 RenderObjectWidget.createRenderObject() 方法。
该方法是一个抽象方法，需要子类实现，对于不同的布局的 Widget 创建的 RenderObject 类型也不一样，在 Render Tree 中最主要的有两种 RenderObject：
首先是在 RenderObject 注释说明中大量提到了一个类 RenderBox，它是大部分的 RenderObjectWidget 所对应的 RenderObject 的抽象类 /// A render object in a 2D Cartesian coordinate system. /// 一个在 2D 坐标系中的渲染对象 abstract class RenderBox extends RenderObject 以及 Render Tree 的根节点 RenderView /// The root of the render tree. /// Render Tree 的根节点，处理渲染管道的引导和渲染树的输出 /// 它有一个填充整个输出表面的 RenderBox 类型的唯一子节点 class RenderView extends RenderObject with RenderObjectWithChildMixin&lt;RenderBox> 其他的类型的 RenderObject 基本是为了特定布局（如滑动、列表）的实现，但大部分都直接或间接集成自 RenderBox。...</p></div><footer class=entry-footer><span title='2022-01-11 00:00:00 +0000 UTC'>January 11, 2022</span></footer><a class=entry-link aria-label="post link to Flutter 绘制流程分析与代码实践" href=http://answerkobe.github.io/posts/analysis-flutter-paint-process/></a></article><article class=post-entry><header class=entry-header><h2>探索 Java & Kotlin 泛型</h2></header><div class=entry-content><p>Kotlin 泛型基础 泛型可以让我们在代码中声明类型参数，Kotlin 泛型最基本的使用和 Java 一样，可以声明在类上和函数上，用法也都差不多。
声明在函数上时，可将类型参数作为参数或返回值的类型，该函数为泛型函数 声明在类上时，可以用在任意一处类型声明处，该类为泛型类 class GenericsDemo&lt;T>(t: T) { val value = t } fun &lt;T> invoke(t: T) : T { return t } 我们可以在声明了类型参数的类中，声明一个泛型方法，但如果内部方法所声明的类型参数名称和类上所声明的相同，那么会覆盖类上所声明的类型参数。下面的代码不会报错，并会打印 Hello 字符串。
class GenericsDemo&lt;T>() { fun &lt;T> invoke(t: T) : T { return t } } val demo = GenericsDemo&lt;Int>() println(demo.invoke("Hello")) 此外，我们知道在类中可通过重载来定义同名方法，但这在泛型中并不起作用，如果类中拥有以下两个方法，那么将会报错。
class GenericsDemo&lt;T>() { // 泛型来自类 fun invoke(t: T) : T { return t } // 泛型来自方法本身 fun &lt;S> invoke(s: S) : S { return s } } 上诉代码报错原因是因为两个方法拥有相同的 signature，也就是在 JVM 看来这两个方法的方法名和参数都是一样的，报错信息如下：...</p></div><footer class=entry-footer><span title='2021-11-06 00:00:00 +0000 UTC'>November 6, 2021</span></footer><a class=entry-link aria-label="post link to 探索 Java & Kotlin 泛型" href=http://answerkobe.github.io/posts/explore-the-kotlin-generics/></a></article><article class=post-entry><header class=entry-header><h2>从源码角度分析 ThreadLocal 的使用</h2></header><div class=entry-content><p>Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。
// ThreadDemo.java static int v = 0; static void autoAdd(){ for (int i = 0; i &lt; 10000; i++) { v++; } } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); System.out.println(v); } 上面代码变量 v 的打印结果可能会小于 20000，随着 v 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。
要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。
局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。
虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。
ThreadLocal 的使用 ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。
ThreadLocal&lt;Integer> threadLocal = new ThreadLocal&lt;>(); System....</p></div><footer class=entry-footer><span title='2021-09-03 00:00:00 +0000 UTC'>September 3, 2021</span></footer><a class=entry-link aria-label="post link to 从源码角度分析 ThreadLocal 的使用" href=http://answerkobe.github.io/posts/threadlocal-usage-and-source/readme/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://answerkobe.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=http://answerkobe.github.io/>Iverson's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>