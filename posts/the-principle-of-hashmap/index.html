<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="upgrade-insecure-requests"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>基于 JDK 1.8 分析 HashMap 的底层原理 | Iverson's blog</title>
<meta name=keywords content="Java"><meta name=description content="Java 的 HashMap 可以说是用的最多、问的最多的一个 Map Collection 了。HashMap 是非同步的，即线程不安全。HashMap 允许存放的 key 为 null，但并不保证映射的顺序，也不保证这个顺序随时间保持不变。
本文对 HashMap 的代码分析基于 JDK 1.8
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable 我们可以先从 HashMap 底层使用的数据结构了解 HashMap。
哈希表 + 链表 / 红黑树 static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; V value; Node<K,V> next; // ... } /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two."><meta name=author content><link rel=canonical href=http://answerkobe.github.io/posts/the-principle-of-hashmap/><link crossorigin=anonymous href=/assets/css/stylesheet.81e9c84b86321fe9cfdf9f01a2f8060920d09e0fec45cb91f131cfed0284007e.css integrity="sha256-genIS4YyH+nP358BovgGCSDQng/sRcuR8THP7QKEAH4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://answerkobe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://answerkobe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://answerkobe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://answerkobe.github.io/apple-touch-icon.png><link rel=mask-icon href=http://answerkobe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4112QEXZJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4112QEXZJ",{anonymize_ip:!1})}</script><meta property="og:title" content="基于 JDK 1.8 分析 HashMap 的底层原理"><meta property="og:description" content="Java 的 HashMap 可以说是用的最多、问的最多的一个 Map Collection 了。HashMap 是非同步的，即线程不安全。HashMap 允许存放的 key 为 null，但并不保证映射的顺序，也不保证这个顺序随时间保持不变。
本文对 HashMap 的代码分析基于 JDK 1.8
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable 我们可以先从 HashMap 底层使用的数据结构了解 HashMap。
哈希表 + 链表 / 红黑树 static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; V value; Node<K,V> next; // ... } /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two."><meta property="og:type" content="article"><meta property="og:url" content="http://answerkobe.github.io/posts/the-principle-of-hashmap/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-31T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-31T00:00:00+00:00"><meta property="og:site_name" content="Iverson"><meta name=twitter:card content="summary"><meta name=twitter:title content="基于 JDK 1.8 分析 HashMap 的底层原理"><meta name=twitter:description content="Java 的 HashMap 可以说是用的最多、问的最多的一个 Map Collection 了。HashMap 是非同步的，即线程不安全。HashMap 允许存放的 key 为 null，但并不保证映射的顺序，也不保证这个顺序随时间保持不变。
本文对 HashMap 的代码分析基于 JDK 1.8
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable 我们可以先从 HashMap 底层使用的数据结构了解 HashMap。
哈希表 + 链表 / 红黑树 static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; V value; Node<K,V> next; // ... } /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://answerkobe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"基于 JDK 1.8 分析 HashMap 的底层原理","item":"http://answerkobe.github.io/posts/the-principle-of-hashmap/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"基于 JDK 1.8 分析 HashMap 的底层原理","name":"基于 JDK 1.8 分析 HashMap 的底层原理","description":"Java 的 HashMap 可以说是用的最多、问的最多的一个 Map Collection 了。HashMap 是非同步的，即线程不安全。HashMap 允许存放的 key 为 null，但并不保证映射的顺序，也不保证这个顺序随时间保持不变。\n本文对 HashMap 的代码分析基于 JDK 1.8\npublic class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable 我们可以先从 HashMap 底层使用的数据结构了解 HashMap。\n哈希表 + 链表 / 红黑树 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; // ... } /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two.","keywords":["Java"],"articleBody":"Java 的 HashMap 可以说是用的最多、问的最多的一个 Map Collection 了。HashMap 是非同步的，即线程不安全。HashMap 允许存放的 key 为 null，但并不保证映射的顺序，也不保证这个顺序随时间保持不变。\n本文对 HashMap 的代码分析基于 JDK 1.8\npublic class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, Serializable 我们可以先从 HashMap 底层使用的数据结构了解 HashMap。\n哈希表 + 链表 / 红黑树 static class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e { final int hash; final K key; V value; Node\u003cK,V\u003e next; // ... } /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node\u003cK,V\u003e[] table; /** * The number of key-value mappings contained in this map. */ transient int size; HashMap 最基本的数据结构是哈希表 table（一个 Node 数组）。在 HashMap 中，把数组每个下标对应的空间称为 bucket（哈希桶），bucket 的数量就是数组的长度。\nHashMap 的 table 是懒加载的，当我们创建 HashMap 实例的时候并不会马上创建 table 数组实例，而是在第一次向 HashMap 实例添加元素的时候，才会进行初始化。\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 初始化 table if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { /* 发生哈希碰撞时的处理 */ } // ... return null; } HashMap 存放和获取数据时，都需要通过计算 key 的 hash 值来并映射为 bucket 的下标。不同的 key 得到的下标可能相同，在存放新数据时，计算出来的下标对应的 bucket 中如果已经存在其它节点，这种情况称为哈希碰撞 / 哈希冲突。\n在 HashMap 中采取的是开散列的方式来处理哈希碰撞，当发生碰撞时，通过链表的方式，将新的节点连接在已有节点的后面，当链表长度超过规定的阈值时，将会把链表转换为红黑树来进行存储（红黑树是在 JDK 1.8 才引入的）。\nstatic final int TREEIFY_THRESHOLD = 8; for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } 链表转换为红黑树的阈值为 TREEIFY_THRESHOLD，该值固定是 8，当链表长度达到这个值时，会调用 treeifyBin() 方法尝试转换为红黑树，最终是否转换为树还要根据当前 table 容量决定。\nstatic final int MIN_TREEIFY_CAPACITY = 64; final void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) { int n, index; Node\u003cK,V\u003e e; if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) \u0026 hash]) != null) { // ... } } MIN_TREEIFY_CAPACITY 是 bucket 结构树形化 table 要求的最小容量，当 table 太小没有达到这个值时（固定是 64），HashMap 会采用扩容的方式来重新打散这些节点的分布。\n从 HashMap 使用的数据结构，我们可以分析出它对应的查找时间复杂度：\n当没有发生碰撞时，那么通过计算下标直接命中对应节点，时间复杂度为 O(1) 当下标位置是发生碰撞 bucket 时，如果起连接作用的数据结构是链表的话，那么时间复杂度为 O(n)，n 是链表长度 当链表过长转换为红黑树时，时间复杂度为 O(log(n))，n 是树的节点个数。 因此，HashMap 发生碰撞的次数越少，查找效率也会越高。\nhash 与 下标计算 添加节点所调用的 putVal 方法第一个参数就是 key 的 hash 值，hash 值通过 (n - 1) \u0026 hash 这一运算，映射为 table 中存放位置的下标。在 HashMap 中通过 hash() 方法来获得 key 对应的 hash 值。\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); } 当 key 为 null 的时候，该方法直接返回的 hash 值是 0，因此在 HashMap 中，是允许 key 为 null 的，并且它只能拥有一个 null 的 key。\n当 key 不为 null 的时候，那么获取 key 的 hashCode 赋值为 h，hashCode 是将对象的内部地址转换为 int 类型的整数（这是一个 native 方法，具体看 JVM 如何实现）。\n计算下标使用的是将 hash 值和 table 数组下标的最大取值 n - 1 进行 \u0026 运算（与运算），这个过程是将 hash 值高位归 0，保留 n - 1 取值范围内的低位，从而转换为 table 数组可取的下标。\n对于 32 位的 hashCode 而言，一般是不会发生碰撞的，但由于位运算会忽略高位的数值，实际参与运算的只有低位，这就增加了碰撞的概率，运气不好的话，出现高位不同而低位相同的情况，那么碰撞将会比较严重。\n因此在 HashMap 中不直接拿 hashCode 来作为 hash 值进行下标运算，而是使用了一个将高位影响向下传播的变换方案，对 hashCode 的高 16 位和低 16 位进行一次异或操作，来将高位的特征混合到低位中，使得高位的影响也可以参与下标计算的 \u0026 运算中。\nHashMap 对这个扰乱操作是从实用性、速度、质量方面考虑的，关于这方面的说明，JDK 1.8 源码中一段注释我没完全看懂，这里贴在下面，或者可以自己去源码阅读完整的说明。\nThere is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.\n此外，每个 Node 节点在创建时就会保存对应的 hash 值，后续扩容迁移节点时计算下标，不需要重新计算 key 的 hash 值。\nresize() 扩容机制 我们知道发生冲突时，会使用链表或者树来处理 bucket 的碰撞集，那么 table 将不会发生溢出的情况。当 table 大部分 bucket 存有节点的时候，那么此时碰撞率将会非常高，碰撞会降低 HashMap 的查找效率，因此需要给 table 设置一个容纳极限 threshold。\n添加节点时，除了链表转换为红黑树时 table 容量没有达到 64 会进行扩容外，如果完成节点的添加后，当前 table 存储的节点超过了容纳极限 threshold，也会进行扩容操作，调整节点的分布情况。\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; int threshold; final float loadFactor; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // ... if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 当 table 存储的节点数量超过目前的 threshold，那么对 table 进行扩容操作，并重新分配已有的节点，通常 threshold 的值是 table.length * loadFactor。除非超出规定大小，否则初始化时和每一次扩容后 threshold 的值都会更新。\nloadFactor 称为负载因子，默认是使用 DEFAULT_LOAD_FACTOR 的值 0.75，这代表在碰撞次数为 0 的情况下，有超过 75% 的 bucket 被使用就会进行扩容操作。0.75 是从时间和空间上进行权衡得出的值，当负载因子更大时，会减少空间的开销，因为扩容所要求的 threshold 会更高，但这也可能会增加查询的时间成本，因为每个 bucket 发生哈希冲突的次数和概率会变得更高。\n/** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16 final Node\u003cK,V\u003e[] resize() { Node\u003cK,V\u003e[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap \u003e 0) { if (oldCap \u003e= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 oldCap \u003e= DEFAULT_INITIAL_CAPACITY) newThr = oldThr \u003c\u003c 1; // double threshold } else if (oldThr \u003e 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap]; table = newTab; if (oldTab != null) { /* 扩容后迁移节点 */ } return newTab; } 初始化与自定义 在 resize() 中会根据 table 原本的容量大小 oldCap 是否为空来判断进行初始化还是扩容，如果进行初试化，则根据原本的容纳极限 oldThr 来决定初始化容量。\n当我们使用无参数构造方法创建 HashMap 对象时，threshold 默认为 0，也就是 oldThr == 0，此时使用 DEFAULT_INITIAL_CAPACITY 来作为初始化容量，其大小为 16，初始化后 threshold 的新值为 DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY。\npublic HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u003c 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity \u003e MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor \u003c= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } 我们可以使用 HashMap 的有参构造方法指定 initialCapacity 来自定义初始化容量，也可以通过有参构造方法指定 loadFactor 的值。\n在 HashMap 中规定初始化容量必须时 2 的幂，并且规定 table 最大长度为 MAXIMUM_CAPACITY，因此会调用 tableSizeFor() 方法来获得符合要求的目标容量，并赋值给 threshold。\ntableSizeFor() 通过一系列右移和或运算的结合，来保证得到的值是一个 2 的幂，并且保证该值不会超过 HashMap 限制的最大容量 MAXIMUM_CAPACITY。\n/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two \u003c= 1\u003c\u003c30. */ static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30; static final int tableSizeFor(int cap) { int n = cap - 1; n |= n \u003e\u003e\u003e 1; n |= n \u003e\u003e\u003e 2; n |= n \u003e\u003e\u003e 4; n |= n \u003e\u003e\u003e 8; n |= n \u003e\u003e\u003e 16; return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 当初始化 table 时原本 threshold 的值 oldThr 不为 0，则用该值作为初始化容量进行初始化，newThr 为负载因子（创建对象时可能指定了 loadFactor）和新容量的积 newCap * loadFactor。\n在 HashMap 中有规定 table 的最大容量 MAXIMUM_CAPACITY，我们自己指定的容量可能达到这一大小，当新容量的大小或新容纳极限达到或超过这个限制时，将会使用 int 类型的最大值 Integer.MAX_VALUE 作为新的容纳极限。\n扩容与节点迁移 HashMap 扩容时，新容量为旧容量的两倍，如果扩充出来的新容量比限制的最大容量 MAXIMUM_CAPACITY 大，那么将会使用最大容量作为新容量，如果原本的容量就已经达到限制的最大容量，那么不进行扩容，直接将原本的 table 返回，而 table 的容纳极限 threshold 变为 int 类型的最大值。\n在扩容后，需要将节点迁移到新的 table 里面，迁移时需要根据节点的 hash 值重新计算下标。\nif (oldTab != null) { for (int j = 0; j \u003c oldCap; ++j) { Node\u003cK,V\u003e e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash \u0026 (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap); else { // preserve order Node\u003cK,V\u003e loHead = null, loTail = null; Node\u003cK,V\u003e hiHead = null, hiTail = null; Node\u003cK,V\u003e next; do { next = e.next; if ((e.hash \u0026 oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } 对于只有单个节点的 bucket，直接计算这个节点在新 table 的位置并插入 对于链表和树，则是通过查看新增加的一位二进制来决定在新 table 的位置，再和已经存在的节点组合起来 我们知道下标的计算采用 \u0026 运算，而新的容量是旧容量的 2 倍，也就是对应的二进制左移了一位，那么下标的取值范围相比原本，从二进制数上看，就是增加了一位，因此我们只需要看新增加的那一位二进制数是 0 还是 1，就能确定节点的新位置。\n实际上增加的那一位在数值上大小就是原本 table 的容量大小，如果新增加的那一位是 1，那么代表新的下标为当前的下标加上原本的容量大小 j + oldCap，这也是为什么 HashMap 规定 table 的长度必须是 2 的幂。\n在发生冲突的 bucket 中查找节点 public V get(Object key) { Node\u003cK,V\u003e e; return (e = getNode(hash(key), key)) == null ? null : e.value; } HashMap 的查找操作使用 get(Object key) 来获取对应 Key 的 Node 节点，并返回节点中的 value 值。查找时需要获取对应的 key 的 hash 值，查找时需要获取到 key 的 hash 值来计算对应 Node 节点所在的 bucket 的下标。\nfinal Node\u003cK,V\u003e getNode(int hash, Object key) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k; if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026 (first = tab[(n - 1) \u0026 hash]) != null) { if (first.hash == hash \u0026\u0026 // always check first node ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 我们知道 bucket 可能发生哈希碰撞，因此在 bucket 可能存在多个节点（以链表或树的结构组织起来），此时如果要找到对应 key 的节点，则需要对 bucket 中存放的节点逐个对 key 进行匹配。\n在 HashMap 匹配 key 的方式，是先判断两个对象是否相同，如果不同再使用 equals() 方法来判断两个对象的内容是否相等。当节点中的 key 与我们查找的 key 相同时，则返回该节点，如果所有节点的 key 都不匹配时，则返回 null。\n这个操作不仅仅存在于查找元素，也存在于 put() 方法进行元素的存放，当发生碰撞后，新存放的元素对应的 key 在 bucket 中已经存在对应的 Node 节点时，将会用新节点覆盖原有节点的。\n// putVal 发生碰撞的 else 块中 if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; 因此，无论是 put() 或是 get()，第一步都是需要通过 hashCode() 进行运算来获得 hash 值，并找到对应 bucket 的下标，发生哈希碰撞时需要使用 equals() 来判断两个 key 是否相等，这也是为什么我们在编写类时，如果重写了 hashCode() 需要重写 equals() 方法。\n参考 JDK 1.8 源码\n不按套路出牌，HashMap负载因子超过1会怎样？\n","wordCount":"1512","inLanguage":"en","datePublished":"2021-05-31T00:00:00Z","dateModified":"2021-05-31T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://answerkobe.github.io/posts/the-principle-of-hashmap/"},"publisher":{"@type":"Organization","name":"Iverson's blog","logo":{"@type":"ImageObject","url":"http://answerkobe.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://answerkobe.github.io/ accesskey=h title="Iverson's blog (Alt + H)">Iverson's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://answerkobe.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=http://answerkobe.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=http://answerkobe.github.io/profile title=Profile-X><span>Profile-X</span></a></li><li><a href=http://answerkobe.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://answerkobe.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://answerkobe.github.io/posts/>Posts</a></div><h1 class=post-title>基于 JDK 1.8 分析 HashMap 的底层原理</h1><div class=post-meta><span title='2021-05-31 00:00:00 +0000 UTC'>May 31, 2021</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%93%88%e5%b8%8c%e8%a1%a8--%e9%93%be%e8%a1%a8--%e7%ba%a2%e9%bb%91%e6%a0%91 aria-label="哈希表 + 链表 / 红黑树">哈希表 + 链表 / 红黑树</a></li><li><a href=#hash-%e4%b8%8e-%e4%b8%8b%e6%a0%87%e8%ae%a1%e7%ae%97 aria-label="hash 与 下标计算">hash 与 下标计算</a></li><li><a href=#resize-%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6 aria-label="resize() 扩容机制">resize() 扩容机制</a><ul><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e8%87%aa%e5%ae%9a%e4%b9%89 aria-label=初始化与自定义>初始化与自定义</a></li><li><a href=#%e6%89%a9%e5%ae%b9%e4%b8%8e%e8%8a%82%e7%82%b9%e8%bf%81%e7%a7%bb aria-label=扩容与节点迁移>扩容与节点迁移</a></li></ul></li><li><a href=#%e5%9c%a8%e5%8f%91%e7%94%9f%e5%86%b2%e7%aa%81%e7%9a%84-bucket-%e4%b8%ad%e6%9f%a5%e6%89%be%e8%8a%82%e7%82%b9 aria-label="在发生冲突的 bucket 中查找节点">在发生冲突的 bucket 中查找节点</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Java 的 HashMap 可以说是用的最多、问的最多的一个 Map Collection 了。HashMap 是非同步的，即线程不安全。HashMap 允许存放的 key 为 null，但并不保证映射的顺序，也不保证这个顺序随时间保持不变。</p><p><em>本文对 HashMap 的代码分析基于 JDK 1.8</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> AbstractMap<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>implements</span> Map<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>, Cloneable, Serializable
</span></span></code></pre></div><p><img loading=lazy src=./HashMap.png alt="HashMap UML"></p><p>我们可以先从 HashMap 底层使用的数据结构了解 HashMap。</p><p><img loading=lazy src=./draw-1.jpg alt=draw-1></p><h2 id=哈希表--链表--红黑树>哈希表 + 链表 / 红黑树<a hidden class=anchor aria-hidden=true href=#哈希表--链表--红黑树>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> hash;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> K key;
</span></span><span style=display:flex><span>    V value;
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The table, initialized on first use, and resized as
</span></span></span><span style=display:flex><span><span style=color:#75715e> * necessary. When allocated, length is always a power of two.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * (We also tolerate length zero in some operations to allow
</span></span></span><span style=display:flex><span><span style=color:#75715e> * bootstrapping mechanics that are currently not needed.)
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>transient</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> table;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The number of key-value mappings contained in this map.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>int</span> size;
</span></span></code></pre></div><p>HashMap 最基本的数据结构是哈希表 table（一个 Node 数组）。在 HashMap 中，把数组每个下标对应的空间称为 bucket（哈希桶），bucket 的数量就是数组的长度。</p><p>HashMap 的 table 是懒加载的，当我们创建 HashMap 实例的时候并不会马上创建 table 数组实例，而是在第一次向 HashMap 实例添加元素的时候，才会进行初始化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> V <span style=color:#a6e22e>put</span>(K key, V value) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> putVal(hash(key), key, value, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> V <span style=color:#a6e22e>putVal</span>(<span style=color:#66d9ef>int</span> hash, K key, V value, <span style=color:#66d9ef>boolean</span> onlyIfAbsent, <span style=color:#66d9ef>boolean</span> evict) {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab; Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p; <span style=color:#66d9ef>int</span> n, i;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((tab <span style=color:#f92672>=</span> table) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> (n <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>) <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> (tab <span style=color:#f92672>=</span> resize()).<span style=color:#a6e22e>length</span>; <span style=color:#75715e>// 初始化 table</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((p <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>i <span style=color:#f92672>=</span> (n <span style=color:#f92672>-</span> 1) <span style=color:#f92672>&amp;</span> hash<span style=color:#f92672>]</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        tab<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> newNode(hash, key, value, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 发生哈希碰撞时的处理 */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>HashMap 存放和获取数据时，都需要通过计算 key 的 hash 值来并映射为 bucket 的下标。不同的 key 得到的下标可能相同，在存放新数据时，计算出来的下标对应的 bucket 中如果已经存在其它节点，这种情况称为<strong>哈希碰撞 / 哈希冲突</strong>。</p><p>在 HashMap 中采取的是开散列的方式来处理哈希碰撞，当发生碰撞时，通过链表的方式，将新的节点连接在已有节点的后面，当链表长度超过规定的阈值时，将会把链表转换为红黑树来进行存储（红黑树是在 JDK 1.8 才引入的）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> TREEIFY_THRESHOLD <span style=color:#f92672>=</span> 8;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> binCount <span style=color:#f92672>=</span> 0; ; <span style=color:#f92672>++</span>binCount) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((e <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>next</span>) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode(hash, key, value, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (binCount <span style=color:#f92672>&gt;=</span> TREEIFY_THRESHOLD <span style=color:#f92672>-</span> 1) <span style=color:#75715e>// -1 for 1st</span>
</span></span><span style=display:flex><span>            treeifyBin(tab, hash);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        ((k <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> (key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key.<span style=color:#a6e22e>equals</span>(k))))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>链表转换为红黑树的阈值为 <code>TREEIFY_THRESHOLD</code>，该值固定是 8，当链表长度达到这个值时，会调用 <code>treeifyBin()</code> 方法尝试转换为红黑树，最终是否转换为树还要根据当前 table 容量决定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> MIN_TREEIFY_CAPACITY <span style=color:#f92672>=</span> 64;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>treeifyBin</span>(Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab, <span style=color:#66d9ef>int</span> hash) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n, index; Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tab <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> (n <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>) <span style=color:#f92672>&lt;</span> MIN_TREEIFY_CAPACITY)
</span></span><span style=display:flex><span>        resize();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((e <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>index <span style=color:#f92672>=</span> (n <span style=color:#f92672>-</span> 1) <span style=color:#f92672>&amp;</span> hash<span style=color:#f92672>]</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>       <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>MIN_TREEIFY_CAPACITY</code> 是 bucket 结构树形化 table 要求的最小容量，当 table 太小没有达到这个值时（固定是 64），HashMap 会采用扩容的方式来重新打散这些节点的分布。</p><p>从 HashMap 使用的数据结构，我们可以分析出它对应的查找时间复杂度：</p><ul><li>当没有发生碰撞时，那么通过计算下标直接命中对应节点，时间复杂度为 O(1)</li><li>当下标位置是发生碰撞 bucket 时，如果起连接作用的数据结构是链表的话，那么时间复杂度为 O(n)，n 是链表长度</li><li>当链表过长转换为红黑树时，时间复杂度为 O(log(n))，n 是树的节点个数。</li></ul><p>因此，HashMap 发生碰撞的次数越少，查找效率也会越高。</p><h2 id=hash-与-下标计算>hash 与 下标计算<a hidden class=anchor aria-hidden=true href=#hash-与-下标计算>#</a></h2><p>添加节点所调用的 <code>putVal</code> 方法第一个参数就是 key 的 hash 值，hash 值通过 <code>(n - 1) & hash</code> 这一运算，映射为 table 中存放位置的下标。在 HashMap 中通过 <code>hash()</code> 方法来获得 key 对应的 hash 值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hash</span>(Object key) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> h;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (key <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#f92672>?</span> 0 : (h <span style=color:#f92672>=</span> key.<span style=color:#a6e22e>hashCode</span>()) <span style=color:#f92672>^</span> (h <span style=color:#f92672>&gt;&gt;&gt;</span> 16);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当 key 为 null 的时候，该方法直接返回的 hash 值是 0，因此在 HashMap 中，是允许 key 为 null 的，并且它只能拥有一个 null 的 key。</p><p>当 key 不为 null 的时候，那么获取 key 的 hashCode 赋值为 h，hashCode 是将对象的内部地址转换为 int 类型的整数（这是一个 native 方法，具体看 JVM 如何实现）。</p><p>计算下标使用的是将 hash 值和 table 数组下标的最大取值 <code>n - 1</code> 进行 & 运算（与运算），这个过程是将 hash 值高位归 0，保留 <code>n - 1</code> 取值范围内的低位，从而转换为 table 数组可取的下标。</p><p><img loading=lazy src=./draw-2.jpg alt=draw-2></p><p>对于 32 位的 hashCode 而言，一般是不会发生碰撞的，但由于位运算会忽略高位的数值，实际参与运算的只有低位，这就增加了碰撞的概率，运气不好的话，出现高位不同而低位相同的情况，那么碰撞将会比较严重。</p><p>因此在 HashMap 中不直接拿 hashCode 来作为 hash 值进行下标运算，而是使用了一个将高位影响向下传播的变换方案，对 hashCode 的高 16 位和低 16 位进行一次异或操作，来将高位的特征混合到低位中，使得高位的影响也可以参与下标计算的 & 运算中。</p><p><img loading=lazy src=./draw-3.jpg alt=draw-3></p><p>HashMap 对这个扰乱操作是从实用性、速度、质量方面考虑的，关于这方面的说明，JDK 1.8 源码中一段注释我没完全看懂，这里贴在下面，或者可以自己去源码阅读完整的说明。</p><blockquote><p>There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don&rsquo;t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p></blockquote><p>此外，每个 Node 节点在创建时就会保存对应的 hash 值，后续扩容迁移节点时计算下标，不需要重新计算 key 的 hash 值。</p><h2 id=resize-扩容机制>resize() 扩容机制<a hidden class=anchor aria-hidden=true href=#resize-扩容机制>#</a></h2><p>我们知道发生冲突时，会使用链表或者树来处理 bucket 的碰撞集，那么 table 将不会发生溢出的情况。当 table 大部分 bucket 存有节点的时候，那么此时碰撞率将会非常高，碰撞会降低 HashMap 的查找效率，因此需要给 table 设置一个容纳极限 <code>threshold</code>。</p><p>添加节点时，除了链表转换为红黑树时 table 容量没有达到 64 会进行扩容外，如果完成节点的添加后，当前 table 存储的节点超过了容纳极限 <code>threshold</code>，也会进行扩容操作，调整节点的分布情况。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>float</span> DEFAULT_LOAD_FACTOR <span style=color:#f92672>=</span> 0.<span style=color:#a6e22e>75f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> threshold;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>float</span> loadFactor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> V <span style=color:#a6e22e>putVal</span>(<span style=color:#66d9ef>int</span> hash, K key, V value, <span style=color:#66d9ef>boolean</span> onlyIfAbsent, <span style=color:#66d9ef>boolean</span> evict) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>++</span>size <span style=color:#f92672>&gt;</span> threshold)
</span></span><span style=display:flex><span>        resize();
</span></span><span style=display:flex><span>    afterNodeInsertion(evict);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>HashMap</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loadFactor</span> <span style=color:#f92672>=</span> DEFAULT_LOAD_FACTOR; <span style=color:#75715e>// all other fields defaulted</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当 table 存储的节点数量超过目前的 <code>threshold</code>，那么对 table 进行扩容操作，并重新分配已有的节点，通常 <code>threshold</code> 的值是 <code>table.length * loadFactor</code>。除非超出规定大小，否则初始化时和每一次扩容后 <code>threshold</code> 的值都会更新。</p><p><code>loadFactor</code> 称为负载因子，默认是使用 <code>DEFAULT_LOAD_FACTOR</code> 的值 0.75，这代表在碰撞次数为 0 的情况下，有超过 75% 的 bucket 被使用就会进行扩容操作。0.75 是从时间和空间上进行权衡得出的值，当负载因子更大时，会减少空间的开销，因为扩容所要求的 <code>threshold</code> 会更高，但这也可能会增加查询的时间成本，因为每个 bucket 发生哈希冲突的次数和概率会变得更高。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The default initial capacity - MUST be a power of two.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> DEFAULT_INITIAL_CAPACITY <span style=color:#f92672>=</span> 1 <span style=color:#f92672>&lt;&lt;</span> 4; <span style=color:#75715e>// aka 16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> <span style=color:#a6e22e>resize</span>() {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> oldTab <span style=color:#f92672>=</span> table;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> oldCap <span style=color:#f92672>=</span> (oldTab <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#f92672>?</span> 0 : oldTab.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> oldThr <span style=color:#f92672>=</span> threshold;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> newCap, newThr <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (oldCap <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (oldCap <span style=color:#f92672>&gt;=</span> MAXIMUM_CAPACITY) {
</span></span><span style=display:flex><span>            threshold <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>MAX_VALUE</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> oldTab;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> ((newCap <span style=color:#f92672>=</span> oldCap <span style=color:#f92672>&lt;&lt;</span> 1) <span style=color:#f92672>&lt;</span> MAXIMUM_CAPACITY <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    oldCap <span style=color:#f92672>&gt;=</span> DEFAULT_INITIAL_CAPACITY)
</span></span><span style=display:flex><span>            newThr <span style=color:#f92672>=</span> oldThr <span style=color:#f92672>&lt;&lt;</span> 1; <span style=color:#75715e>// double threshold</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (oldThr <span style=color:#f92672>&gt;</span> 0) <span style=color:#75715e>// initial capacity was placed in threshold</span>
</span></span><span style=display:flex><span>        newCap <span style=color:#f92672>=</span> oldThr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {               <span style=color:#75715e>// zero initial threshold signifies using defaults</span>
</span></span><span style=display:flex><span>        newCap <span style=color:#f92672>=</span> DEFAULT_INITIAL_CAPACITY;
</span></span><span style=display:flex><span>        newThr <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span>)(DEFAULT_LOAD_FACTOR <span style=color:#f92672>*</span> DEFAULT_INITIAL_CAPACITY);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newThr <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>float</span> ft <span style=color:#f92672>=</span> (<span style=color:#66d9ef>float</span>)newCap <span style=color:#f92672>*</span> loadFactor;
</span></span><span style=display:flex><span>        newThr <span style=color:#f92672>=</span> (newCap <span style=color:#f92672>&lt;</span> MAXIMUM_CAPACITY <span style=color:#f92672>&amp;&amp;</span> ft <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>float</span>)MAXIMUM_CAPACITY <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                    (<span style=color:#66d9ef>int</span>)ft : Integer.<span style=color:#a6e22e>MAX_VALUE</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    threshold <span style=color:#f92672>=</span> newThr;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SuppressWarnings</span>({<span style=color:#e6db74>&#34;rawtypes&#34;</span>,<span style=color:#e6db74>&#34;unchecked&#34;</span>})
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> newTab <span style=color:#f92672>=</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span>)<span style=color:#66d9ef>new</span> Node<span style=color:#f92672>[</span>newCap<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    table <span style=color:#f92672>=</span> newTab;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (oldTab <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 扩容后迁移节点 */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> newTab;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=初始化与自定义>初始化与自定义<a hidden class=anchor aria-hidden=true href=#初始化与自定义>#</a></h3><p>在 resize() 中会根据 table 原本的容量大小 <code>oldCap</code> 是否为空来判断进行初始化还是扩容，如果进行初试化，则根据原本的容纳极限 <code>oldThr</code> 来决定初始化容量。</p><p>当我们使用无参数构造方法创建 HashMap 对象时，<code>threshold</code> 默认为 0，也就是 <code>oldThr == 0</code>，此时使用 <code>DEFAULT_INITIAL_CAPACITY</code> 来作为初始化容量，其大小为 16，初始化后 <code>threshold</code> 的新值为 <code>DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>HashMap</span>(<span style=color:#66d9ef>int</span> initialCapacity, <span style=color:#66d9ef>float</span> loadFactor) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (initialCapacity <span style=color:#f92672>&lt;</span> 0)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;Illegal initial capacity: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                                            initialCapacity);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (initialCapacity <span style=color:#f92672>&gt;</span> MAXIMUM_CAPACITY)
</span></span><span style=display:flex><span>        initialCapacity <span style=color:#f92672>=</span> MAXIMUM_CAPACITY;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (loadFactor <span style=color:#f92672>&lt;=</span> 0 <span style=color:#f92672>||</span> Float.<span style=color:#a6e22e>isNaN</span>(loadFactor))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;Illegal load factor: &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                                            loadFactor);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>loadFactor</span> <span style=color:#f92672>=</span> loadFactor;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>threshold</span> <span style=color:#f92672>=</span> tableSizeFor(initialCapacity);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>HashMap</span>(<span style=color:#66d9ef>int</span> initialCapacity) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以使用 HashMap 的有参构造方法指定 <code>initialCapacity</code> 来自定义初始化容量，也可以通过有参构造方法指定 <code>loadFactor</code> 的值。</p><p>在 HashMap 中规定初始化容量必须时 2 的幂，并且规定 table 最大长度为 <code>MAXIMUM_CAPACITY</code>，因此会调用 <code>tableSizeFor()</code> 方法来获得符合要求的目标容量，并赋值给 <code>threshold</code>。</p><p><code>tableSizeFor()</code> 通过一系列右移和或运算的结合，来保证得到的值是一个 2 的幂，并且保证该值不会超过 HashMap 限制的最大容量 <code>MAXIMUM_CAPACITY</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The maximum capacity, used if a higher value is implicitly specified
</span></span></span><span style=display:flex><span><span style=color:#75715e> * by either of the constructors with arguments.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * MUST be a power of two &lt;= 1&lt;&lt;30.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> MAXIMUM_CAPACITY <span style=color:#f92672>=</span> 1 <span style=color:#f92672>&lt;&lt;</span> 30;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>tableSizeFor</span>(<span style=color:#66d9ef>int</span> cap) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> cap <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>    n <span style=color:#f92672>|=</span> n <span style=color:#f92672>&gt;&gt;&gt;</span> 1;
</span></span><span style=display:flex><span>    n <span style=color:#f92672>|=</span> n <span style=color:#f92672>&gt;&gt;&gt;</span> 2;
</span></span><span style=display:flex><span>    n <span style=color:#f92672>|=</span> n <span style=color:#f92672>&gt;&gt;&gt;</span> 4;
</span></span><span style=display:flex><span>    n <span style=color:#f92672>|=</span> n <span style=color:#f92672>&gt;&gt;&gt;</span> 8;
</span></span><span style=display:flex><span>    n <span style=color:#f92672>|=</span> n <span style=color:#f92672>&gt;&gt;&gt;</span> 16;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (n <span style=color:#f92672>&lt;</span> 0) <span style=color:#f92672>?</span> 1 : (n <span style=color:#f92672>&gt;=</span> MAXIMUM_CAPACITY) <span style=color:#f92672>?</span> MAXIMUM_CAPACITY : n <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=./draw-4.jpg alt=draw-4></p><p>当初始化 table 时原本 <code>threshold</code> 的值 <code>oldThr</code> 不为 0，则用该值作为初始化容量进行初始化，<code>newThr</code> 为负载因子（创建对象时可能指定了 loadFactor）和新容量的积 <code>newCap * loadFactor</code>。</p><p>在 HashMap 中有规定 table 的最大容量 <code>MAXIMUM_CAPACITY</code>，我们自己指定的容量可能达到这一大小，当新容量的大小或新容纳极限达到或超过这个限制时，将会使用 int 类型的最大值 <code>Integer.MAX_VALUE</code> 作为新的容纳极限。</p><h3 id=扩容与节点迁移>扩容与节点迁移<a hidden class=anchor aria-hidden=true href=#扩容与节点迁移>#</a></h3><p>HashMap 扩容时，新容量为旧容量的两倍，如果扩充出来的新容量比限制的最大容量 <code>MAXIMUM_CAPACITY</code> 大，那么将会使用最大容量作为新容量，如果原本的容量就已经达到限制的最大容量，那么不进行扩容，直接将原本的 table 返回，而 table 的容纳极限 <code>threshold</code> 变为 int 类型的最大值。</p><p>在扩容后，需要将节点迁移到新的 table 里面，迁移时需要根据节点的 hash 值重新计算下标。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>if</span> (oldTab <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0; j <span style=color:#f92672>&lt;</span> oldCap; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((e <span style=color:#f92672>=</span> oldTab<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            oldTab<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>next</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                newTab<span style=color:#f92672>[</span>e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> (newCap <span style=color:#f92672>-</span> 1)<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (e <span style=color:#66d9ef>instanceof</span> TreeNode)
</span></span><span style=display:flex><span>                ((TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)e).<span style=color:#a6e22e>split</span>(<span style=color:#66d9ef>this</span>, newTab, j, oldCap);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// preserve order</span>
</span></span><span style=display:flex><span>                Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> loHead <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>, loTail <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> hiHead <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>, hiTail <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                    next <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>next</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> ((e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> oldCap) <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (loTail <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                            loHead <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                            loTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                        loTail <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (hiTail <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                            hiHead <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                            hiTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                        hiTail <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>while</span> ((e <span style=color:#f92672>=</span> next) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (loTail <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    loTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                    newTab<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> loHead;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (hiTail <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    hiTail.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                    newTab<span style=color:#f92672>[</span>j <span style=color:#f92672>+</span> oldCap<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> hiHead;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>对于只有单个节点的 bucket，直接计算这个节点在新 table 的位置并插入</li><li>对于链表和树，则是通过查看新增加的一位二进制来决定在新 table 的位置，再和已经存在的节点组合起来</li></ul><p>我们知道下标的计算采用 & 运算，而新的容量是旧容量的 2 倍，也就是对应的二进制左移了一位，那么下标的取值范围相比原本，从二进制数上看，就是增加了一位，因此我们只需要看新增加的那一位二进制数是 0 还是 1，就能确定节点的新位置。</p><p><img loading=lazy src=./draw-5.jpg alt=draw-5></p><p>实际上增加的那一位在数值上大小就是原本 table 的容量大小，如果新增加的那一位是 1，那么代表新的下标为当前的下标加上原本的容量大小 <code>j + oldCap</code>，这也是为什么 HashMap 规定 table 的长度必须是 2 的幂。</p><h2 id=在发生冲突的-bucket-中查找节点>在发生冲突的 bucket 中查找节点<a hidden class=anchor aria-hidden=true href=#在发生冲突的-bucket-中查找节点>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> V <span style=color:#a6e22e>get</span>(Object key) {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (e <span style=color:#f92672>=</span> getNode(hash(key), key)) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span> : e.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>HashMap 的查找操作使用 <code>get(Object key)</code> 来获取对应 Key 的 Node 节点，并返回节点中的 value 值。查找时需要获取对应的 key 的 hash 值，查找时需要获取到 key 的 hash 值来计算对应 Node 节点所在的 bucket 的下标。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getNode</span>(<span style=color:#66d9ef>int</span> hash, Object key) {
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab; Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> first, e; <span style=color:#66d9ef>int</span> n; K k;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((tab <span style=color:#f92672>=</span> table) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> (n <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>) <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        (first <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>(n <span style=color:#f92672>-</span> 1) <span style=color:#f92672>&amp;</span> hash<span style=color:#f92672>]</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (first.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span> <span style=color:#75715e>// always check first node</span>
</span></span><span style=display:flex><span>            ((k <span style=color:#f92672>=</span> first.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> (key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key.<span style=color:#a6e22e>equals</span>(k))))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> first;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((e <span style=color:#f92672>=</span> first.<span style=color:#a6e22e>next</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (first <span style=color:#66d9ef>instanceof</span> TreeNode)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> ((TreeNode<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)first).<span style=color:#a6e22e>getTreeNode</span>(hash, key);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    ((k <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> (key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key.<span style=color:#a6e22e>equals</span>(k))))
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> e;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>while</span> ((e <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>next</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们知道 bucket 可能发生哈希碰撞，因此在 bucket 可能存在多个节点（以链表或树的结构组织起来），此时如果要找到对应 key 的节点，则需要对 bucket 中存放的节点逐个对 key 进行匹配。</p><p>在 HashMap 匹配 key 的方式，是先判断两个对象是否相同，如果不同再使用 <code>equals()</code> 方法来判断两个对象的内容是否相等。当节点中的 key 与我们查找的 key 相同时，则返回该节点，如果所有节点的 key 都不匹配时，则返回 null。</p><p>这个操作不仅仅存在于查找元素，也存在于 <code>put()</code> 方法进行元素的存放，当发生碰撞后，新存放的元素对应的 key 在 bucket 中已经存在对应的 Node 节点时，将会用新节点覆盖原有节点的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>// putVal 发生碰撞的 else 块中</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (p.<span style=color:#a6e22e>hash</span> <span style=color:#f92672>==</span> hash <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>    ((k <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>key</span>) <span style=color:#f92672>==</span> key <span style=color:#f92672>||</span> (key <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> key.<span style=color:#a6e22e>equals</span>(k))))
</span></span><span style=display:flex><span>    e <span style=color:#f92672>=</span> p;
</span></span></code></pre></div><p>因此，无论是 <code>put()</code> 或是 <code>get()</code>，第一步都是需要通过 <code>hashCode()</code> 进行运算来获得 hash 值，并找到对应 bucket 的下标，发生哈希碰撞时需要使用 <code>equals()</code> 来判断两个 key 是否相等，这也是为什么我们在编写类时，如果重写了 <code>hashCode()</code> 需要重写 <code>equals()</code> 方法。</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><blockquote><p>JDK 1.8 源码</p><p><a href=https://juejin.cn/post/6844903993265618951>不按套路出牌，HashMap负载因子超过1会怎样？</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=http://answerkobe.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=http://answerkobe.github.io/posts/threadlocal-usage-and-source/readme/><span class=title>« Prev</span><br><span>从源码角度分析 ThreadLocal 的使用</span>
</a><a class=next href=http://answerkobe.github.io/posts/red-black-tree/><span class=title>Next »</span><br><span>基于 2-3-4 树理解红黑树的性质与操作</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于 JDK 1.8 分析 HashMap 的底层原理 on x" href="https://x.com/intent/tweet/?text=%e5%9f%ba%e4%ba%8e%20JDK%201.8%20%e5%88%86%e6%9e%90%20HashMap%20%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthe-principle-of-hashmap%2f&amp;hashtags=Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于 JDK 1.8 分析 HashMap 的底层原理 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthe-principle-of-hashmap%2f&amp;title=%e5%9f%ba%e4%ba%8e%20JDK%201.8%20%e5%88%86%e6%9e%90%20HashMap%20%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86&amp;summary=%e5%9f%ba%e4%ba%8e%20JDK%201.8%20%e5%88%86%e6%9e%90%20HashMap%20%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86&amp;source=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthe-principle-of-hashmap%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于 JDK 1.8 分析 HashMap 的底层原理 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthe-principle-of-hashmap%2f&title=%e5%9f%ba%e4%ba%8e%20JDK%201.8%20%e5%88%86%e6%9e%90%20HashMap%20%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于 JDK 1.8 分析 HashMap 的底层原理 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthe-principle-of-hashmap%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于 JDK 1.8 分析 HashMap 的底层原理 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%9f%ba%e4%ba%8e%20JDK%201.8%20%e5%88%86%e6%9e%90%20HashMap%20%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86%20-%20http%3a%2f%2fanswerkobe.github.io%2fposts%2fthe-principle-of-hashmap%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于 JDK 1.8 分析 HashMap 的底层原理 on telegram" href="https://telegram.me/share/url?text=%e5%9f%ba%e4%ba%8e%20JDK%201.8%20%e5%88%86%e6%9e%90%20HashMap%20%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthe-principle-of-hashmap%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于 JDK 1.8 分析 HashMap 的底层原理 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%9f%ba%e4%ba%8e%20JDK%201.8%20%e5%88%86%e6%9e%90%20HashMap%20%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86&u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthe-principle-of-hashmap%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script id=utteranc src=https://utteranc.es/client.js repo=Answerkobe/utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.body.className.includes("dark")?"github-light":"photon-dark",t={type:"set-theme",theme:e},n=document.querySelector(".utterances-frame");n.contentWindow.postMessage(t,"https://utteranc.es")})</script></article></main><footer class=footer><span>&copy; 2023 <a href=http://answerkobe.github.io/>Iverson's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>