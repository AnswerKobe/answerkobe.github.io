<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="upgrade-insecure-requests"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从源码角度分析 ThreadLocal 的使用 | Iverson's blog</title>
<meta name=keywords content="Java"><meta name=description content="Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。
// ThreadDemo.java static int v = 0; static void autoAdd(){ for (int i = 0; i < 10000; i++) { v++; } } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); System.out.println(v); } 上面代码变量 v 的打印结果可能会小于 20000，随着 v 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。
要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。
局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。
虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。
ThreadLocal 的使用 ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。
ThreadLocal<Integer> threadLocal = new ThreadLocal<>(); System."><meta name=author content><link rel=canonical href=http://answerkobe.github.io/posts/threadlocal-usage-and-source/readme/><link crossorigin=anonymous href=/assets/css/stylesheet.81e9c84b86321fe9cfdf9f01a2f8060920d09e0fec45cb91f131cfed0284007e.css integrity="sha256-genIS4YyH+nP358BovgGCSDQng/sRcuR8THP7QKEAH4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://answerkobe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://answerkobe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://answerkobe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://answerkobe.github.io/apple-touch-icon.png><link rel=mask-icon href=http://answerkobe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4112QEXZJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4112QEXZJ",{anonymize_ip:!1})}</script><meta property="og:title" content="从源码角度分析 ThreadLocal 的使用"><meta property="og:description" content="Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。
// ThreadDemo.java static int v = 0; static void autoAdd(){ for (int i = 0; i < 10000; i++) { v++; } } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); System.out.println(v); } 上面代码变量 v 的打印结果可能会小于 20000，随着 v 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。
要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。
局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。
虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。
ThreadLocal 的使用 ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。
ThreadLocal<Integer> threadLocal = new ThreadLocal<>(); System."><meta property="og:type" content="article"><meta property="og:url" content="http://answerkobe.github.io/posts/threadlocal-usage-and-source/readme/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-03T00:00:00+00:00"><meta property="article:modified_time" content="2021-09-03T00:00:00+00:00"><meta property="og:site_name" content="Iverson"><meta name=twitter:card content="summary"><meta name=twitter:title content="从源码角度分析 ThreadLocal 的使用"><meta name=twitter:description content="Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。
// ThreadDemo.java static int v = 0; static void autoAdd(){ for (int i = 0; i < 10000; i++) { v++; } } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); System.out.println(v); } 上面代码变量 v 的打印结果可能会小于 20000，随着 v 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。
要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。
局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。
虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。
ThreadLocal 的使用 ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。
ThreadLocal<Integer> threadLocal = new ThreadLocal<>(); System."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://answerkobe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"从源码角度分析 ThreadLocal 的使用","item":"http://answerkobe.github.io/posts/threadlocal-usage-and-source/readme/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从源码角度分析 ThreadLocal 的使用","name":"从源码角度分析 ThreadLocal 的使用","description":"Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。\n// ThreadDemo.java static int v = 0; static void autoAdd(){ for (int i = 0; i \u0026lt; 10000; i++) { v++; } } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); System.out.println(v); } 上面代码变量 v 的打印结果可能会小于 20000，随着 v 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。\n要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。\n局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。\n虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。\nThreadLocal 的使用 ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。\nThreadLocal\u0026lt;Integer\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); System.","keywords":["Java"],"articleBody":"Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。\n// ThreadDemo.java static int v = 0; static void autoAdd(){ for (int i = 0; i \u003c 10000; i++) { v++; } } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); System.out.println(v); } 上面代码变量 v 的打印结果可能会小于 20000，随着 v 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。\n要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。\n局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。\n虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。\nThreadLocal 的使用 ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。\nThreadLocal\u003cInteger\u003e threadLocal = new ThreadLocal\u003c\u003e(); System.out.println(threadLocal.get()); 我们使用 new 创建的 ThreadLocal 本身是一个对象，如果要获取数据的话，需要调用 get() 方法，上面的代码会得到一个 null，正确的使用方法应当重写 initialValue() 方法，来创建我们需要的初始化值。\nstatic ThreadLocal\u003cInteger\u003e threadLocal = new ThreadLocal\u003cInteger\u003e() { @Override protected Integer initialValue() { return 0; } }; static void autoAdd() { for (int i = 0; i \u003c 10000; i++) { int v = threadLocal.get(); threadLocal.set(v + 1); } System.out.println(Thread.currentThread().getName() + \" --\u003e \" + threadLocal.get()); } public static void main(String[] args) throws Exception { new Thread(ThreadLocalDemo::autoAdd).start(); autoAdd(); Thread.sleep(1000); } 上面的代码执行结果将会如下\nThread-0 --\u003e 10000 main --\u003e 10000 可以看到两个线程获取到的值都是独享的，彼此间不会相互干扰，因为破坏了同一资源这一要素，因此也不需要考虑线程安全的问题。\nThreadLocal 如何存储各个线程独享的数据 我们知道，变量所存储的是引用，那么简单地通过变量来实现线程独占是比较困难的，如果我们能理解在 ThreadLocal 是用什么结构来存储这些数据，那么就能理解它是怎么做到线程独享的。\npublic T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } 我们使用 ThreadLocal 是通过 get() 方法来获取独享的值的，这个方法会先获取当前线程的 Thread 对象，再根据当前线程去获取一个 ThreadLocalMap，这是一个结构类似于 Java Map 的类，但它并没有实现 Map 接口。\n利用 IDEA 整理一下相关的类可以得到下面的类图\nJava 中每个 Thread 都有一个 ThreadLocalMap 类型的成员变量 threadLocals，这个变量默认为 null。当 ThreadLocal 调用 getMap(Thread t) 的时候，其实只是获取对应 Thread 中的这个 threadLocals，并没有什么复杂的操作。\n// Thread.java ThreadLocal.ThreadLocalMap threadLocals = null; // ThreadLocal.java ThreadLocalMap getMap(Thread t) { return t.threadLocals; } 而 ThreadLocalMap 和 HashMap 类似，都用一个 Entry 数组作为哈希表来存储元素，每一个 Entry 代表一个键值对元素，其中 Entry 的成员变量 value 就是各个线程独享的值，而对应的 key，是一个 ThreadLocal 对象，它使用 WeakReference 来存储。\n按照注释说明，之所以使用 WeakReference 来引用键，是因为方便处理比较大又需要长时间使用的空间。\n/** * To help deal with very large and long-lived usages, * the hash table entries use WeakReferences for keys. */ static class ThreadLocalMap { static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } private Entry[] table; // ... } 到这里可以整理出一个关系链，Thread 中有一个 ThreadLocalMap 成员 threadLocals，它存储各个 ThreadLocal 对应的值，由于不同的线程的 threadLocals 不同，因此相同的 ThreadLocal 在不同线程中获取到的值是不同的，这就是 ThreadLocal 中的值线程独享的原理。\nThreadLocal 的初始化 前面提到 ThreadLocal 的使用需要重写 initialValue() 方法，这是因为并没有办法在创建 ThreadLocal 变量时直接为它赋值一个初始值。\n当调用 get() 方法时，当前线程的 threadLocals 为 null，或者在 threadLocals 中获取不到当前 ThreadLocal 对应的值时，则会调用 setInitialValue() 方法来设置初始值存储到 threadLocals 中，而这个初始值就是通过 initialValue() 方法生成的，如果不重写该方法，默认得到的初始值将会是 null。\nprivate T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } // 初始化值 protected T initialValue() { return null; } 由于线程中的 threadLocals 默认为 null，因此这一步如果得到的 ThreadLocalMap 为 null 的话则会调用 createMap() 方法来创建一个 ThreadLocalMap 对象，并提供第一个元素的 key 和 value 给 ThreadLocalMap。\nvoid createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } ThreadLocalMap(ThreadLocal\u003c?\u003e firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode \u0026 (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } ThreadLocal 修改数据 修改 ThreadLocal 中的值可以像上面的例子一样使用 set(T value) 方法，当调用 set() 方法时，如果 threadLocals 还没创建则调用 createMap() 创建并存储新值，否则调用 ThreadLocalMap.set(ThreadLocal\u003c?\u003e key, Object value)。\npublic void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } 需要注意的是，set() 方法并不能用来代替 initialValue() 来对 ThreadLocal 的值进行初始化。因为这需要在每个线程的第一次使用 ThreadLocal 之前都调用一次 set，这会很麻烦。\n另外即便使用了 ThreadLocal，对应的值依旧是一个对象，存放在堆内存中。也就是任何线程其实都有访问该对象的权限。当我们在不同线程调用 set() 存放一个相同的对象时，那么 ThreadLocal 将失去线程独享的副本。\nstatic class Demo { int v = 0; } static ThreadLocal\u003cDemo\u003e threadLocal = new ThreadLocal\u003cDemo\u003e() { @Override protected Demo initialValue() { return new Demo(); } }; public static void main(String[] args) throws Exception { Demo demo = threadLocal.get(); new Thread(() -\u003e { threadLocal.set(demo); threadLocal.get().v = 100; }).start(); Thread.sleep(100); System.out.println(threadLocal.get().v); // 100 } 执行上面代码的输出结果将会是 100。这很好理解，因为两个线程中 ThreadLocal 对应的 value 是同一个对象，因此其中一个线程的修改操作将会影响到其它线程。\nThreadLocalMap 的一些细节 ThreadLocalMap 和 HashMap 不同，获取 Entry 下标使用的不是 ThreadLocal 对象的 hashCode，而是 threadLocalHashCode。\n// ThreadLocalMap 中获取对应 Entry 下标 // key 是一个 ThreadLocal 对象 int i = key.threadLocalHashCode \u0026 (table.length - 1); 这个值由 ThreadLocal 一个 AtomicInteger 类型的静态成员 nextHashCode 的 getAndAdd() 方法生成。\n// ThreadLocal private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } 另外，哈希表可能会发生哈希冲突，ThreadLocalMap 处理哈希冲突采用的是闭散列，没有采用哈希桶可能是我们代码中的 ThreadLocal 并不会很多，发生冲突的概率比较小。\nprivate void set(ThreadLocal\u003c?\u003e key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode \u0026 (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal\u003c?\u003e k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) \u0026\u0026 sz \u003e= threshold) rehash(); } 内存溢出问题 static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } 内存溢出是使用 ThreadLocal 需要注意的一个问题，但使用 ThreadLocal 时发生内存泄露的不是 ThreadLocal 对象，而是存储在 Entry 中对应的 value。\nThreadLocal 对象并不会发生内存泄露，当我们将 ThreadLocal 引用置为 null 时，由于在 Thread 中的 ThreadLocalMap 中的 Entry，对 ThreadLocal 是一个弱引用，因此发生 GC 时就会被回收。\n所以在 ThreadLocalMap 中可能存在 key 为 null 的 Entry，但由于这个 Entry 以及存储的 value 本身是一个强引用，因此不会被回收，这才发生了内存泄露。\n其实 ThreadLocalMap 的生命周期线程相同，当线程运行结束，线程将会被销毁，那么 ThreadLocalMap 对象、存储的 Entry 对象以及 value 引用的对象也会被回收。\n但如果使用的是线程池，线程执行完任务并不会被销毁，而是放回线程池，那么对应的 value 会一直存在，这才发生了内存泄露。\nThreadLocal 提供了 remove() 方法，可将当前线程对应 ThreadLocal 的 Entry 中 WeakReference 对 ThreadLocal 的引用和 value 对 Object 的引用都设置为 null，同时移除该 Entry 对象。\n当 ThreadLocal 使用完后，在将引用设置为 null 前，应当调用 remove() 来防止内存泄露。\n// ThreadLocal public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } // ThreadLocalMap private void remove(ThreadLocal\u003c?\u003e key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode \u0026 (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // ... } // WeakReference --\u003e Reference public void clear() { this.referent = null; } ThreadLocal 使用小技巧 ThreadLocal 尽量声明为静态 对于一个 ThreadLocal 变量而言应当声明为静态的，因为每个线程访问该变量时应该是同一个 ThreadLocal 对象，如果不声明为静态的话，需要创建对应 ThreadLocal 所在类的对象来使用它，如果我们创建多个对象将会拥有多个相同作用的 ThreadLocal，这只是在增加内存的消耗。\nwithInitial() 配合 Lambda 表达式 定义 ThreadLocal 初始化也可以通过调用 withInitial() 方法传入 Supplier 对象来实现，Supplier 是一个接口，需要重写的方法只有 get()，因此我们可以配合 Lambda 表达式或者 Method Reference 来使用。\nstatic ThreadLocal\u003cInteger\u003e threadLocal1 = ThreadLocal.withInitial(() -\u003e 0); static ThreadLocal\u003cDemo\u003e threadLocal2 = ThreadLocal.withInitial(Demo::new); withInitial() 方法会返回一个 SuppliedThreadLocal 对象，SuppliedThreadLocal 的大部分功能继承自 ThreadLocal，但它帮我们重写了 initialValue() 方法，通过调用传入的 Supplier 对象的 get() 方法来获取初始化值。\npublic static \u003cS\u003e ThreadLocal\u003cS\u003e withInitial(Supplier\u003c? extends S\u003e supplier) { return new SuppliedThreadLocal\u003c\u003e(supplier); } static final class SuppliedThreadLocal\u003cT\u003e extends ThreadLocal\u003cT\u003e { private final Supplier\u003c? extends T\u003e supplier; SuppliedThreadLocal(Supplier\u003c? extends T\u003e supplier) { this.supplier = Objects.requireNonNull(supplier); } @Override protected T initialValue() { return supplier.get(); } } 参考 理解Java中的ThreadLocal Red Rose - ThreadLocal 内存泄漏问题深入分析 ","wordCount":"1026","inLanguage":"en","datePublished":"2021-09-03T00:00:00Z","dateModified":"2021-09-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://answerkobe.github.io/posts/threadlocal-usage-and-source/readme/"},"publisher":{"@type":"Organization","name":"Iverson's blog","logo":{"@type":"ImageObject","url":"http://answerkobe.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://answerkobe.github.io/ accesskey=h title="Iverson's blog (Alt + H)">Iverson's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://answerkobe.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=http://answerkobe.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=http://answerkobe.github.io/profile title=Profile-X><span>Profile-X</span></a></li><li><a href=http://answerkobe.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://answerkobe.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://answerkobe.github.io/posts/>Posts</a></div><h1 class=post-title>从源码角度分析 ThreadLocal 的使用</h1><div class=post-meta><span title='2021-09-03 00:00:00 +0000 UTC'>September 3, 2021</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#threadlocal-%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label="ThreadLocal 的使用">ThreadLocal 的使用</a></li><li><a href=#threadlocal-%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8%e5%90%84%e4%b8%aa%e7%ba%bf%e7%a8%8b%e7%8b%ac%e4%ba%ab%e7%9a%84%e6%95%b0%e6%8d%ae aria-label="ThreadLocal 如何存储各个线程独享的数据">ThreadLocal 如何存储各个线程独享的数据</a></li><li><a href=#threadlocal-%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label="ThreadLocal 的初始化">ThreadLocal 的初始化</a></li><li><a href=#threadlocal-%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae aria-label="ThreadLocal 修改数据">ThreadLocal 修改数据</a></li><li><a href=#threadlocalmap-%e7%9a%84%e4%b8%80%e4%ba%9b%e7%bb%86%e8%8a%82 aria-label="ThreadLocalMap 的一些细节">ThreadLocalMap 的一些细节</a></li><li><a href=#%e5%86%85%e5%ad%98%e6%ba%a2%e5%87%ba%e9%97%ae%e9%a2%98 aria-label=内存溢出问题>内存溢出问题</a></li><li><a href=#threadlocal-%e4%bd%bf%e7%94%a8%e5%b0%8f%e6%8a%80%e5%b7%a7 aria-label="ThreadLocal 使用小技巧">ThreadLocal 使用小技巧</a><ul><ul><li><a href=#threadlocal-%e5%b0%bd%e9%87%8f%e5%a3%b0%e6%98%8e%e4%b8%ba%e9%9d%99%e6%80%81 aria-label="ThreadLocal 尽量声明为静态">ThreadLocal 尽量声明为静态</a></li><li><a href=#withinitial-%e9%85%8d%e5%90%88-lambda-%e8%a1%a8%e8%be%be%e5%bc%8f aria-label="withInitial() 配合 Lambda 表达式">withInitial() 配合 Lambda 表达式</a></li></ul></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>Java 中的创建的对象存放在堆内存，这一块空间是线程共享的，通常我们定义的变量所持有的是对象的引用存，即每个线程访问该变量时都将获取到堆内存中的同一个对象，因此在使用多线程的时候如果需要操作同一资源，那么需要思考线程安全的问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>// ThreadDemo.java</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>autoAdd</span>(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10000; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        v<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> Thread(ThreadLocalDemo::autoAdd).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    autoAdd();
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>sleep</span>(1000);
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(v);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面代码变量 <code>v</code> 的打印结果可能会小于 20000，随着 <code>v</code> 自增次数的增加，例如循环次数增加到 100000，这个问题将会更加明显。</p><p>要解决线程安全的问题可以用同步或加锁的方式来处理，但有时候我们希望的该变量对于每个线程来说是独享的，也就是对于同一个变量，它的值对于不同线程都应该有一份单独的副本。</p><p>局部变量对于 Java 开发者而言应该是再熟悉不过的了。不同线程操作一个共享的变量时，我们可以创建一个新的局部变量来复制该变量的值，再进行操作，这样就不会污染到该共享变量的值。但对于复杂的对象而言，复制起来比较麻烦，而且这种方式也不能将操作完的值写回共享的变量。</p><p>虽然我们有办法解决这些问题，但没必要，因为 Java 提供了 ThreadLocal 来帮助我们创建一个线程局部的变量。</p><h2 id=threadlocal-的使用>ThreadLocal 的使用<a hidden class=anchor aria-hidden=true href=#threadlocal-的使用>#</a></h2><p>ThreadLocal 的使用利用了泛型，我们可以将期望的值放到 ThreadLocal 中，使用 ThreadLocal 时通过指定泛型类型来决定该 ThreadLocal 存放的数据的类型，这是集合类一样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>ThreadLocal<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> threadLocal <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadLocal<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(threadLocal.<span style=color:#a6e22e>get</span>());
</span></span></code></pre></div><p>我们使用 new 创建的 ThreadLocal 本身是一个对象，如果要获取数据的话，需要调用 <code>get()</code> 方法，上面的代码会得到一个 <code>null</code>，正确的使用方法应当重写 <code>initialValue()</code> 方法，来创建我们需要的初始化值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>static</span> ThreadLocal<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> threadLocal <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadLocal<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> Integer <span style=color:#a6e22e>initialValue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>autoAdd</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 10000; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> threadLocal.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        threadLocal.<span style=color:#a6e22e>set</span>(v <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; --&gt; &#34;</span> <span style=color:#f92672>+</span> threadLocal.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> Thread(ThreadLocalDemo::autoAdd).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    autoAdd();
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>sleep</span>(1000);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码执行结果将会如下</p><pre tabindex=0><code>Thread-0 --&gt; 10000
main --&gt; 10000
</code></pre><p>可以看到两个线程获取到的值都是独享的，彼此间不会相互干扰，因为破坏了同一资源这一要素，因此也不需要考虑线程安全的问题。</p><h2 id=threadlocal-如何存储各个线程独享的数据>ThreadLocal 如何存储各个线程独享的数据<a hidden class=anchor aria-hidden=true href=#threadlocal-如何存储各个线程独享的数据>#</a></h2><p>我们知道，变量所存储的是引用，那么简单地通过变量来实现线程独占是比较困难的，如果我们能理解在 ThreadLocal 是用什么结构来存储这些数据，那么就能理解它是怎么做到线程独享的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> T <span style=color:#a6e22e>get</span>() {
</span></span><span style=display:flex><span>    Thread t <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>();
</span></span><span style=display:flex><span>    ThreadLocalMap map <span style=color:#f92672>=</span> getMap(t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (map <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        ThreadLocalMap.<span style=color:#a6e22e>Entry</span> e <span style=color:#f92672>=</span> map.<span style=color:#a6e22e>getEntry</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;unchecked&#34;</span>)
</span></span><span style=display:flex><span>            T result <span style=color:#f92672>=</span> (T)e.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> setInitialValue();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们使用 ThreadLocal 是通过 <code>get()</code> 方法来获取独享的值的，这个方法会先获取当前线程的 Thread 对象，再根据当前线程去获取一个 ThreadLocalMap，这是一个结构类似于 Java Map 的类，但它并没有实现 Map 接口。</p><p>利用 IDEA 整理一下相关的类可以得到下面的类图</p><p><img loading=lazy src=./ThreadLocalDiagram.png alt></p><p>Java 中每个 Thread 都有一个 ThreadLocalMap 类型的成员变量 <code>threadLocals</code>，这个变量默认为 <code>null</code>。当 ThreadLocal 调用 <code>getMap(Thread t)</code> 的时候，其实只是获取对应 Thread 中的这个 <code>threadLocals</code>，并没有什么复杂的操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>// Thread.java</span>
</span></span><span style=display:flex><span>ThreadLocal.<span style=color:#a6e22e>ThreadLocalMap</span> threadLocals <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ThreadLocal.java</span>
</span></span><span style=display:flex><span>ThreadLocalMap <span style=color:#a6e22e>getMap</span>(Thread t) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> t.<span style=color:#a6e22e>threadLocals</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而 ThreadLocalMap 和 HashMap 类似，都用一个 Entry 数组作为哈希表来存储元素，每一个 Entry 代表一个键值对元素，其中 Entry 的成员变量 value 就是各个线程独享的值，而对应的 key，是一个 ThreadLocal 对象，它使用 WeakReference 来存储。</p><p>按照注释说明，之所以使用 WeakReference 来引用键，是因为方便处理比较大又需要长时间使用的空间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * To help deal with very large and long-lived usages, 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * the hash table entries use WeakReferences for keys.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ThreadLocalMap</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Entry</span> <span style=color:#66d9ef>extends</span> WeakReference<span style=color:#f92672>&lt;</span>ThreadLocal<span style=color:#f92672>&lt;?&gt;&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/** The value associated with this ThreadLocal. */</span>
</span></span><span style=display:flex><span>            Object value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Entry(ThreadLocal<span style=color:#f92672>&lt;?&gt;</span> k, Object v) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>super</span>(k);
</span></span><span style=display:flex><span>                value <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> Entry<span style=color:#f92672>[]</span> table;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到这里可以整理出一个关系链，Thread 中有一个 ThreadLocalMap 成员 <code>threadLocals</code>，它存储各个 ThreadLocal 对应的值，由于不同的线程的 <code>threadLocals</code> 不同，因此相同的 ThreadLocal 在不同线程中获取到的值是不同的，这就是 ThreadLocal 中的值线程独享的原理。</p><p><img loading=lazy src=./ThreadLocalGet.jpg alt></p><h2 id=threadlocal-的初始化>ThreadLocal 的初始化<a hidden class=anchor aria-hidden=true href=#threadlocal-的初始化>#</a></h2><p>前面提到 ThreadLocal 的使用需要重写 <code>initialValue()</code> 方法，这是因为并没有办法在创建 ThreadLocal 变量时直接为它赋值一个初始值。</p><p>当调用 <code>get()</code> 方法时，当前线程的 <code>threadLocals</code> 为 <code>null</code>，或者在 <code>threadLocals</code> 中获取不到当前 ThreadLocal 对应的值时，则会调用 <code>setInitialValue()</code> 方法来设置初始值存储到 <code>threadLocals</code> 中，而这个初始值就是通过 <code>initialValue()</code> 方法生成的，如果不重写该方法，默认得到的初始值将会是 <code>null</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> T <span style=color:#a6e22e>setInitialValue</span>() {
</span></span><span style=display:flex><span>    T value <span style=color:#f92672>=</span> initialValue();
</span></span><span style=display:flex><span>    Thread t <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>();
</span></span><span style=display:flex><span>    ThreadLocalMap map <span style=color:#f92672>=</span> getMap(t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (map <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>this</span>, value);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        createMap(t, value);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> value;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 初始化值</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> T <span style=color:#a6e22e>initialValue</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于线程中的 <code>threadLocals</code> 默认为 <code>null</code>，因此这一步如果得到的 ThreadLocalMap 为 <code>null</code> 的话则会调用 <code>createMap()</code> 方法来创建一个 ThreadLocalMap 对象，并提供第一个元素的 key 和 value 给 ThreadLocalMap。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>createMap</span>(Thread t, T firstValue) {
</span></span><span style=display:flex><span>    t.<span style=color:#a6e22e>threadLocals</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadLocalMap(<span style=color:#66d9ef>this</span>, firstValue);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ThreadLocalMap(ThreadLocal<span style=color:#f92672>&lt;?&gt;</span> firstKey, Object firstValue) {
</span></span><span style=display:flex><span>    table <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Entry<span style=color:#f92672>[</span>INITIAL_CAPACITY<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> firstKey.<span style=color:#a6e22e>threadLocalHashCode</span> <span style=color:#f92672>&amp;</span> (INITIAL_CAPACITY <span style=color:#f92672>-</span> 1);
</span></span><span style=display:flex><span>    table<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Entry(firstKey, firstValue);
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>    setThreshold(INITIAL_CAPACITY);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=threadlocal-修改数据>ThreadLocal 修改数据<a hidden class=anchor aria-hidden=true href=#threadlocal-修改数据>#</a></h2><p>修改 ThreadLocal 中的值可以像上面的例子一样使用 <code>set(T value)</code> 方法，当调用 <code>set()</code> 方法时，如果 <code>threadLocals</code> 还没创建则调用 <code>createMap()</code> 创建并存储新值，否则调用 <code>ThreadLocalMap.set(ThreadLocal&lt;?> key, Object value)</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(T value) {
</span></span><span style=display:flex><span>    Thread t <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>();
</span></span><span style=display:flex><span>    ThreadLocalMap map <span style=color:#f92672>=</span> getMap(t);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (map <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        map.<span style=color:#a6e22e>set</span>(<span style=color:#66d9ef>this</span>, value);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        createMap(t, value);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>需要注意的是，<code>set()</code> 方法并不能用来代替 <code>initialValue()</code> 来对 ThreadLocal 的值进行初始化。因为这需要在每个线程的第一次使用 ThreadLocal 之前都调用一次 set，这会很麻烦。</p><p>另外即便使用了 ThreadLocal，对应的值依旧是一个对象，存放在堆内存中。也就是任何线程其实都有访问该对象的权限。当我们在不同线程调用 <code>set()</code> 存放一个相同的对象时，那么 ThreadLocal 将失去线程独享的副本。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Demo</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> ThreadLocal<span style=color:#f92672>&lt;</span>Demo<span style=color:#f92672>&gt;</span> threadLocal <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadLocal<span style=color:#f92672>&lt;</span>Demo<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> Demo <span style=color:#a6e22e>initialValue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Demo();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>    Demo demo <span style=color:#f92672>=</span> threadLocal.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        threadLocal.<span style=color:#a6e22e>set</span>(demo);
</span></span><span style=display:flex><span>        threadLocal.<span style=color:#a6e22e>get</span>().<span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> 100;
</span></span><span style=display:flex><span>    }).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>sleep</span>(100);
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(threadLocal.<span style=color:#a6e22e>get</span>().<span style=color:#a6e22e>v</span>); <span style=color:#75715e>// 100</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行上面代码的输出结果将会是 100。这很好理解，因为两个线程中 ThreadLocal 对应的 value 是同一个对象，因此其中一个线程的修改操作将会影响到其它线程。</p><h2 id=threadlocalmap-的一些细节>ThreadLocalMap 的一些细节<a hidden class=anchor aria-hidden=true href=#threadlocalmap-的一些细节>#</a></h2><p>ThreadLocalMap 和 HashMap 不同，获取 Entry 下标使用的不是 ThreadLocal 对象的 <code>hashCode</code>，而是 <code>threadLocalHashCode</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>// ThreadLocalMap 中获取对应 Entry 下标</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// key 是一个 ThreadLocal 对象</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> key.<span style=color:#a6e22e>threadLocalHashCode</span> <span style=color:#f92672>&amp;</span> (table.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1);
</span></span></code></pre></div><p>这个值由 ThreadLocal 一个 AtomicInteger 类型的静态成员 <code>nextHashCode</code> 的 <code>getAndAdd()</code> 方法生成。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>// ThreadLocal</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> threadLocalHashCode <span style=color:#f92672>=</span> nextHashCode();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> AtomicInteger nextHashCode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicInteger();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> HASH_INCREMENT <span style=color:#f92672>=</span> 0x61c88647;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>nextHashCode</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> nextHashCode.<span style=color:#a6e22e>getAndAdd</span>(HASH_INCREMENT);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>另外，哈希表可能会发生哈希冲突，ThreadLocalMap 处理哈希冲突采用的是闭散列，没有采用哈希桶可能是我们代码中的 ThreadLocal 并不会很多，发生冲突的概率比较小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set</span>(ThreadLocal<span style=color:#f92672>&lt;?&gt;</span> key, Object value) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Entry<span style=color:#f92672>[]</span> tab <span style=color:#f92672>=</span> table;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> key.<span style=color:#a6e22e>threadLocalHashCode</span> <span style=color:#f92672>&amp;</span> (len<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Entry e <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            e <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>i <span style=color:#f92672>=</span> nextIndex(i, len)<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>        ThreadLocal<span style=color:#f92672>&lt;?&gt;</span> k <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>==</span> key) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            replaceStaleEntry(key, value, i);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    tab<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Entry(key, value);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sz <span style=color:#f92672>=</span> <span style=color:#f92672>++</span>size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>cleanSomeSlots(i, sz) <span style=color:#f92672>&amp;&amp;</span> sz <span style=color:#f92672>&gt;=</span> threshold)
</span></span><span style=display:flex><span>        rehash();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=内存溢出问题>内存溢出问题<a hidden class=anchor aria-hidden=true href=#内存溢出问题>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Entry</span> <span style=color:#66d9ef>extends</span> WeakReference<span style=color:#f92672>&lt;</span>ThreadLocal<span style=color:#f92672>&lt;?&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** The value associated with this ThreadLocal. */</span>
</span></span><span style=display:flex><span>    Object value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Entry(ThreadLocal<span style=color:#f92672>&lt;?&gt;</span> k, Object v) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(k);
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>内存溢出是使用 ThreadLocal 需要注意的一个问题，但使用 ThreadLocal 时发生内存泄露的不是 ThreadLocal 对象，而是存储在 Entry 中对应的 value。</p><p>ThreadLocal 对象并不会发生内存泄露，当我们将 ThreadLocal 引用置为 <code>null</code> 时，由于在 Thread 中的 ThreadLocalMap 中的 Entry，对 ThreadLocal 是一个弱引用，因此发生 GC 时就会被回收。</p><p>所以在 ThreadLocalMap 中可能存在 key 为 <code>null</code> 的 Entry，但由于这个 Entry 以及存储的 value 本身是一个强引用，因此不会被回收，这才发生了内存泄露。</p><p><img loading=lazy src=./MemoryLeak.jpg alt></p><p>其实 ThreadLocalMap 的生命周期线程相同，当线程运行结束，线程将会被销毁，那么 ThreadLocalMap 对象、存储的 Entry 对象以及 value 引用的对象也会被回收。</p><p>但如果使用的是线程池，线程执行完任务并不会被销毁，而是放回线程池，那么对应的 value 会一直存在，这才发生了内存泄露。</p><p>ThreadLocal 提供了 <code>remove()</code> 方法，可将当前线程对应 ThreadLocal 的 Entry 中 WeakReference 对 ThreadLocal 的引用和 value 对 Object 的引用都设置为 <code>null</code>，同时移除该 Entry 对象。</p><p>当 ThreadLocal 使用完后，在将引用设置为 null 前，应当调用 <code>remove()</code> 来防止内存泄露。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#75715e>// ThreadLocal</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove</span>() {
</span></span><span style=display:flex><span>    ThreadLocalMap m <span style=color:#f92672>=</span> getMap(Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        m.<span style=color:#a6e22e>remove</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ThreadLocalMap</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>remove</span>(ThreadLocal<span style=color:#f92672>&lt;?&gt;</span> key) {
</span></span><span style=display:flex><span>    Entry<span style=color:#f92672>[]</span> tab <span style=color:#f92672>=</span> table;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> key.<span style=color:#a6e22e>threadLocalHashCode</span> <span style=color:#f92672>&amp;</span> (len<span style=color:#f92672>-</span>1);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (Entry e <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            e <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>i <span style=color:#f92672>=</span> nextIndex(i, len)<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (e.<span style=color:#a6e22e>get</span>() <span style=color:#f92672>==</span> key) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>            expungeStaleEntry(i);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>expungeStaleEntry</span>(<span style=color:#66d9ef>int</span> staleSlot) {
</span></span><span style=display:flex><span>    Entry<span style=color:#f92672>[]</span> tab <span style=color:#f92672>=</span> table;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> tab.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// expunge entry at staleSlot</span>
</span></span><span style=display:flex><span>    tab<span style=color:#f92672>[</span>staleSlot<span style=color:#f92672>]</span>.<span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    tab<span style=color:#f92672>[</span>staleSlot<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    size<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// WeakReference --&gt; Reference</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>clear</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>referent</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=threadlocal-使用小技巧>ThreadLocal 使用小技巧<a hidden class=anchor aria-hidden=true href=#threadlocal-使用小技巧>#</a></h2><h4 id=threadlocal-尽量声明为静态>ThreadLocal 尽量声明为静态<a hidden class=anchor aria-hidden=true href=#threadlocal-尽量声明为静态>#</a></h4><p>对于一个 ThreadLocal 变量而言应当声明为静态的，因为每个线程访问该变量时应该是同一个 ThreadLocal 对象，如果不声明为静态的话，需要创建对应 ThreadLocal 所在类的对象来使用它，如果我们创建多个对象将会拥有多个相同作用的 ThreadLocal，这只是在增加内存的消耗。</p><h4 id=withinitial-配合-lambda-表达式>withInitial() 配合 Lambda 表达式<a hidden class=anchor aria-hidden=true href=#withinitial-配合-lambda-表达式>#</a></h4><p>定义 ThreadLocal 初始化也可以通过调用 <code>withInitial()</code> 方法传入 Supplier 对象来实现，Supplier 是一个接口，需要重写的方法只有 <code>get()</code>，因此我们可以配合 Lambda 表达式或者 Method Reference 来使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>static</span> ThreadLocal<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> threadLocal1 <span style=color:#f92672>=</span> ThreadLocal.<span style=color:#a6e22e>withInitial</span>(() <span style=color:#f92672>-&gt;</span> 0);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> ThreadLocal<span style=color:#f92672>&lt;</span>Demo<span style=color:#f92672>&gt;</span> threadLocal2 <span style=color:#f92672>=</span> ThreadLocal.<span style=color:#a6e22e>withInitial</span>(Demo::<span style=color:#66d9ef>new</span>);
</span></span></code></pre></div><p><code>withInitial()</code> 方法会返回一个 SuppliedThreadLocal 对象，SuppliedThreadLocal 的大部分功能继承自 ThreadLocal，但它帮我们重写了 <code>initialValue()</code> 方法，通过调用传入的 Supplier 对象的 <code>get()</code> 方法来获取初始化值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span> ThreadLocal<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>withInitial</span>(Supplier<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> S<span style=color:#f92672>&gt;</span> supplier) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> SuppliedThreadLocal<span style=color:#f92672>&lt;&gt;</span>(supplier);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SuppliedThreadLocal</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> ThreadLocal<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Supplier<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;</span> supplier;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SuppliedThreadLocal(Supplier<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;</span> supplier) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>supplier</span> <span style=color:#f92672>=</span> Objects.<span style=color:#a6e22e>requireNonNull</span>(supplier);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> T <span style=color:#a6e22e>initialValue</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> supplier.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://www.cnblogs.com/tkzL/p/12926797.html>理解Java中的ThreadLocal</a></li><li><a href=https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/>Red Rose - ThreadLocal 内存泄漏问题深入分析</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://answerkobe.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=http://answerkobe.github.io/posts/explore-the-kotlin-generics/><span class=title>« Prev</span><br><span>探索 Java & Kotlin 泛型</span>
</a><a class=next href=http://answerkobe.github.io/posts/the-principle-of-hashmap/><span class=title>Next »</span><br><span>基于 JDK 1.8 分析 HashMap 的底层原理</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 从源码角度分析 ThreadLocal 的使用 on x" href="https://x.com/intent/tweet/?text=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%88%86%e6%9e%90%20ThreadLocal%20%e7%9a%84%e4%bd%bf%e7%94%a8&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthreadlocal-usage-and-source%2freadme%2f&amp;hashtags=Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从源码角度分析 ThreadLocal 的使用 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthreadlocal-usage-and-source%2freadme%2f&amp;title=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%88%86%e6%9e%90%20ThreadLocal%20%e7%9a%84%e4%bd%bf%e7%94%a8&amp;summary=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%88%86%e6%9e%90%20ThreadLocal%20%e7%9a%84%e4%bd%bf%e7%94%a8&amp;source=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthreadlocal-usage-and-source%2freadme%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从源码角度分析 ThreadLocal 的使用 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthreadlocal-usage-and-source%2freadme%2f&title=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%88%86%e6%9e%90%20ThreadLocal%20%e7%9a%84%e4%bd%bf%e7%94%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从源码角度分析 ThreadLocal 的使用 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthreadlocal-usage-and-source%2freadme%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从源码角度分析 ThreadLocal 的使用 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%88%86%e6%9e%90%20ThreadLocal%20%e7%9a%84%e4%bd%bf%e7%94%a8%20-%20http%3a%2f%2fanswerkobe.github.io%2fposts%2fthreadlocal-usage-and-source%2freadme%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从源码角度分析 ThreadLocal 的使用 on telegram" href="https://telegram.me/share/url?text=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%88%86%e6%9e%90%20ThreadLocal%20%e7%9a%84%e4%bd%bf%e7%94%a8&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthreadlocal-usage-and-source%2freadme%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从源码角度分析 ThreadLocal 的使用 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e4%bb%8e%e6%ba%90%e7%a0%81%e8%a7%92%e5%ba%a6%e5%88%86%e6%9e%90%20ThreadLocal%20%e7%9a%84%e4%bd%bf%e7%94%a8&u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fthreadlocal-usage-and-source%2freadme%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script id=utteranc src=https://utteranc.es/client.js repo=Answerkobe/utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.body.className.includes("dark")?"github-light":"photon-dark",t={type:"set-theme",theme:e},n=document.querySelector(".utterances-frame");n.contentWindow.postMessage(t,"https://utteranc.es")})</script></article></main><footer class=footer><span>&copy; 2023 <a href=http://answerkobe.github.io/>Iverson's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>