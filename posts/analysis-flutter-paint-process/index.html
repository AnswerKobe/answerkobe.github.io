<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="upgrade-insecure-requests"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Flutter 绘制流程分析与代码实践 | Iverson's blog</title>
<meta name=keywords content="Flutter,Android"><meta name=description content="Render Tree 的创建过程 RenderObject 的类型 我们知道 Element 主要分为负责渲染的 RenderObjectElement 和负责组合的 ComponentElement 两大类，而创建 RenderObject 节点的是前者 mount() 方法中调用的 RenderObjectWidget.createRenderObject() 方法。
该方法是一个抽象方法，需要子类实现，对于不同的布局的 Widget 创建的 RenderObject 类型也不一样，在 Render Tree 中最主要的有两种 RenderObject：
首先是在 RenderObject 注释说明中大量提到了一个类 RenderBox，它是大部分的 RenderObjectWidget 所对应的 RenderObject 的抽象类 /// A render object in a 2D Cartesian coordinate system. /// 一个在 2D 坐标系中的渲染对象 abstract class RenderBox extends RenderObject 以及 Render Tree 的根节点 RenderView /// The root of the render tree. /// Render Tree 的根节点，处理渲染管道的引导和渲染树的输出 /// 它有一个填充整个输出表面的 RenderBox 类型的唯一子节点 class RenderView extends RenderObject with RenderObjectWithChildMixin<RenderBox> 其他的类型的 RenderObject 基本是为了特定布局（如滑动、列表）的实现，但大部分都直接或间接集成自 RenderBox。"><meta name=author content><link rel=canonical href=http://answerkobe.github.io/posts/analysis-flutter-paint-process/><link crossorigin=anonymous href=/assets/css/stylesheet.81e9c84b86321fe9cfdf9f01a2f8060920d09e0fec45cb91f131cfed0284007e.css integrity="sha256-genIS4YyH+nP358BovgGCSDQng/sRcuR8THP7QKEAH4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://answerkobe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://answerkobe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://answerkobe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://answerkobe.github.io/apple-touch-icon.png><link rel=mask-icon href=http://answerkobe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4112QEXZJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4112QEXZJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Flutter 绘制流程分析与代码实践"><meta property="og:description" content="Render Tree 的创建过程 RenderObject 的类型 我们知道 Element 主要分为负责渲染的 RenderObjectElement 和负责组合的 ComponentElement 两大类，而创建 RenderObject 节点的是前者 mount() 方法中调用的 RenderObjectWidget.createRenderObject() 方法。
该方法是一个抽象方法，需要子类实现，对于不同的布局的 Widget 创建的 RenderObject 类型也不一样，在 Render Tree 中最主要的有两种 RenderObject：
首先是在 RenderObject 注释说明中大量提到了一个类 RenderBox，它是大部分的 RenderObjectWidget 所对应的 RenderObject 的抽象类 /// A render object in a 2D Cartesian coordinate system. /// 一个在 2D 坐标系中的渲染对象 abstract class RenderBox extends RenderObject 以及 Render Tree 的根节点 RenderView /// The root of the render tree. /// Render Tree 的根节点，处理渲染管道的引导和渲染树的输出 /// 它有一个填充整个输出表面的 RenderBox 类型的唯一子节点 class RenderView extends RenderObject with RenderObjectWithChildMixin<RenderBox> 其他的类型的 RenderObject 基本是为了特定布局（如滑动、列表）的实现，但大部分都直接或间接集成自 RenderBox。"><meta property="og:type" content="article"><meta property="og:url" content="http://answerkobe.github.io/posts/analysis-flutter-paint-process/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-11T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-11T00:00:00+00:00"><meta property="og:site_name" content="Iverson"><meta name=twitter:card content="summary"><meta name=twitter:title content="Flutter 绘制流程分析与代码实践"><meta name=twitter:description content="Render Tree 的创建过程 RenderObject 的类型 我们知道 Element 主要分为负责渲染的 RenderObjectElement 和负责组合的 ComponentElement 两大类，而创建 RenderObject 节点的是前者 mount() 方法中调用的 RenderObjectWidget.createRenderObject() 方法。
该方法是一个抽象方法，需要子类实现，对于不同的布局的 Widget 创建的 RenderObject 类型也不一样，在 Render Tree 中最主要的有两种 RenderObject：
首先是在 RenderObject 注释说明中大量提到了一个类 RenderBox，它是大部分的 RenderObjectWidget 所对应的 RenderObject 的抽象类 /// A render object in a 2D Cartesian coordinate system. /// 一个在 2D 坐标系中的渲染对象 abstract class RenderBox extends RenderObject 以及 Render Tree 的根节点 RenderView /// The root of the render tree. /// Render Tree 的根节点，处理渲染管道的引导和渲染树的输出 /// 它有一个填充整个输出表面的 RenderBox 类型的唯一子节点 class RenderView extends RenderObject with RenderObjectWithChildMixin<RenderBox> 其他的类型的 RenderObject 基本是为了特定布局（如滑动、列表）的实现，但大部分都直接或间接集成自 RenderBox。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://answerkobe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Flutter 绘制流程分析与代码实践","item":"http://answerkobe.github.io/posts/analysis-flutter-paint-process/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Flutter 绘制流程分析与代码实践","name":"Flutter 绘制流程分析与代码实践","description":"Render Tree 的创建过程 RenderObject 的类型 我们知道 Element 主要分为负责渲染的 RenderObjectElement 和负责组合的 ComponentElement 两大类，而创建 RenderObject 节点的是前者 mount() 方法中调用的 RenderObjectWidget.createRenderObject() 方法。\n该方法是一个抽象方法，需要子类实现，对于不同的布局的 Widget 创建的 RenderObject 类型也不一样，在 Render Tree 中最主要的有两种 RenderObject：\n首先是在 RenderObject 注释说明中大量提到了一个类 RenderBox，它是大部分的 RenderObjectWidget 所对应的 RenderObject 的抽象类 /// A render object in a 2D Cartesian coordinate system. /// 一个在 2D 坐标系中的渲染对象 abstract class RenderBox extends RenderObject 以及 Render Tree 的根节点 RenderView /// The root of the render tree. /// Render Tree 的根节点，处理渲染管道的引导和渲染树的输出 /// 它有一个填充整个输出表面的 RenderBox 类型的唯一子节点 class RenderView extends RenderObject with RenderObjectWithChildMixin\u0026lt;RenderBox\u0026gt; 其他的类型的 RenderObject 基本是为了特定布局（如滑动、列表）的实现，但大部分都直接或间接集成自 RenderBox。","keywords":["Flutter","Android"],"articleBody":"Render Tree 的创建过程 RenderObject 的类型 我们知道 Element 主要分为负责渲染的 RenderObjectElement 和负责组合的 ComponentElement 两大类，而创建 RenderObject 节点的是前者 mount() 方法中调用的 RenderObjectWidget.createRenderObject() 方法。\n该方法是一个抽象方法，需要子类实现，对于不同的布局的 Widget 创建的 RenderObject 类型也不一样，在 Render Tree 中最主要的有两种 RenderObject：\n首先是在 RenderObject 注释说明中大量提到了一个类 RenderBox，它是大部分的 RenderObjectWidget 所对应的 RenderObject 的抽象类 /// A render object in a 2D Cartesian coordinate system. /// 一个在 2D 坐标系中的渲染对象 abstract class RenderBox extends RenderObject 以及 Render Tree 的根节点 RenderView /// The root of the render tree. /// Render Tree 的根节点，处理渲染管道的引导和渲染树的输出 /// 它有一个填充整个输出表面的 RenderBox 类型的唯一子节点 class RenderView extends RenderObject with RenderObjectWithChildMixin\u003cRenderBox\u003e 其他的类型的 RenderObject 基本是为了特定布局（如滑动、列表）的实现，但大部分都直接或间接集成自 RenderBox。\n通常一个 RenderBox 只有一个子节点（因为它只有一个 child 属性），这使得它整体更像是链表。 Flutter 提供了 ContainerRenderObjectMixin 用来给那些需要存储多个子节点的 RenderBox 进行扩展，多个子节点的组织方式也是采用链表来连接存储，下面列出常见的两种：\nRenderStack 实现了堆栈布局算法 RenderFlex 实现了 Flex 布局算法，Column 和 Row 都是属于 Flex 的变体 RenderView 如何创建 既然 Render Tree 的根节点是 RenderView，那么我们看 RenderView 是在哪被创建的。\n通过 IDE 的全局搜索我们可以找到对应的创建引用是在 RendererBinding 中。\n/// Flutter 引擎和 Render Tree 之间的一个绑定器 mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable 这个类建立了 Flutter Engine 和 Render Tree 之间的关联，注释中介绍，当 Binding 被创建的时候就会执行 initInstances() 进行初始化并创建 RenderView。\n/// RendererBinding @override void initInstances() { // ... 省略了 PipelineOwner 创建和 window 初始化代码 // 创建 RenderView initRenderView(); } /// Called automatically when the binding is created. void initRenderView() { // ... renderView = RenderView( configuration: createViewConfiguration(), window: window); // 初始化 RenderView renderView.prepareInitialFrame(); } 我们回到 Flutter App 启动时调用的函数 runApp。\nrunApp 会创建 WidgetsFlutterBinding，并执行 ensureInitialized() 方法。\nvoid runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() //初始化 ..scheduleAttachRootWidget(app) // 创建其他两棵树的根节点 ..scheduleWarmUpFrame(); } 而这个 WidgetsFlutterBinding 实际上由 7 个 mixin Binding 组合成，其中就包括了 RendererBinding，而调用这几个 mixin Binding 的 initInstances() 都是交给父类 BindingBase 在构造方法中执行。\n这种采用 mixin 组合 Binding 的设计可以方便后续接入新的 Binding。\nclass WidgetsFlutterBinding extends BindingBase with GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance!; } } abstract class BindingBase { /// Default abstract constructor for bindings. /// /// First calls [initInstances] to have bindings initialize their /// instance pointers and other state, then calls /// [initServiceExtensions] to have bindings initialize their /// observatory service extensions, if any. BindingBase() { initInstances(); initServiceExtensions(); developer.postEvent('Flutter.FrameworkInitialization', \u003cString, String\u003e{}); developer.Timeline.finishSync(); } } 三棵树的初始化关联 在ensureInitialized() 方法执行完成得到 Render Tree 根节点之后，就是调用 scheduleAttachRootWidget() 创建其他两棵树的根节点，然后和 Render Tree 进行关联。\n@protected void scheduleAttachRootWidget(Widget rootWidget) { Timer.run(() { attachRootWidget(rootWidget); }); } void attachRootWidget(Widget rootWidget) { final bool isBootstrapFrame = renderViewElement == null; _readyToProduceFrames = true; _renderViewElement = RenderObjectToWidgetAdapter\u003cRenderBox\u003e( container: renderView, debugShortDescription: '[root]', child: rootWidget, ).attachToRenderTree( buildOwner!, renderViewElement as RenderObjectToWidgetElement\u003cRenderBox\u003e? ); if (isBootstrapFrame) { SchedulerBinding.instance!.ensureVisualUpdate(); } } 在这里attachRootWidget() 创建了 RenderObjectToWidgetAdapter，它的本质其实是 RenderObjectWidget，我们可以看到它声明了对应的 Render Tree 的节点类型为 RenderBox，并且指定了该 RenderBox 的父节点是 RenderView。\n最后调用 attachToRenderTree() 将 RenderObjectToWidgetAdapter 转化为 RootRenderObjectElement 并和 Render Tree 进行绑定。\nPipelineOwner 渲染管道管理 目前的 Render Tree 只是一个数据结构，并没有渲染操作。因此我们来研究一下从 Render Tree 到界面是一个什么样的过程。\n刚刚提到了 RenderBinding 建立了 Flutter Engine 和 Render Tree 之间的关联，在创建 RenderView 的过程中，我们可以注意到它还创建了一个 PipelineOwner 的对象，并且在设置 renderView 时还将 RenderView 赋值给了它的 rootNode。\n/// RendererBinding @override void initInstances() { _pipelineOwner = PipelineOwner( onNeedVisualUpdate: ensureVisualUpdate, onSemanticsOwnerCreated: _handleSemanticsOwnerCreated, onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed, ); } set renderView(RenderView value) { _pipelineOwner.rootNode = value; } PipelineOwner 其实渲染管道的管理者，它在渲染流程中有 3 个主要的方法：\nflushLayout 更新所有脏节点列表的布局信息 flushCompositionBits 对重新计算 needsCompositing 的节点进行更新 flushPaint 重绘所有脏节点 这 3 个方法通常是按顺序一起使用的，RenderBiding 会在 drawFrame() 方法中调用这 3 个方法\n/// RenderBiding @protected void drawFrame() { assert(renderView != null); pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); if (sendFramesToEngine) { renderView.compositeFrame(); // this sends the bits to the GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS. _firstFrameSent = true; } } 那么接下来我们就来研究一下这 3 个方法分别做了什么。\nflushLayout 我们知道当 RenderObject 有两个标识：\n_needsLayout 用于标识是否需要重新 Layout _needsPaint 用于标识是否需要重新绘制 这两个属性是保证 Render Tree 局部重绘的关键属性。\n当某个节点需要更新布局信息时，会调用 markNeedsLayout() 来重置 _needsLayout，但只这个过程还会将当前节点添加到 PipelineOwner 的 _nodesNeedingLayout 中（markNeedsPaint 则会添加到 _nodesNeedingPaint）。\n// 仅保留主要代码 void markNeedsLayout() { _needsLayout = true; if (owner != null) { owner!._nodesNeedingLayout.add(this); owner!.requestVisualUpdate(); } } flushLayout() 会将深度遍历这些节点，调用 RenderObject 的 _layoutWithoutResize() 方法来重新 Layout，最后将 _needsLayout 置为 false 并调用 markNeedsPaint() 让该节点需要重新绘制。\n/// PipelineOwner void flushLayout() { // 只保留主要逻辑 while (_nodesNeedingLayout.isNotEmpty) { final List\u003cRenderObject\u003e dirtyNodes = _nodesNeedingLayout; _nodesNeedingLayout = \u003cRenderObject\u003e[]; // 深度遍历 for (RenderObject node in dirtyNodes..sort( (RenderObject a, RenderObject b) =\u003e a.depth - b.depth) ) { if (node._needsLayout \u0026\u0026 node.owner == this) node._layoutWithoutResize(); } } } /// RenderObject @pragma('vm:notify-debugger-on-exception') void _layoutWithoutResize() { try { performLayout(); // 布局测量 markNeedsSemanticsUpdate(); } catch (e, stack) { _debugReportException('performLayout', e, stack); } _needsLayout = false; markNeedsPaint(); // 让节点需要重新绘制 } Layout 是通过 performLayout() 方法完成的，这个方法是 RenderObject 预留给子类实现自身 Layout 逻辑的抽象方法，例如在 RenderView 中的实现如下\n/// RenderView @override void performLayout() { // RenderView 需要占满整个屏幕 // 使用 ViewConfiguration 的 size _size = configuration.size; if (child != null) // 让子节点在父节点的布局约束下进行 Layout child!.layout(BoxConstraints.tight(_size)); } 要注意的是，自定义的 RenderBox 如果要放在能包含多个子节点的 RenderBox 中，例如 RenderFlex 和 RenderStack，那么需要重写 performLayout() 来确定布局大小，当然我们也可以利用另外一种方式，使用父节点的提供的约束来调整自己的大小：\n@override bool get sizedByParent =\u003e true; @override Size computeDryLayout(BoxConstraints constraints) { return constraints.smallest; } 这个方式在我们下面的实验🧪会用到。\nflushCompositingBits 在 flushLayout() 方法后紧接着会被调用的方法是 flushCompositingBits()。这个方法会进行深度遍历更新 _nodesNeedingCompositingBitsUpdate 列表中节点的 needsCompositing，它会调用节点的 _updateCompositingBits() 方法对 RenderObject 节点的一些属性进行更新，包括：\n_needsCompositing 是否需要合成 layer _needsCompositingBitsUpdate 是否需要更新 _needsCompositing /// PipelineOwner void flushCompositingBits() { // 只保留主要逻辑 _nodesNeedingCompositingBitsUpdate.sort( (RenderObject a, RenderObject b) =\u003e a.depth - b.depth); for (final RenderObject node in _nodesNeedingCompositingBitsUpdate) { if (node._needsCompositingBitsUpdate \u0026\u0026 node.owner == this) node._updateCompositingBits(); } _nodesNeedingCompositingBitsUpdate.clear(); if (!kReleaseMode) { Timeline.finishSync(); } } flushPaint flushPaint() 是第 3 个调用的，对 _nodesNeedingPaint 中的节点进行深度遍历，然后调用节点的 PaintingContext 的静态方法 repaintCompositedChild() 重新绘制 RenderObject 的视图。\n/// PipelineOwner void flushPaint() { // 只保留主要逻辑 final List\u003cRenderObject\u003e dirtyNodes = _nodesNeedingPaint; _nodesNeedingPaint = \u003cRenderObject\u003e[]; // Sort the dirty nodes in reverse order (deepest first). for (final RenderObject node in dirtyNodes..sort( (RenderObject a, RenderObject b) =\u003e b.depth - a.depth)) { if (node._needsPaint \u0026\u0026 node.owner == this) { if (node._layerHandle.layer!.attached) { PaintingContext.repaintCompositedChild(node); } else { node._skippedPaintingOnLayer(); } } } } 该方法中通过层层调用最终会到达，传入节点的 paint() 方法。paint() 方法也是 RenderObject 提供给子类实现绘制逻辑的抽象方法。同样以 RenderView 为例子：\n/// RenderView @override void paint(PaintingContext context, Offset offset) { if (child != null) context.paintChild(child!, offset); } 由于 RenderView 是整颗树的根节点，因此没有什么绘制逻辑，但所有的 RenderObject 都一样，如果有子节点都会通过 PaintingContext 继续调用子节点的 paint() 方法并将 PaintingContext 传递下去，直到整颗树的节点都完成绘制。\n场景合成与界面刷新渲染 我们知道 Widget 最终都是通过 Canvas 进行绘制的，因此我们以一个自定义 View 的例子来做分析。\n在 《Flutter 实战·第二版》 这本书中，是使用 CustomPainter 来编写自定义 View，通过重写 void paint(Canvas canvas, Size size); 方法来获得一个 Canvas 对象，因此可以往这个方法的源码翻阅，查看这个 Canvas 对象的来源。\n// custom_paint.dart abstract class CustomPainter extends Listenable /// Provides a canvas on which to draw during the paint phase. /// 提供了在绘图阶段要进行绘制的 Canvas class RenderCustomPaint extends RenderProxyBox { void _paintWithPainter(Canvas canvas, Offset offset, CustomPainter painter) { // ... // 在这里调用 CustomPainter 的 paint，并提供一个 Canvas 对象 painter.paint(canvas, size); } @override void paint(PaintingContext context, Offset offset) { if (_painter != null) { // 这里提供 canvas _paintWithPainter(context.canvas, offset, _painter!); _setRasterCacheHints(context); } super.paint(context, offset); if (_foregroundPainter != null) _paintWithPainter(context.canvas, offset, _foregroundPainter!); _setRasterCacheHints(context); } } } 在这里我们可以看出，我们自定义 View 的绘制操作，是由 RenderCustomPaint 执行，它的本质其实是一个 RenderBox，而其中传入的 Canvas 对象是由它在 paint() 中的 PaintingContext 提供的。\nCanvas 与绘制存储 在 PaintingContext 中是采用懒加载的方式来创建 Canvas 对象，PaintingContext 一般创建于 Render Tree 的单独子树开始绘制时，创建时会附带创建另外两个对象：\nPictureLayer 图层 PictureRecorder 图像记录者 // object.dart class PaintingContext extends ClipContext { Canvas? _canvas; /// 获取 Canvas 对象， /// 当 _canvas 没有创建时调用 [_startRecording] 方法创建 @override Canvas get canvas { if (_canvas == null) _startRecording(); assert(_currentLayer != null); return _canvas!; } /// 创建 Canvas 对象 /// - 创建 PictureLayer 图层对象 /// - 创建 PictureRecorder 图像记录者 /// - 创建 Canvas 对象 /// - 将 PictureLayer 添加到 ContainerLayer 容器层 void _startRecording() { assert(!_isRecording); _currentLayer = PictureLayer(estimatedBounds); _recorder = ui.PictureRecorder(); _canvas = Canvas(_recorder!); _containerLayer.append(_currentLayer!); } } 创建 Canvas 时必须传入一个 PictureRecorder 对象，这个对象会记录 Canvas 的绘制操作，当完成记录时，可通过调用 PictureRecord.endRecording 来结束记录，并得到一个 Picture 对象，由于 Canvas 的绘制是由 Engine 层中的 Skia 引擎提供，因此 Picture 对象也是存储在 Engine 层。\n/// PictureRecorder Picture endRecording() { if (_canvas == null) throw StateError('PictureRecorder did not start recording.'); final Picture picture = Picture._(); _endRecording(picture); _canvas!._recorder = null; _canvas = null; return picture; } void _endRecording(Picture outPicture) native 'PictureRecorder_endRecording'; Layer Tree _startRecording() 除了创建 Canvas 和 PictureRecorder 外，还创建了一个 PictureLayer 对象并将它加入到了 _containerLayer 中。这个 _containerLayer 其实是 RenderObject 中的一个 Layer。\nLayer 是用于缓存绘图操作结果（Picture）的图层，图层可以按照规则进行排列得到图像。每个 RenderObject 中会都有一个 Layer，存储在 LayerHandle 中，Render Tree 执行 flushPaint 完成绘制后，会形成一颗 Layer Tree，Layer Tree 的节点数量会比 Render Tree 少，几个 RenderObject 节点只对应一个 Layer 节点。\nLayer 节点也有多种，但用的最多的是以下两种：\n使用 PictureRecorder 记录绘图操作的节点使用 PictureLayer，PictureLayer 不具有子节点，这是最常用的叶子节点类型 当需要和 Layer 子节点进行叠加来得到图像时，可使用 ContainerLayer，它提供了 append 方法来连接 Layer，以形成一颗 Layer Tree。 ContainerLayer 可以有多个子节点，它们以链表的方式连接在一起，一般不会直接使用 ContainerLayer，而是使用它的子类 OffsetLayer。\n使用 prepareInitialFrame() 方法初始化 RenderView 创建的 Layer 类型是 TransformLayer ，它也是 OffsetLayer 的子类。\n当创建 PaintingContext 时提供的 Layer 节点不属于 OffsetLayer 时 ，会创建一个 OffsetLayer 来代替原本的 Layer，作为当前子树的根节点。 PaintingContext 创建新的 PictureLayer 时将会使用 append 方法将新的 Layer 节点添加到这个 OffsetLayer 中。\n/// PaintingContext static void _repaintCompositedChild( RenderObject child, { bool debugAlsoPaintedParent = false, PaintingContext? childContext, }) { OffsetLayer? childLayer = child._layerHandle.layer as OffsetLayer?; if (childLayer == null) { final OffsetLayer layer = OffsetLayer(); child._layerHandle.layer = childLayer = layer; } else { childLayer.removeAllChildren(); } // 在这里创建 PaintingContext childContext ??= PaintingContext(childLayer, child.paintBounds); child._paintWithContext(childContext, Offset.zero); // 完成绘制结束记录 childContext.stopRecordingIfNeeded(); } 上面提到如果节点有孩子，会通过 context.paintChild() 让子节点也调用 _paintWithContext() 方法将 PaintingContext 向下传递，继续执行子节点的 paint() 方法进行绘制。\n当目前的图层绘制完成时，绘制完成时会调用 stopRecordingIfNeeded() 来结束记录绘制，并将 PictureRecord 生成的 Picture 对象缓存到 PictureLayer 中。\n/// PaintingContext @protected @mustCallSuper void stopRecordingIfNeeded() { if (!_isRecording) return; _currentLayer!.picture = _recorder!.endRecording(); _currentLayer = null; _recorder = null; _canvas = null; } /// PictureLayer set picture(ui.Picture? picture) { markNeedsAddToScene(); _picture?.dispose(); _picture = picture; } 节点的绘制分离 Render Tree 的绘制是采用深度遍历自顶向下绘制的，即当前节点绘制完调用子节点的绘制方法。\nRenderObject 提供了 isRepaintBoundary 属性来判断当前子树是否需要与父节点分开绘制，该属性默认为 false，并且没有 setter 来进行修改，因此默认情况下一颗 Render Tree 可能只会生成 2 个 Layer 节点（根节点的 TransformLayer 和存储绘制结果的 PictureLayout）。\n但其实我们可以在 RenderBox 的子类重写该属性，或者使用 RenderRepaintBoundary（它的 isRepaintBoundary 被重写为 true），来分离父子节点的绘制，从达到分开绘制生成不同 Layer 节点形成一颗 Layer Tree。\n该属性在 markNeedsPaint()方法中也有使用，相关源码如下：\nvoid markNeedsPaint() { if (_needsPaint) return; _needsPaint = true; markNeedsPaintCout++; if (isRepaintBoundary) { if (owner != null) { owner!._nodesNeedingPaint.add(this); owner!.requestVisualUpdate(); } } else if (parent is RenderObject) { final RenderObject parent = this.parent! as RenderObject; parent.markNeedsPaint(); } } 如果 isRepaintBoundary 为 true 则表示和父节点分开绘制，将自己添加到 _nodesNeedingPaint 列表中，在下一次更新时就只会重绘当前子树，不会污染到父节点。 如果 isRepaintBoundary 为 false 则调用父节点的 markNeedsPaint()来让父节点处理，下一次更新由父节点重绘时执行自己的绘制方法进行重绘。 而在绘制流程中，如果子节点的 isRepaintBoundary 为 true，代表需要分开绘制，会结束当前 PictureRecorder 的记录并将生成的 Picture 存到 Layer 中，然后开始子节点的绘制。\n子节点绘制时由于 PaintingContext 的 Layer 已经被设置为 null 了，所以会创建新的 PictureLayer 并添加到根 Layer 的子节点列表，如果子节点不需要重新绘制，就直接将子节点的 Layer 添加到根 Layer 的子节点列表。\n这里添加时使用的 appendLayer() 会先将当前的 Layer 节点从原本的父节点中移除，再进行添加，因此不用当心会出现重复添加的情况，由于子节点列表的本质是链表，而且创建后添加与再添加之间通常不会有其它 Layer 节点介入，因此也不需要当心该方法添加时的移动和查找效率。\n/// PaintingContext void paintChild(RenderObject child, Offset offset) { if (child.isRepaintBoundary) { stopRecordingIfNeeded(); // 结束当前树的绘制 _compositeChild(child, offset); } else { child._paintWithContext(this, offset); } } /// 省略了很多代码 void _compositeChild(RenderObject child, Offset offset) { // Create a layer for our child, and paint the child into it. if (child._needsPaint) { repaintCompositedChild(child, debugAlsoPaintedParent: true); } final OffsetLayer childOffsetLayer = child._layerHandle.layer! as OffsetLayer; childOffsetLayer.offset = offset; appendLayer(childOffsetLayer); } @protected void appendLayer(Layer layer) { layer.remove(); // 从父节点中移除当前节点 _containerLayer.append(layer); } 场景渲染 我们回到 RenderBinding 的 drawFrame() 方法中，看一下 Render Tree 完成绘制后，是如何渲染到界面的。\n/// RenderBiding @protected void drawFrame() { pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); if (sendFramesToEngine) { renderView.compositeFrame(); // this sends the bits to the GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS. _firstFrameSent = true; } } /// RenderView void compositeFrame() { final ui.SceneBuilder builder = ui.SceneBuilder(); // 将图层添加到 scene final ui.Scene scene = layer!.buildScene(builder); // 发送 scene 给 GPU 进行渲染 _window.render(scene); scene.dispose(); } /// Layer ui.Scene buildScene(ui.SceneBuilder builder) { updateSubtreeNeedsAddToScene(); addToScene(builder); // 抽象方法，由子类实现 _needsAddToScene = false; final ui.Scene scene = builder.build(); return scene; } 当需要发送帧图像给 GPU 时，会调用 compositeFrame() 方法，在这个方法中会构建一个 SceneBuilder，然后通过 ContainerLayer.buildScene() 将 Layer Tree 的 Picture 合成一个 Scene。\nScene 可理解为场景，是存储 GPU 绘制的像素信息的图像对象，当添加的是 OffsetLayer 会设置图层的偏移量，当添加的是 ContanierLayer 时会遍历子节点进行添加，当添加的是 PictureLayer 会调用 native 方法在 Engine 添加 Picture 到图像中，当我们调用 build 方法时也是从 Engine 得到 Scene 对象。\nvoid _addPicture(double dx, double dy, Picture picture, int hints) native 'SceneBuilder_addPicture'; void _build(Scene outScene) native 'SceneBuilder_build'; Layer 中有两个属性 _needsAddToScene 和 _subtreeNeedsAddToScene 来表示自己和子树是否需要被添加到 Scene 中，当 Layer 被脏了则需要合成到 Scene，一个 Layer 或者其子树被合成到 Scene 后，对应的属性会被设置为 false。\nScene 合成完成后，接着调用 render 方法将 Scene 发送给 GUP 渲染到界面上。\n/// FlutterView void render(Scene scene) =\u003e _render(scene, this); void _render(Scene scene, FlutterView view) native 'PlatformConfiguration_render'; 界面刷新 现在我们知道 Flutter 是调用 drawFrame() 方法，来做 Render Tree 的绘制，那么 drawFrame() 什么时候执行呢？我们阅读一下这个方法的注释。\n/// This method is called by [handleDrawFrame], which itself is called /// automatically by the engine when it is time to lay out and paint a frame. 注释中说明 drawFrame() 会在 Engine 需要提供一帧新图像时，自动被 handleDrawFrame() 方法调用，实际上在 RenderBinding 初始化的时候，会把这个方法添加到 persistentCallbacks 回调列表中。\n/// RenderBinding void initInstances() { // window 的初始化时会设置一些状态改变的回调 window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; // RenderView 初始化创建 initRenderView(); // 在这里添加了一个回调 addPersistentFrameCallback(_handlePersistentFrameCallback); } void _handlePersistentFrameCallback(Duration timeStamp) { drawFrame(); // 在这个回调里调用帧绘制 _scheduleMouseTrackerUpdate(); } /// SchedulerBinding /// 该列表中的回调方法会被 handleDrawFrame 依次拿出来执行 final List\u003cFrameCallback\u003e _persistentCallbacks = \u003cFrameCallback\u003e[]; /// 将回调添加到 _persistentCallbacks 中 void addPersistentFrameCallback(FrameCallback callback) { _persistentCallbacks.add(callback); } handleDrawFrame() 被执行时，会从回调列表里面取出这个回调，从而屏幕刷新的时候都会调用 drawFrame() 将 Render Tree 绘制到界面上。\n/// Engine 调用这个方法来提供新的一帧图像 void handleDrawFrame() { // PERSISTENT FRAME CALLBACKS _schedulerPhase = SchedulerPhase.persistentCallbacks; for (final FrameCallback callback in _persistentCallbacks) _invokeFrameCallback(callback, _currentFrameTimeStamp!); // ... 只保留关键代码 } 也就是说，我们界面刷新时，相关的回调工作会交给 handleDrawFrame() 去执行，而这个方法除了在 APP 启动的时候，会先在 scheduleWarmUpFrame() 的定时器中执行一次进行首次展示外，在 scheduleAttachRootWidget() 方法执行的时候，就会被注册到 window.onDrawFrame了作为界面刷新的回调了。 我们采用断点调试的方式，可以看到 APP 启动的时候这个方法的注册调用链如下：\nvoid runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() ..scheduleAttachRootWidget(app) // 提前注册回调 ..scheduleWarmUpFrame(); } void attachRootWidget(Widget rootWidget) { // 如果是引导帧，则进行视觉更新 if (isBootstrapFrame) { SchedulerBinding.instance!.ensureVisualUpdate(); } } void ensureVisualUpdate() { switch (schedulerPhase) { case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: scheduleFrame(); // \u003c- 帧任务 return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; } } /// 以下都是 SchedulerBinding 中的方法 void scheduleFrame() { ensureFrameCallbacksRegistered(); // \u003c- 确定回调的注册 window.scheduleFrame(); // 请求回调的执行，进行界面更新 _hasScheduledFrame = true; } @protected void ensureFrameCallbacksRegistered() { window.onBeginFrame ??= _handleBeginFrame; window.onDrawFrame ??= _handleDrawFrame; // \u003c- 注册回调 } 注册的这个回调其实就是对 handleDrawFrame 包了一层壳。\nvoid _handleDrawFrame() { if (_rescheduleAfterWarmUpFrame) { _rescheduleAfterWarmUpFrame = false; addPostFrameCallback((Duration timeStamp) { _hasScheduledFrame = false; scheduleFrame(); }); return; } handleDrawFrame(); } window.scheduleFrame() 会向 Engine 层发起一个请求，在下一次合适的时机调用window.onDrawFrame和 window.onBeginFrame注册的回调，从而刷新界面。\n最后我们采用断点调试的方式，看界面刷新时 drawFrame 的完整调用链是什么样，绿框中的就是我们刚刚所讲到的那些方法了。\n到这里，知识就串起来了～\n整理图 我们画张图整理一下，为了让图更加简单易看，我们省略掉亿点点细节🤏。\nFramework 项目代码实验 当然了解完相关流程，我们直接在 Flutter Framework 的项目中进行实验，按照流程自己写一遍从 Render Tree 到界面刷新的代码，证明、也是熟悉这个流程。\n首先根据官方说明配置一个 Framework 开发环境，然后进入到 hello_world 项目中： https://github.com/flutter/flutter/wiki/Setting-up-the-Framework-development-environment\n实验项目和平时开发一样依旧采用 Flutter APP 的方式启动，但不同的是我们不调用 runApp() 方法，而是直接创建一颗 Render Tree 和使用 Canvas，采用上面讲的流程来执行我们的 APP。\n我们先尝试使用 Canvas 绘制一条直线，然后生成 Picture 添加到 Sence 中，然后发送给 GPU 进行渲染。\nimport 'dart:ui'; import 'package:flutter/material.dart'; void main() { final PictureRecorder pictureRecorder = PictureRecorder(); drawLine(pictureRecorder); final Picture picture = pictureRecorder.endRecording(); final SceneBuilder sceneBuilder = SceneBuilder(); sceneBuilder.addPicture(Offset.zero, picture); final Scene scene = sceneBuilder.build(); window.render(scene); } void drawLine(PictureRecorder recorder) { final Canvas canvas = Canvas(recorder); final Paint paint = Paint() ..color = Colors.white ..strokeWidth = 10; canvas.drawLine(Offset(300, 300), Offset(800, 300), paint); } 上面的代码会在界面绘制一条白线，由于这里只 render 了一次，因此在绘制完这条白线后，界面就不会有任何变化了。 现在我们尝试让线条动起来，通过上面的讲解，我们知道 Flutter 是使用 window.scheduleFrame()来请求屏幕的刷新，因此我们将渲染放到 window.onDrawFrame中，并不断改变线条位置。\nimport 'dart:ui'; import 'package:flutter/material.dart'; void main() { double dy = 300.0; window.onDrawFrame = () { final PictureRecorder pictureRecorder = PictureRecorder(); drawLine(pictureRecorder, dy); if (dy \u003c 800) dy++; final Picture picture = pictureRecorder.endRecording(); final SceneBuilder sceneBuilder = SceneBuilder(); sceneBuilder.addPicture(Offset.zero, picture); final Scene scene = sceneBuilder.build(); // 不断刷新界面 window.render(scene); window.scheduleFrame(); }; window.scheduleFrame(); } void drawLine(PictureRecorder recorder, double dy) { final Canvas canvas = Canvas(recorder); final Paint paint = Paint() ..color = Colors.white ..strokeWidth = 10; canvas.drawLine(Offset(300, dy), Offset(800, dy), paint); } 这样就得到了一条会移动的直线。\n接下来我们将上面的直线封装为一个自定义的 RenderObject，然后自己创建一颗 Render Tree，并使用 drawFrame() 方法中的流程：使用 PipelineOwner 来重新绘制被污染的节点。\nvoid main() { // 构建根节点 final PipelineOwner pipelineOwner = PipelineOwner(); final RenderView renderView = RenderView(configuration: const ViewConfiguration(), window: window); pipelineOwner.rootNode = renderView; // 初始化 renderView.prepareInitialFrame(); renderView.child = MyRenderNode(); window.onDrawFrame = () { callFlush(pipelineOwner); renderView.compositeFrame(); window.scheduleFrame(); }; window.scheduleFrame(); } void callFlush(PipelineOwner pipelineOwner) { pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); } class MyRenderNode extends RenderBox { double _dy = 300; final Paint _paint = Paint() ..color = Colors.white ..strokeWidth = 10; void _drawLines(Canvas canvas, double dy) { canvas.drawLine(Offset(300, dy), Offset(800, dy), _paint); } @override void paint(PaintingContext context, Offset offset) { _drawLines(context.canvas, _dy); _dy++; markNeedsLayout(); } } 这份代码运行的效果和上面的是一样的，但只有一个节点并不能看出转化为 Layer Tree 的优势，我们来构建一颗多个节点的 Render Tree。我们采用 RenderFlex 来存储多个节点，并和上面讲解 flushLayout()时所说的一样交由父节点来决定布局大小。\nvoid main() { // 构建根节点 final PipelineOwner pipelineOwner = PipelineOwner(); final RenderView renderView = RenderView(configuration: const ViewConfiguration(), window: window); pipelineOwner.rootNode = renderView; // 初始化 renderView.prepareInitialFrame(); final RenderFlex flex = RenderFlex(textDirection: TextDirection.ltr); // 从 301 开始移动到 500 一共绘制了 200 次 double dy = 301; // 创建两个叶子节点 final MyRenderNode node1 = MyRenderNode(dy, Colors.white); final MyRenderNode node2 = MyRenderNode(dy, Colors.blue); renderView.child = flex; // 注意这里是往前插入 flex.insert(node1); flex.insert(node2); window.onDrawFrame = () { callFlush(pipelineOwner); renderView.compositeFrame(); if (dy \u003c 500) { node1.dy = ++dy; window.scheduleFrame(); } else { print('node1 paint count: ${node1.paintCount}'); print('node2 paint count: ${node2.paintCount}'); } }; window.scheduleFrame(); } void callFlush(PipelineOwner pipelineOwner) { pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); } class MyRenderNode extends RenderBox { MyRenderNode(this._dy, Color color) { _paint = Paint() ..color = color ..strokeWidth = 10; } double _dy; int paintCount = 0; set dy(double dy) { _dy = dy; markNeedsLayout(); } double get dy =\u003e _dy; late Paint _paint; void _drawLines(Canvas canvas, double dy) { canvas.drawLine(Offset(300, dy), Offset(800, dy), _paint); } @override void paint(PaintingContext context, Offset offset) { _drawLines(context.canvas, dy); paintCount++; } @override bool get sizedByParent =\u003e true; @override Size computeDryLayout(BoxConstraints constraints) { return constraints.smallest; } } 这份代码比较长，对于 MyRenderNode的修改：\n首先我们重写了 sizedByParent和 computeDryLayout()，用于在布局测量时决定大小 _dy 属性添加了 setter 方法，在每次修改 _dy 的值时调用 markNeedsLayout() 来让下一次界面刷新时重新绘制节点 另外我们还添加了一个 piantCount 属性来记录节点绘制了几次 接着是 main 方法中：\n使用 RenderFlex 作为 RenderView 的子节点 创建了两个子节点插入到 RenderFlex 中 每次渲染时，都会修改 node1 的 dy，让他进行重绘，node2 则不做修改 当 dy 的值达到了 500 的时候停止界面刷新并打印两个节点的绘制次数 效果如上，会有一根不动的蓝线，和一根移动的白线。 我们再看看控制台打印的信息。\n我们发现两个节点的绘制次数都是 200，这意味着每次渲染两个节点都进行了重新绘制，根据上面我们讲到的 PaintingContext 和 Layer 的特点，我们可以很快判断出，这是由于 node1 和 node2 没有分开绘制，使用同一个 Layer 节点所造成的。\n由于 node1 被污染后也会调用父节点 flex 的 markNeedsPaint()，因此绘制操作时由父节点向下绘制的，而 node2 也是 flex 的子节点，整棵子树都会重新绘制，这就是 node2 污染时 node1 也跟着重绘的原因。 ​\n我们在自定义的 RenderBox 里重写 isRepaintBoundary 属性，并在 framework 层为 ContainerLayer 添加一个节点计数方法。\n/// ContainerLayer int layerCount() { int count = 1; // 算上当前节点 Layer? child = firstChild; while (child != null) { if(child is OffsetLayer) count += child.layerCount(); else count += 1; child = child.nextSibling; } return count; } void main() { window.onDrawFrame = () { if (dy \u003c 500) { node1.dy = ++dy; window.scheduleFrame(); } else { print('node1 paint count: ${node1.paintCount}'); print('node2 paint count: ${node2.paintCount}'); // 在结束时打印 Layer 的数量 print('layer count: ${renderView.layer?.layerCount()}'); } }; } class MyRenderNode extends RenderBox { bool _isRepaintBoundary = false; @override bool get isRepaintBoundary =\u003e _isRepaintBoundary; /// 添加设置方法 set isRepaintBoundary(bool v) { _isRepaintBoundary = v; } } 我们先来演示两种情况：\n不对两个叶子节点的 isRepaintBoundary 进行修改 将 node1 单独绘制：node1.isRepaintBoundary = false; 可以看到 node1 的 isRepaintBoundary 设置为 true 时， node2 只绘制了 1 次，现在 node2 的污染就不会导致 node1 重绘制了。\n另外我们看到第二种情况的 Layer 节点数量分是 4，为什么会是 4 呢？\n回想一下介绍 PaintingContext 创建时提供 Layout 的要求：\n当提供给 PaintingContext 的 Layer 节点不属于 OffsetLayer 时 ，会创建一个 OffsetLayer 来代替原本的 Layer，作为当前子树的根节点。\n如果我们对程序进行调试，就可以发现，虽然是以 node1、node2 的顺序插入，但实际 insert() 方法是往前插入，在 flex 中 node2 是处于 node1 的前面，因此 node2 会先进行绘制。\n由于 node2 并没有设置单独绘制，因此会按照正常流程和 flex 绘制在同一个 PictureRecorder 中生成一个 PictureLayer 并添加到 TransformLayer 中。\nnode2 绘制完成之后开始绘制 node1。由于我们将 node1 设置为单独绘制，那么绘制 node1 的时候将会作为一个子树重新开始绘制，这时会重新调用 _repaintCompositedChild()方法，创建一个新的 PaintingContext 来传递，此时由于 node1 是一个叶子结点，本身并不附带 OffsetLayer 节点，因此会创建一个新的 OffsetLayer 给 PaintingConext，再进行绘制。\n绘制 node 1 时生成的 PictureLayer 添加到这个 OffsetLayout 中，完成绘制之后再将 OffsetLayout 添加到 RenderView 的 TransformLayer 中。\n因此第 2 种情况会得到 4 个 Layer 节点，对应的 Layer 图示如下：\n我们修改一下计数方法，让它打印当前遍历的层次和节点类型。\nint layerCount() { int deep = 0; print('$deep ==\u003e root is [${this.runtimeType}]'); return _layerCount(deep + 1); } int _layerCount(int deep) { int count = 1; // 算上当前节点 Layer? child = firstChild; while (child != null) { print('$deep ==\u003e child is [${child.runtimeType}]'); if(child is OffsetLayer) count += child._layerCount(deep + 1); else count += 1; child = child.nextSibling; } return count; } 可以看到和我们画的转化图是一样的。如果我们将 node1 和 node2 交换一下，先添加 node2 再添加 node1，使 node1 先进行绘制，那么结果会是什么样呢？\nflex.insert(node2); flex.insert(node1); 可以看到依旧是 4 个 Layer 节点，node2 生成的 PictureLayer 依旧是 TransformLayer 的子节点。\n我们看一下 RenderFlex 是如何绘制子节点的，我们通过调试进入 RenderFlex 的 paint() 方法，可以看到它调用的是 paintDefault()，也就是进行遍历依次调用当前 PaintingContext 的 paintChild() 绘制子节点。\nvoid defaultPaint(PaintingContext context, Offset offset) { ChildType? child = firstChild; // 遍历子节点进行绘制 while (child != null) { final ParentDataType childParentData = child.parentData! as ParentDataType; context.paintChild(child, childParentData.offset + offset); child = childParentData.nextSibling; } } RenderFlex 循环绘制时，父节点和下面的子节点用的都是同一个 PaintingContex。由于 node1 是单独绘制，因此会创建一个新的 PaintingContext 和 OffsetLayer，但绘制 node2 时还是使用父节点的 PaintingContext，所以 flex 和 node2 会一起生成一个 PictureLayer 添加到根节点中。\n结语 本文到这里就结束了，我们现在可以看到，Flutter 性能高的一个很重要的原因，就是它在资源复用和避免不必要计算等方面，做了很多思考。\n之所以研究这部分，是因为这部分是 Flutter Framework 层最贴近 Engine 层的内容，对以后研究 Flutter 和 Android 两者在 Engine 层的异同点会有很大帮助。\n由于涉及到的东西特别多，因此并没办法讲的很全面，本文所要介绍的内容也可能存在遗漏，但按照本文讲解的流程去阅读源码进行扩展，并不难弄懂，有问题可在评论区留言。\n","wordCount":"2875","inLanguage":"en","datePublished":"2022-01-11T00:00:00Z","dateModified":"2022-01-11T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://answerkobe.github.io/posts/analysis-flutter-paint-process/"},"publisher":{"@type":"Organization","name":"Iverson's blog","logo":{"@type":"ImageObject","url":"http://answerkobe.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://answerkobe.github.io/ accesskey=h title="Iverson's blog (Alt + H)">Iverson's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://answerkobe.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=http://answerkobe.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=http://answerkobe.github.io/profile title=Profile-X><span>Profile-X</span></a></li><li><a href=http://answerkobe.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://answerkobe.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://answerkobe.github.io/posts/>Posts</a></div><h1 class=post-title>Flutter 绘制流程分析与代码实践</h1><div class=post-meta><span title='2022-01-11 00:00:00 +0000 UTC'>January 11, 2022</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#render-tree-%e7%9a%84%e5%88%9b%e5%bb%ba%e8%bf%87%e7%a8%8b aria-label="Render Tree 的创建过程">Render Tree 的创建过程</a><ul><li><a href=#renderobject-%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label="RenderObject 的类型">RenderObject 的类型</a></li><li><a href=#renderview-%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba aria-label="RenderView 如何创建">RenderView 如何创建</a></li><li><a href=#%e4%b8%89%e6%a3%b5%e6%a0%91%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e5%85%b3%e8%81%94 aria-label=三棵树的初始化关联>三棵树的初始化关联</a></li></ul></li><li><a href=#pipelineowner-%e6%b8%b2%e6%9f%93%e7%ae%a1%e9%81%93%e7%ae%a1%e7%90%86 aria-label="PipelineOwner 渲染管道管理">PipelineOwner 渲染管道管理</a><ul><li><a href=#flushlayout aria-label=flushLayout>flushLayout</a></li><li><a href=#flushcompositingbits aria-label=flushCompositingBits>flushCompositingBits</a></li><li><a href=#flushpaint aria-label=flushPaint>flushPaint</a></li></ul></li><li><a href=#%e5%9c%ba%e6%99%af%e5%90%88%e6%88%90%e4%b8%8e%e7%95%8c%e9%9d%a2%e5%88%b7%e6%96%b0%e6%b8%b2%e6%9f%93 aria-label=场景合成与界面刷新渲染>场景合成与界面刷新渲染</a><ul><li><a href=#canvas-%e4%b8%8e%e7%bb%98%e5%88%b6%e5%ad%98%e5%82%a8 aria-label="Canvas 与绘制存储">Canvas 与绘制存储</a></li><li><a href=#layer-tree aria-label="Layer Tree">Layer Tree</a></li><li><a href=#%e8%8a%82%e7%82%b9%e7%9a%84%e7%bb%98%e5%88%b6%e5%88%86%e7%a6%bb aria-label=节点的绘制分离>节点的绘制分离</a></li><li><a href=#%e5%9c%ba%e6%99%af%e6%b8%b2%e6%9f%93 aria-label=场景渲染>场景渲染</a></li><li><a href=#%e7%95%8c%e9%9d%a2%e5%88%b7%e6%96%b0 aria-label=界面刷新>界面刷新</a></li></ul></li><li><a href=#%e6%95%b4%e7%90%86%e5%9b%be aria-label=整理图>整理图</a></li><li><a href=#framework-%e9%a1%b9%e7%9b%ae%e4%bb%a3%e7%a0%81%e5%ae%9e%e9%aa%8c aria-label="Framework 项目代码实验">Framework 项目代码实验</a></li><li><a href=#%e7%bb%93%e8%af%ad aria-label=结语>结语</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=render-tree-的创建过程>Render Tree 的创建过程<a hidden class=anchor aria-hidden=true href=#render-tree-的创建过程>#</a></h2><h3 id=renderobject-的类型>RenderObject 的类型<a hidden class=anchor aria-hidden=true href=#renderobject-的类型>#</a></h3><p>我们知道 Element 主要分为负责渲染的 <strong>RenderObjectElement</strong> 和负责组合的 <strong>ComponentElement</strong> 两大类，而创建 RenderObject 节点的是前者 <code>mount()</code> 方法中调用的 <code>RenderObjectWidget.createRenderObject()</code> 方法。</p><p>该方法是一个抽象方法，需要子类实现，对于不同的布局的 Widget 创建的 RenderObject 类型也不一样，在 Render Tree 中最主要的有两种 RenderObject：</p><ul><li>首先是在 RenderObject 注释说明中大量提到了一个类 <strong>RenderBox</strong>，它是大部分的 RenderObjectWidget 所对应的 RenderObject 的抽象类</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// A render object in a 2D Cartesian coordinate system.
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// 一个在 2D 坐标系中的渲染对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RenderBox</span> <span style=color:#66d9ef>extends</span> RenderObject
</span></span></code></pre></div><ul><li>以及 Render Tree 的根节点 <strong>RenderView</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// The root of the render tree.
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// Render Tree 的根节点，处理渲染管道的引导和渲染树的输出
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// 它有一个填充整个输出表面的 RenderBox 类型的唯一子节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RenderView</span> <span style=color:#66d9ef>extends</span> RenderObject <span style=color:#66d9ef>with</span> RenderObjectWithChildMixin<span style=color:#f92672>&lt;</span>RenderBox<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>其他的类型的 RenderObject 基本是为了特定布局（如滑动、列表）的实现，但大部分都直接或间接集成自 RenderBox。</p><p>通常一个 RenderBox 只有一个子节点（因为它只有一个 child 属性），这使得它整体更像是链表。
Flutter 提供了 <code>ContainerRenderObjectMixin</code> 用来给那些需要存储多个子节点的 RenderBox 进行扩展，多个子节点的组织方式也是采用链表来连接存储，下面列出常见的两种：</p><ul><li><strong>RenderStack</strong> 实现了堆栈布局算法</li><li><strong>RenderFlex</strong> 实现了 <strong>Flex</strong> 布局算法，Column 和 Row 都是属于 Flex 的变体</li></ul><h3 id=renderview-如何创建>RenderView 如何创建<a hidden class=anchor aria-hidden=true href=#renderview-如何创建>#</a></h3><p>既然 Render Tree 的根节点是 RenderView，那么我们看 RenderView 是在哪被创建的。</p><p>通过 IDE 的全局搜索我们可以找到对应的创建引用是在 <code>RendererBinding</code> 中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// Flutter 引擎和 Render Tree 之间的一个绑定器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>mixin RendererBinding on BindingBase, ServicesBinding,
</span></span><span style=display:flex><span>SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable
</span></span></code></pre></div><p>这个类建立了 Flutter Engine 和 Render Tree 之间的关联，注释中介绍，当 Binding 被创建的时候就会执行
<code>initInstances()</code> 进行初始化并创建 RenderView。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// RendererBinding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> initInstances() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ... 省略了 PipelineOwner 创建和 window 初始化代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 创建 RenderView
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  initRenderView();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Called automatically when the binding is created.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> initRenderView() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  renderView <span style=color:#f92672>=</span> RenderView(
</span></span><span style=display:flex><span>    configuration: createViewConfiguration(),
</span></span><span style=display:flex><span>    window: window);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 初始化 RenderView
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  renderView.prepareInitialFrame();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们回到 Flutter App 启动时调用的函数 runApp。</p><p>runApp 会创建 <code>WidgetsFlutterBinding</code>，并执行 <code>ensureInitialized()</code> 方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>void</span> runApp(Widget app) {
</span></span><span style=display:flex><span>  WidgetsFlutterBinding.ensureInitialized() <span style=color:#75715e>//初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ..scheduleAttachRootWidget(app) <span style=color:#75715e>// 创建其他两棵树的根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ..scheduleWarmUpFrame();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而这个 <code>WidgetsFlutterBinding</code> 实际上由 7 个 mixin Binding 组合成，其中就包括了 <code>RendererBinding</code>，而调用这几个 mixin Binding 的 <code>initInstances()</code> 都是交给父类 BindingBase 在构造方法中执行。</p><p>这种采用 mixin 组合 Binding 的设计可以方便后续接入新的 Binding。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WidgetsFlutterBinding</span> <span style=color:#66d9ef>extends</span> BindingBase
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span> GestureBinding, SchedulerBinding, ServicesBinding,
</span></span><span style=display:flex><span>PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> WidgetsBinding ensureInitialized() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (WidgetsBinding.instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>      WidgetsFlutterBinding();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> WidgetsBinding.instance<span style=color:#f92672>!</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BindingBase</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// Default abstract constructor for bindings.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>///
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>/// First calls [initInstances] to have bindings initialize their
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>/// instance pointers and other state, then calls
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>/// [initServiceExtensions] to have bindings initialize their
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>/// observatory service extensions, if any.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  BindingBase() {
</span></span><span style=display:flex><span>    initInstances();
</span></span><span style=display:flex><span>    initServiceExtensions();
</span></span><span style=display:flex><span>    developer.postEvent(<span style=color:#e6db74>&#39;Flutter.FrameworkInitialization&#39;</span>, <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>String</span>, <span style=color:#66d9ef>String</span><span style=color:#f92672>&gt;</span>{});
</span></span><span style=display:flex><span>    developer.Timeline.finishSync();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=三棵树的初始化关联>三棵树的初始化关联<a hidden class=anchor aria-hidden=true href=#三棵树的初始化关联>#</a></h3><p>在<code>ensureInitialized()</code> 方法执行完成得到 Render Tree 根节点之后，就是调用 <code>scheduleAttachRootWidget()</code> 创建其他两棵树的根节点，然后和 Render Tree 进行关联。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>@</span>protected
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> scheduleAttachRootWidget(Widget rootWidget) {
</span></span><span style=display:flex><span>  Timer.run(() {
</span></span><span style=display:flex><span>    attachRootWidget(rootWidget);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> attachRootWidget(Widget rootWidget) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>bool</span> isBootstrapFrame <span style=color:#f92672>=</span> renderViewElement <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  _readyToProduceFrames <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  _renderViewElement <span style=color:#f92672>=</span> RenderObjectToWidgetAdapter<span style=color:#f92672>&lt;</span>RenderBox<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    container: renderView,
</span></span><span style=display:flex><span>    debugShortDescription: <span style=color:#e6db74>&#39;[root]&#39;</span>,
</span></span><span style=display:flex><span>    child: rootWidget,
</span></span><span style=display:flex><span>  ).attachToRenderTree(
</span></span><span style=display:flex><span>    buildOwner<span style=color:#f92672>!</span>,
</span></span><span style=display:flex><span>    renderViewElement <span style=color:#f92672>as</span> RenderObjectToWidgetElement<span style=color:#f92672>&lt;</span>RenderBox<span style=color:#f92672>&gt;?</span>
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (isBootstrapFrame) {
</span></span><span style=display:flex><span>    SchedulerBinding.instance<span style=color:#f92672>!</span>.ensureVisualUpdate();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这里<code>attachRootWidget()</code> 创建了 RenderObjectToWidgetAdapter，它的本质其实是 RenderObjectWidget，我们可以看到它声明了对应的 Render Tree 的节点类型为 RenderBox，并且指定了该 RenderBox 的父节点是 RenderView。</p><p>最后调用 <code>attachToRenderTree()</code> 将 RenderObjectToWidgetAdapter 转化为 RootRenderObjectElement 并和 Render Tree 进行绑定。</p><hr><h2 id=pipelineowner-渲染管道管理>PipelineOwner 渲染管道管理<a hidden class=anchor aria-hidden=true href=#pipelineowner-渲染管道管理>#</a></h2><p>目前的 Render Tree 只是一个数据结构，并没有渲染操作。因此我们来研究一下从 Render Tree 到界面是一个什么样的过程。</p><p>刚刚提到了 RenderBinding 建立了 Flutter Engine 和 Render Tree 之间的关联，在创建 RenderView 的过程中，我们可以注意到它还创建了一个 <strong>PipelineOwner</strong> 的对象，并且在设置 renderView 时还将 RenderView 赋值给了它的 rootNode。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// RendererBinding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> initInstances() {
</span></span><span style=display:flex><span>  _pipelineOwner <span style=color:#f92672>=</span> PipelineOwner(
</span></span><span style=display:flex><span>    onNeedVisualUpdate: ensureVisualUpdate,
</span></span><span style=display:flex><span>    onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,
</span></span><span style=display:flex><span>    onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>set</span> renderView(RenderView value) {
</span></span><span style=display:flex><span>  _pipelineOwner.rootNode <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>PipelineOwner</strong> 其实渲染管道的管理者，它在渲染流程中有 3 个主要的方法：</p><ol><li><code>flushLayout</code> 更新所有脏节点列表的布局信息</li><li><code>flushCompositionBits</code> 对重新计算 needsCompositing 的节点进行更新</li><li><code>flushPaint</code> 重绘所有脏节点</li></ol><p>这 3 个方法通常是按顺序一起使用的，RenderBiding 会在 <code>drawFrame()</code> 方法中调用这 3 个方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// RenderBiding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>@</span>protected
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> drawFrame() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>assert</span>(renderView <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>  pipelineOwner.flushLayout();
</span></span><span style=display:flex><span>  pipelineOwner.flushCompositingBits();
</span></span><span style=display:flex><span>  pipelineOwner.flushPaint();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (sendFramesToEngine) {
</span></span><span style=display:flex><span>    renderView.compositeFrame(); <span style=color:#75715e>// this sends the bits to the GPU
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pipelineOwner.flushSemantics(); <span style=color:#75715e>// this also sends the semantics to the OS.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _firstFrameSent <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那么接下来我们就来研究一下这 3 个方法分别做了什么。</p><h3 id=flushlayout>flushLayout<a hidden class=anchor aria-hidden=true href=#flushlayout>#</a></h3><p>我们知道当 RenderObject 有两个标识：</p><ul><li>_needsLayout 用于标识是否需要重新 Layout</li><li>_needsPaint 用于标识是否需要重新绘制</li></ul><p>这两个属性是保证 Render Tree 局部重绘的关键属性。</p><p>当某个节点需要更新布局信息时，会调用 <code>markNeedsLayout()</code> 来重置 _needsLayout，但只这个过程还会将当前节点添加到 PipelineOwner 的 _nodesNeedingLayout 中（<code>markNeedsPaint</code> 则会添加到 _nodesNeedingPaint）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>// 仅保留主要代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> markNeedsLayout() {
</span></span><span style=display:flex><span>  _needsLayout <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (owner <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    owner<span style=color:#f92672>!</span>._nodesNeedingLayout.add(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    owner<span style=color:#f92672>!</span>.requestVisualUpdate();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>flushLayout()</code> 会将深度遍历这些节点，调用 RenderObject 的 <code>_layoutWithoutResize()</code> 方法来重新 Layout，最后将 _needsLayout 置为 false 并调用 <code>markNeedsPaint()</code> 让该节点需要重新绘制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// PipelineOwner
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> flushLayout() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 只保留主要逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> (_nodesNeedingLayout.isNotEmpty) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>RenderObject<span style=color:#f92672>&gt;</span> dirtyNodes <span style=color:#f92672>=</span> _nodesNeedingLayout;
</span></span><span style=display:flex><span>    _nodesNeedingLayout <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>RenderObject<span style=color:#f92672>&gt;</span>[];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 深度遍历
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (RenderObject node <span style=color:#66d9ef>in</span> dirtyNodes..sort(
</span></span><span style=display:flex><span>      (RenderObject a, RenderObject b) <span style=color:#f92672>=&gt;</span> a.depth <span style=color:#f92672>-</span> b.depth)
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (node._needsLayout <span style=color:#f92672>&amp;&amp;</span> node.owner <span style=color:#f92672>==</span> <span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>        node._layoutWithoutResize();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// RenderObject
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>@</span>pragma(<span style=color:#e6db74>&#39;vm:notify-debugger-on-exception&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> _layoutWithoutResize() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    performLayout(); <span style=color:#75715e>// 布局测量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    markNeedsSemanticsUpdate();
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (e, stack) {
</span></span><span style=display:flex><span>    _debugReportException(<span style=color:#e6db74>&#39;performLayout&#39;</span>, e, stack);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  _needsLayout <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>  markNeedsPaint(); <span style=color:#75715e>// 让节点需要重新绘制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Layout 是通过 <code>performLayout()</code> 方法完成的，这个方法是 RenderObject 预留给子类实现自身 Layout 逻辑的抽象方法，例如在 RenderView 中的实现如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// RenderView
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> performLayout() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// RenderView 需要占满整个屏幕
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 使用 ViewConfiguration 的 size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _size <span style=color:#f92672>=</span> configuration.size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (child <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 让子节点在父节点的布局约束下进行 Layout
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    child<span style=color:#f92672>!</span>.layout(BoxConstraints.tight(_size));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>要注意的是，自定义的 RenderBox 如果要放在能包含多个子节点的 RenderBox 中，例如 RenderFlex 和 RenderStack，那么<strong>需要重写 <code>performLayout()</code> 来确定布局大小，当然我们也可以利用另外一种方式，使用父节点的提供的约束来调整自己的大小：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>get</span> sizedByParent <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>Size computeDryLayout(BoxConstraints constraints) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> constraints.smallest;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>这个方式在我们下面的实验🧪会用到。</em></p><h3 id=flushcompositingbits>flushCompositingBits<a hidden class=anchor aria-hidden=true href=#flushcompositingbits>#</a></h3><p>在 <code>flushLayout()</code> 方法后紧接着会被调用的方法是 <code>flushCompositingBits()</code>。这个方法会进行深度遍历更新 _nodesNeedingCompositingBitsUpdate 列表中节点的 needsCompositing，它会调用节点的
<code>_updateCompositingBits()</code> 方法对 RenderObject 节点的一些属性进行更新，包括：</p><ul><li>_needsCompositing 是否需要合成 layer</li><li>_needsCompositingBitsUpdate 是否需要更新 _needsCompositing</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// PipelineOwner
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> flushCompositingBits() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 只保留主要逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _nodesNeedingCompositingBitsUpdate.sort(
</span></span><span style=display:flex><span>    (RenderObject a, RenderObject b) <span style=color:#f92672>=&gt;</span> a.depth <span style=color:#f92672>-</span> b.depth);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>final</span> RenderObject node <span style=color:#66d9ef>in</span> _nodesNeedingCompositingBitsUpdate) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (node._needsCompositingBitsUpdate <span style=color:#f92672>&amp;&amp;</span> node.owner <span style=color:#f92672>==</span> <span style=color:#66d9ef>this</span>)
</span></span><span style=display:flex><span>      node._updateCompositingBits();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  _nodesNeedingCompositingBitsUpdate.clear();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>kReleaseMode) {
</span></span><span style=display:flex><span>    Timeline.finishSync();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=flushpaint>flushPaint<a hidden class=anchor aria-hidden=true href=#flushpaint>#</a></h3><p><code>flushPaint()</code> 是第 3 个调用的，对 _nodesNeedingPaint 中的节点进行深度遍历，然后调用节点的 <strong>PaintingContext</strong> 的静态方法 <code>repaintCompositedChild()</code> 重新绘制 RenderObject 的视图。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// PipelineOwner
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> flushPaint() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 只保留主要逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>RenderObject<span style=color:#f92672>&gt;</span> dirtyNodes <span style=color:#f92672>=</span> _nodesNeedingPaint;
</span></span><span style=display:flex><span>  _nodesNeedingPaint <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>RenderObject<span style=color:#f92672>&gt;</span>[];
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Sort the dirty nodes in reverse order (deepest first).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>final</span> RenderObject node <span style=color:#66d9ef>in</span> dirtyNodes..sort(
</span></span><span style=display:flex><span>    (RenderObject a, RenderObject b) <span style=color:#f92672>=&gt;</span> b.depth <span style=color:#f92672>-</span> a.depth)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (node._needsPaint <span style=color:#f92672>&amp;&amp;</span> node.owner <span style=color:#f92672>==</span> <span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (node._layerHandle.layer<span style=color:#f92672>!</span>.attached) {
</span></span><span style=display:flex><span>        PaintingContext.repaintCompositedChild(node);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        node._skippedPaintingOnLayer();
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该方法中通过层层调用最终会到达，传入节点的 <code>paint()</code> 方法。<code>paint()</code> 方法也是 RenderObject 提供给子类实现绘制逻辑的抽象方法。同样以 RenderView 为例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// RenderView
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> paint(PaintingContext context, Offset offset) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (child <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    context.paintChild(child<span style=color:#f92672>!</span>, offset);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于 RenderView 是整颗树的根节点，因此没有什么绘制逻辑，但所有的 RenderObject 都一样，如果有子节点都会通过 PaintingContext 继续调用子节点的 <code>paint()</code> 方法并将 PaintingContext 传递下去，直到整颗树的节点都完成绘制。</p><hr><h2 id=场景合成与界面刷新渲染>场景合成与界面刷新渲染<a hidden class=anchor aria-hidden=true href=#场景合成与界面刷新渲染>#</a></h2><p>我们知道 Widget 最终都是通过 Canvas 进行绘制的，因此我们以一个自定义 View 的例子来做分析。</p><p>在 《Flutter 实战·第二版》 这本书中，是使用 <code>CustomPainter</code> 来编写自定义 View，通过重写
<code>void paint(Canvas canvas, Size size);</code> 方法来获得一个 Canvas 对象，因此可以往这个方法的源码翻阅，查看这个 Canvas 对象的来源。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>// custom_paint.dart
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CustomPainter</span> <span style=color:#66d9ef>extends</span> Listenable
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Provides a canvas on which to draw during the paint phase.
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// 提供了在绘图阶段要进行绘制的 Canvas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RenderCustomPaint</span> <span style=color:#66d9ef>extends</span> RenderProxyBox {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> _paintWithPainter(Canvas canvas, Offset offset, CustomPainter painter) {
</span></span><span style=display:flex><span>  	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 在这里调用 CustomPainter 的 paint，并提供一个 Canvas 对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	painter.paint(canvas, size);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> paint(PaintingContext context, Offset offset) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (_painter <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 这里提供 canvas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      _paintWithPainter(context.canvas, offset, _painter<span style=color:#f92672>!</span>);
</span></span><span style=display:flex><span>      _setRasterCacheHints(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span>.paint(context, offset);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (_foregroundPainter <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>      _paintWithPainter(context.canvas, offset, _foregroundPainter<span style=color:#f92672>!</span>);
</span></span><span style=display:flex><span>      _setRasterCacheHints(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这里我们可以看出，我们自定义 View 的绘制操作，是由 <strong>RenderCustomPaint</strong> 执行，它的本质其实是一个 <strong>RenderBox</strong>，而其中传入的 Canvas 对象是由它在 <code>paint()</code> 中的 PaintingContext 提供的。</p><h3 id=canvas-与绘制存储>Canvas 与绘制存储<a hidden class=anchor aria-hidden=true href=#canvas-与绘制存储>#</a></h3><p>在 PaintingContext 中是采用懒加载的方式来创建 Canvas 对象，PaintingContext 一般创建于 Render Tree 的单独子树开始绘制时，创建时会附带创建另外两个对象：</p><ul><li>PictureLayer 图层</li><li>PictureRecorder 图像记录者</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>// object.dart
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PaintingContext</span> <span style=color:#66d9ef>extends</span> ClipContext {
</span></span><span style=display:flex><span>  Canvas<span style=color:#f92672>?</span> _canvas;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// 获取 Canvas 对象，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>/// 当 _canvas 没有创建时调用 [_startRecording] 方法创建
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  Canvas <span style=color:#66d9ef>get</span> canvas {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (_canvas <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>      _startRecording();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span>(_currentLayer <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _canvas<span style=color:#f92672>!</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// 创建 Canvas 对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>/// - 创建 PictureLayer 图层对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>/// - 创建 PictureRecorder 图像记录者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>/// - 创建 Canvas 对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>/// - 将 PictureLayer 添加到 ContainerLayer 容器层
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> _startRecording() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span>(<span style=color:#f92672>!</span>_isRecording);
</span></span><span style=display:flex><span>    _currentLayer <span style=color:#f92672>=</span> PictureLayer(estimatedBounds);
</span></span><span style=display:flex><span>    _recorder <span style=color:#f92672>=</span> ui.PictureRecorder();
</span></span><span style=display:flex><span>    _canvas <span style=color:#f92672>=</span> Canvas(_recorder<span style=color:#f92672>!</span>);
</span></span><span style=display:flex><span>    _containerLayer.append(_currentLayer<span style=color:#f92672>!</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>创建 Canvas 时必须传入一个 PictureRecorder 对象，这个对象会记录 Canvas 的绘制操作，当完成记录时，可通过调用 <code>PictureRecord.endRecording</code> 来结束记录，并得到一个 Picture 对象，由于 Canvas 的绘制是由 Engine 层中的 Skia 引擎提供，因此 Picture 对象也是存储在 Engine 层。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// PictureRecorder
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Picture endRecording() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (_canvas <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> StateError(<span style=color:#e6db74>&#39;PictureRecorder did not start recording.&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> Picture picture <span style=color:#f92672>=</span> Picture._();
</span></span><span style=display:flex><span>  _endRecording(picture);
</span></span><span style=display:flex><span>  _canvas<span style=color:#f92672>!</span>._recorder <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  _canvas <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> picture;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> _endRecording(Picture outPicture) <span style=color:#66d9ef>native</span> <span style=color:#e6db74>&#39;PictureRecorder_endRecording&#39;</span>;
</span></span></code></pre></div><h3 id=layer-tree>Layer Tree<a hidden class=anchor aria-hidden=true href=#layer-tree>#</a></h3><p><code>_startRecording()</code> 除了创建 Canvas 和 PictureRecorder 外，还创建了一个 PictureLayer 对象并将它加入到了 _containerLayer 中。这个 _containerLayer 其实是 RenderObject 中的一个 Layer。</p><p>Layer 是用于缓存绘图操作结果（Picture）的图层，图层可以按照规则进行排列得到图像。每个 RenderObject 中会都有一个 Layer，存储在 LayerHandle 中，<strong>Render Tree 执行 flushPaint 完成绘制后，会形成一颗 Layer Tree，Layer Tree 的节点数量会比 Render Tree 少，几个 RenderObject 节点只对应一个 Layer 节点。</strong></p><p>Layer 节点也有多种，但用的最多的是以下两种：</p><ul><li>使用 PictureRecorder 记录绘图操作的节点使用 PictureLayer，PictureLayer 不具有子节点，这是最常用的叶子节点类型</li><li>当需要和 Layer 子节点进行叠加来得到图像时，可使用 ContainerLayer，它提供了 append 方法来连接 Layer，以形成一颗 Layer Tree。</li></ul><p>ContainerLayer 可以有多个子节点，它们以链表的方式连接在一起，一般不会直接使用 ContainerLayer，而是使用它的子类 OffsetLayer。</p><blockquote><p>使用 <code>prepareInitialFrame()</code> 方法初始化 RenderView 创建的 Layer 类型是 <strong>TransformLayer</strong> ，它也是 OffsetLayer 的子类。</p></blockquote><p>当创建 PaintingContext 时提供的 Layer 节点不属于 OffsetLayer 时 ，会创建一个 OffsetLayer 来代替原本的 Layer，作为当前子树的根节点。 PaintingContext 创建新的 PictureLayer 时将会使用 append 方法将新的 Layer 节点添加到这个 OffsetLayer 中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// PaintingContext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> _repaintCompositedChild(
</span></span><span style=display:flex><span>  RenderObject child, {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> debugAlsoPaintedParent <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>    PaintingContext<span style=color:#f92672>?</span> childContext,
</span></span><span style=display:flex><span>  }) {
</span></span><span style=display:flex><span>  OffsetLayer<span style=color:#f92672>?</span> childLayer <span style=color:#f92672>=</span> child._layerHandle.layer <span style=color:#f92672>as</span> OffsetLayer<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (childLayer <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> OffsetLayer layer <span style=color:#f92672>=</span> OffsetLayer();
</span></span><span style=display:flex><span>    child._layerHandle.layer <span style=color:#f92672>=</span> childLayer <span style=color:#f92672>=</span> layer;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    childLayer.removeAllChildren();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 在这里创建 PaintingContext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  childContext <span style=color:#f92672>??=</span> PaintingContext(childLayer, child.paintBounds);
</span></span><span style=display:flex><span>  child._paintWithContext(childContext, Offset.zero);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 完成绘制结束记录
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  childContext.stopRecordingIfNeeded();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面提到如果节点有孩子，会通过 <code>context.paintChild()</code> 让子节点也调用 <code>_paintWithContext()</code> 方法将 PaintingContext 向下传递，继续执行子节点的 <code>paint()</code> 方法进行绘制。</p><p>当目前的图层绘制完成时，绘制完成时会调用 <code>stopRecordingIfNeeded()</code> 来结束记录绘制，并将 PictureRecord 生成的 Picture 对象缓存到 PictureLayer 中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// PaintingContext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>@</span>protected
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>@</span>mustCallSuper
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> stopRecordingIfNeeded() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>_isRecording)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  _currentLayer<span style=color:#f92672>!</span>.picture <span style=color:#f92672>=</span> _recorder<span style=color:#f92672>!</span>.endRecording();
</span></span><span style=display:flex><span>  _currentLayer <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  _recorder <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  _canvas <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// PictureLayer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>set</span> picture(ui.Picture<span style=color:#f92672>?</span> picture) {
</span></span><span style=display:flex><span>  markNeedsAddToScene();
</span></span><span style=display:flex><span>  _picture<span style=color:#f92672>?</span>.dispose();
</span></span><span style=display:flex><span>  _picture <span style=color:#f92672>=</span> picture;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=节点的绘制分离>节点的绘制分离<a hidden class=anchor aria-hidden=true href=#节点的绘制分离>#</a></h3><p>Render Tree 的绘制是采用深度遍历自顶向下绘制的，即当前节点绘制完调用子节点的绘制方法。</p><p>RenderObject 提供了 <strong>isRepaintBoundary</strong> 属性来判断当前子树是否需要与父节点分开绘制，该属性默认为 false，并且没有 setter 来进行修改，因此默认情况下一颗 Render Tree 可能只会生成 2 个 Layer 节点（根节点的 TransformLayer 和存储绘制结果的 PictureLayout）。</p><p>但其实我们可以在 RenderBox 的子类重写该属性，或者使用 RenderRepaintBoundary（它的 isRepaintBoundary 被重写为 true），来分离父子节点的绘制，从达到分开绘制生成不同 Layer 节点形成一颗 Layer Tree。</p><p>该属性在 <code>markNeedsPaint()</code>方法中也有使用，相关源码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>void</span> markNeedsPaint() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (_needsPaint)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  _needsPaint <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  markNeedsPaintCout<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (isRepaintBoundary) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (owner <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>      owner<span style=color:#f92672>!</span>._nodesNeedingPaint.add(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>      owner<span style=color:#f92672>!</span>.requestVisualUpdate();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (parent <span style=color:#66d9ef>is</span> RenderObject) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> RenderObject parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.parent<span style=color:#f92672>!</span> <span style=color:#f92672>as</span> RenderObject;
</span></span><span style=display:flex><span>    parent.markNeedsPaint();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>如果 isRepaintBoundary 为 true 则表示和父节点分开绘制，将自己添加到 _nodesNeedingPaint 列表中，在下一次更新时就只会重绘当前子树，不会污染到父节点。</li><li>如果 isRepaintBoundary 为 false 则调用父节点的 <code>markNeedsPaint()</code>来让父节点处理，下一次更新由父节点重绘时执行自己的绘制方法进行重绘。</li></ul><p>而在绘制流程中，如果子节点的 isRepaintBoundary 为 true，代表需要分开绘制，会结束当前 PictureRecorder 的记录并将生成的 Picture 存到 Layer 中，然后开始子节点的绘制。</p><p>子节点绘制时由于 PaintingContext 的 Layer 已经被设置为 null 了，所以会创建新的 PictureLayer 并添加到根 Layer 的子节点列表，如果子节点不需要重新绘制，就直接将子节点的 Layer 添加到根 Layer 的子节点列表。</p><p>这里添加时使用的 <code>appendLayer()</code> 会先将当前的 Layer 节点从原本的父节点中移除，再进行添加，因此不用当心会出现重复添加的情况，由于子节点列表的本质是链表，而且创建后添加与再添加之间通常不会有其它 Layer 节点介入，因此也不需要当心该方法添加时的移动和查找效率。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// PaintingContext
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> paintChild(RenderObject child, Offset offset) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (child.isRepaintBoundary) {
</span></span><span style=display:flex><span>    stopRecordingIfNeeded(); <span style=color:#75715e>// 结束当前树的绘制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _compositeChild(child, offset);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    child._paintWithContext(<span style=color:#66d9ef>this</span>, offset);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 省略了很多代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> _compositeChild(RenderObject child, Offset offset) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a layer for our child, and paint the child into it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (child._needsPaint) {
</span></span><span style=display:flex><span>      repaintCompositedChild(child, debugAlsoPaintedParent: <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> OffsetLayer childOffsetLayer <span style=color:#f92672>=</span> child._layerHandle.layer<span style=color:#f92672>!</span> <span style=color:#f92672>as</span> OffsetLayer;
</span></span><span style=display:flex><span>    childOffsetLayer.offset <span style=color:#f92672>=</span> offset;
</span></span><span style=display:flex><span>    appendLayer(childOffsetLayer);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>@</span>protected
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> appendLayer(Layer layer) {
</span></span><span style=display:flex><span>  layer.remove(); <span style=color:#75715e>// 从父节点中移除当前节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _containerLayer.append(layer);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=场景渲染>场景渲染<a hidden class=anchor aria-hidden=true href=#场景渲染>#</a></h3><p>我们回到 RenderBinding 的 <code>drawFrame()</code> 方法中，看一下 Render Tree 完成绘制后，是如何渲染到界面的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// RenderBiding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#960050;background-color:#1e0010>@</span>protected
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> drawFrame() {
</span></span><span style=display:flex><span>  pipelineOwner.flushLayout();
</span></span><span style=display:flex><span>  pipelineOwner.flushCompositingBits();
</span></span><span style=display:flex><span>  pipelineOwner.flushPaint();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (sendFramesToEngine) {
</span></span><span style=display:flex><span>    renderView.compositeFrame(); <span style=color:#75715e>// this sends the bits to the GPU
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pipelineOwner.flushSemantics(); <span style=color:#75715e>// this also sends the semantics to the OS.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _firstFrameSent <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// RenderView
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> compositeFrame() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> ui.SceneBuilder builder <span style=color:#f92672>=</span> ui.SceneBuilder();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 将图层添加到 scene
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>final</span> ui.Scene scene <span style=color:#f92672>=</span> layer<span style=color:#f92672>!</span>.buildScene(builder);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 发送 scene 给 GPU 进行渲染
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _window.render(scene);
</span></span><span style=display:flex><span>  scene.dispose();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Layer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ui.Scene buildScene(ui.SceneBuilder builder) {
</span></span><span style=display:flex><span>  updateSubtreeNeedsAddToScene();
</span></span><span style=display:flex><span>  addToScene(builder); <span style=color:#75715e>// 抽象方法，由子类实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _needsAddToScene <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> ui.Scene scene <span style=color:#f92672>=</span> builder.build();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> scene;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当需要发送帧图像给 GPU 时，会调用 <code>compositeFrame()</code> 方法，在这个方法中会构建一个 SceneBuilder，然后通过 <code>ContainerLayer.buildScene()</code> 将 Layer Tree 的 Picture 合成一个 Scene。</p><p>Scene 可理解为场景，是存储 GPU 绘制的像素信息的图像对象，当添加的是 OffsetLayer 会设置图层的偏移量，当添加的是 ContanierLayer 时会遍历子节点进行添加，当添加的是 PictureLayer 会调用 native 方法在 Engine 添加 Picture 到图像中，当我们调用 build 方法时也是从 Engine 得到 Scene 对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>void</span> _addPicture(<span style=color:#66d9ef>double</span> dx, <span style=color:#66d9ef>double</span> dy, Picture picture, <span style=color:#66d9ef>int</span> hints)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>native</span> <span style=color:#e6db74>&#39;SceneBuilder_addPicture&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> _build(Scene outScene) <span style=color:#66d9ef>native</span> <span style=color:#e6db74>&#39;SceneBuilder_build&#39;</span>;
</span></span></code></pre></div><p>Layer 中有两个属性 _needsAddToScene 和 _subtreeNeedsAddToScene 来表示自己和子树是否需要被添加到 Scene 中，当 Layer 被脏了则需要合成到 Scene，一个 Layer 或者其子树被合成到 Scene 后，对应的属性会被设置为 false。</p><p>Scene 合成完成后，接着调用 <strong>render</strong> 方法将 Scene 发送给 GUP 渲染到界面上。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// FlutterView
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> render(Scene scene) <span style=color:#f92672>=&gt;</span> _render(scene, <span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> _render(Scene scene, FlutterView view) <span style=color:#66d9ef>native</span> <span style=color:#e6db74>&#39;PlatformConfiguration_render&#39;</span>;
</span></span></code></pre></div><h3 id=界面刷新>界面刷新<a hidden class=anchor aria-hidden=true href=#界面刷新>#</a></h3><p>现在我们知道 Flutter 是调用 <code>drawFrame()</code> 方法，来做 Render Tree 的绘制，那么 <code>drawFrame()</code> 什么时候执行呢？我们阅读一下这个方法的注释。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// This method is called by [handleDrawFrame], which itself is called
</span></span></span><span style=display:flex><span><span style=color:#75715e>/// automatically by the engine when it is time to lay out and paint a frame.
</span></span></span></code></pre></div><p>注释中说明 <code>drawFrame()</code> 会在 Engine 需要提供一帧新图像时，自动被 <code>handleDrawFrame()</code> 方法调用，实际上在 RenderBinding 初始化的时候，会把这个方法添加到 persistentCallbacks 回调列表中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// RenderBinding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> initInstances() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// window 的初始化时会设置一些状态改变的回调
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  window
</span></span><span style=display:flex><span>      ..onMetricsChanged <span style=color:#f92672>=</span> handleMetricsChanged
</span></span><span style=display:flex><span>      ..onTextScaleFactorChanged <span style=color:#f92672>=</span> handleTextScaleFactorChanged
</span></span><span style=display:flex><span>      ..onPlatformBrightnessChanged <span style=color:#f92672>=</span> handlePlatformBrightnessChanged
</span></span><span style=display:flex><span>      ..onSemanticsEnabledChanged <span style=color:#f92672>=</span> _handleSemanticsEnabledChanged
</span></span><span style=display:flex><span>      ..onSemanticsAction <span style=color:#f92672>=</span> _handleSemanticsAction;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// RenderView 初始化创建
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  initRenderView();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 在这里添加了一个回调
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  addPersistentFrameCallback(_handlePersistentFrameCallback);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> _handlePersistentFrameCallback(Duration timeStamp) {
</span></span><span style=display:flex><span>  drawFrame(); <span style=color:#75715e>// 在这个回调里调用帧绘制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _scheduleMouseTrackerUpdate();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// SchedulerBinding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 该列表中的回调方法会被 handleDrawFrame 依次拿出来执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>FrameCallback<span style=color:#f92672>&gt;</span> _persistentCallbacks <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span>FrameCallback<span style=color:#f92672>&gt;</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 将回调添加到 _persistentCallbacks 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> addPersistentFrameCallback(FrameCallback callback) {
</span></span><span style=display:flex><span>  _persistentCallbacks.add(callback);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>handleDrawFrame()</code> 被执行时，会从回调列表里面取出这个回调，从而屏幕刷新的时候都会调用
<code>drawFrame()</code> 将 Render Tree 绘制到界面上。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// Engine 调用这个方法来提供新的一帧图像
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> handleDrawFrame() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// PERSISTENT FRAME CALLBACKS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _schedulerPhase <span style=color:#f92672>=</span> SchedulerPhase.persistentCallbacks;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>final</span> FrameCallback callback <span style=color:#66d9ef>in</span> _persistentCallbacks)
</span></span><span style=display:flex><span>    _invokeFrameCallback(callback, _currentFrameTimeStamp<span style=color:#f92672>!</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ... 只保留关键代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>也就是说，我们界面刷新时，相关的回调工作会交给 <code>handleDrawFrame()</code> 去执行，而这个方法除了在 APP 启动的时候，会先在 <code>scheduleWarmUpFrame()</code> 的定时器中执行一次进行首次展示外，在 <code>scheduleAttachRootWidget()</code> 方法执行的时候，就会被注册到 <code>window.onDrawFrame</code>了作为界面刷新的回调了。
我们采用断点调试的方式，可以看到 APP 启动的时候这个方法的注册调用链如下：</p><p><img loading=lazy src=./01.png alt=注册调用链.png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>void</span> runApp(Widget app) {
</span></span><span style=display:flex><span>  WidgetsFlutterBinding.ensureInitialized()
</span></span><span style=display:flex><span>    ..scheduleAttachRootWidget(app) <span style=color:#75715e>// 提前注册回调
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ..scheduleWarmUpFrame();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> attachRootWidget(Widget rootWidget) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果是引导帧，则进行视觉更新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (isBootstrapFrame) {
</span></span><span style=display:flex><span>    SchedulerBinding.instance<span style=color:#f92672>!</span>.ensureVisualUpdate();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ensureVisualUpdate() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (schedulerPhase) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> SchedulerPhase.idle:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> SchedulerPhase.postFrameCallbacks:
</span></span><span style=display:flex><span>      scheduleFrame(); <span style=color:#75715e>// &lt;- 帧任务
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> SchedulerPhase.transientCallbacks:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> SchedulerPhase.midFrameMicrotasks:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> SchedulerPhase.persistentCallbacks:
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 以下都是 SchedulerBinding 中的方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> scheduleFrame() {
</span></span><span style=display:flex><span>  ensureFrameCallbacksRegistered(); <span style=color:#75715e>// &lt;- 确定回调的注册
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  window.scheduleFrame(); <span style=color:#75715e>// 请求回调的执行，进行界面更新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _hasScheduledFrame <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>@</span>protected
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ensureFrameCallbacksRegistered() {
</span></span><span style=display:flex><span>  window.onBeginFrame <span style=color:#f92672>??=</span> _handleBeginFrame;
</span></span><span style=display:flex><span>  window.onDrawFrame <span style=color:#f92672>??=</span> _handleDrawFrame; <span style=color:#75715e>// &lt;- 注册回调
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>注册的这个回调其实就是对 handleDrawFrame 包了一层壳。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>void</span> _handleDrawFrame() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (_rescheduleAfterWarmUpFrame) {
</span></span><span style=display:flex><span>    _rescheduleAfterWarmUpFrame <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    addPostFrameCallback((Duration timeStamp) {
</span></span><span style=display:flex><span>      _hasScheduledFrame <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>      scheduleFrame();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  handleDrawFrame();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>window.scheduleFrame()</code> 会向 Engine 层发起一个请求，在下一次合适的时机调用<code>window.onDrawFrame</code>和 <code>window.onBeginFrame</code>注册的回调，从而刷新界面。</p><p>最后我们采用断点调试的方式，看界面刷新时 drawFrame 的完整调用链是什么样，绿框中的就是我们刚刚所讲到的那些方法了。</p><p><img loading=lazy src=./02.png alt=drawFrame调用链></p><p>到这里，知识就串起来了～</p><hr><h2 id=整理图>整理图<a hidden class=anchor aria-hidden=true href=#整理图>#</a></h2><p>我们画张图整理一下，为了让图更加简单易看，我们省略掉亿点点细节🤏。</p><p><img loading=lazy src=./yuque_diagram_1.jpg alt=yuque_diagram_1></p><hr><h2 id=framework-项目代码实验>Framework 项目代码实验<a hidden class=anchor aria-hidden=true href=#framework-项目代码实验>#</a></h2><p>当然了解完相关流程，我们直接在 Flutter Framework 的项目中进行实验，按照流程自己写一遍从 Render Tree 到界面刷新的代码，证明、也是熟悉这个流程。</p><p>首先根据官方说明配置一个 Framework 开发环境，然后进入到 hello_world 项目中：
<a href=https://github.com/flutter/flutter/wiki/Setting-up-the-Framework-development-environment>https://github.com/flutter/flutter/wiki/Setting-up-the-Framework-development-environment</a></p><p>实验项目和平时开发一样依旧采用 Flutter APP 的方式启动，但不同的是我们不调用 <code>runApp()</code> 方法，而是直接创建一颗 Render Tree 和使用 Canvas，采用上面讲的流程来执行我们的 APP。</p><p>我们先尝试使用 Canvas 绘制一条直线，然后生成 Picture 添加到 Sence 中，然后发送给 GPU 进行渲染。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;dart:ui&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;package:flutter/material.dart&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> PictureRecorder pictureRecorder <span style=color:#f92672>=</span> PictureRecorder();
</span></span><span style=display:flex><span>  drawLine(pictureRecorder);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> Picture picture <span style=color:#f92672>=</span> pictureRecorder.endRecording();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> SceneBuilder sceneBuilder <span style=color:#f92672>=</span> SceneBuilder();
</span></span><span style=display:flex><span>  sceneBuilder.addPicture(Offset.zero, picture);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> Scene scene <span style=color:#f92672>=</span> sceneBuilder.build();
</span></span><span style=display:flex><span>  window.render(scene);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> drawLine(PictureRecorder recorder) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> Canvas canvas <span style=color:#f92672>=</span> Canvas(recorder);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> Paint paint <span style=color:#f92672>=</span> Paint()
</span></span><span style=display:flex><span>    ..color <span style=color:#f92672>=</span> Colors.white
</span></span><span style=display:flex><span>    ..strokeWidth <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  canvas.drawLine(Offset(<span style=color:#ae81ff>300</span>, <span style=color:#ae81ff>300</span>), Offset(<span style=color:#ae81ff>800</span>, <span style=color:#ae81ff>300</span>), paint);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=./03.png alt=03.png></p><p>上面的代码会在界面绘制一条白线，由于这里只 render 了一次，因此在绘制完这条白线后，界面就不会有任何变化了。
现在我们尝试让线条动起来，通过上面的讲解，我们知道 Flutter 是使用 <code>window.scheduleFrame()</code>来请求屏幕的刷新，因此我们将渲染放到 <code>window.onDrawFrame</code>中，并不断改变线条位置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;dart:ui&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#39;package:flutter/material.dart&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>double</span> dy <span style=color:#f92672>=</span> <span style=color:#ae81ff>300.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  window.onDrawFrame <span style=color:#f92672>=</span> () {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> PictureRecorder pictureRecorder <span style=color:#f92672>=</span> PictureRecorder();
</span></span><span style=display:flex><span>    drawLine(pictureRecorder, dy);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (dy <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>800</span>)
</span></span><span style=display:flex><span>      dy<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Picture picture <span style=color:#f92672>=</span> pictureRecorder.endRecording();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> SceneBuilder sceneBuilder <span style=color:#f92672>=</span> SceneBuilder();
</span></span><span style=display:flex><span>    sceneBuilder.addPicture(Offset.zero, picture);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Scene scene <span style=color:#f92672>=</span> sceneBuilder.build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 不断刷新界面
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    window.render(scene);
</span></span><span style=display:flex><span>    window.scheduleFrame();
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  window.scheduleFrame();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> drawLine(PictureRecorder recorder, <span style=color:#66d9ef>double</span> dy) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> Canvas canvas <span style=color:#f92672>=</span> Canvas(recorder);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> Paint paint <span style=color:#f92672>=</span> Paint()
</span></span><span style=display:flex><span>    ..color <span style=color:#f92672>=</span> Colors.white
</span></span><span style=display:flex><span>    ..strokeWidth <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  canvas.drawLine(Offset(<span style=color:#ae81ff>300</span>, dy), Offset(<span style=color:#ae81ff>800</span>, dy), paint);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样就得到了一条会移动的直线。</p><p><img loading=lazy src=./04.gif alt=04.gif></p><p>接下来我们将上面的直线封装为一个自定义的 RenderObject，然后自己创建一颗 Render Tree，并使用 <code>drawFrame()</code> 方法中的流程：使用 <strong>PipelineOwner</strong> 来重新绘制被污染的节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 构建根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>final</span> PipelineOwner pipelineOwner <span style=color:#f92672>=</span> PipelineOwner();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> RenderView renderView <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      RenderView(configuration: <span style=color:#66d9ef>const</span> ViewConfiguration(), window: window);
</span></span><span style=display:flex><span>  pipelineOwner.rootNode <span style=color:#f92672>=</span> renderView;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  renderView.prepareInitialFrame();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  renderView.child <span style=color:#f92672>=</span> MyRenderNode();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  window.onDrawFrame <span style=color:#f92672>=</span> () {
</span></span><span style=display:flex><span>    callFlush(pipelineOwner);
</span></span><span style=display:flex><span>    renderView.compositeFrame();
</span></span><span style=display:flex><span>    window.scheduleFrame();
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  window.scheduleFrame();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> callFlush(PipelineOwner pipelineOwner) {
</span></span><span style=display:flex><span>  pipelineOwner.flushLayout();
</span></span><span style=display:flex><span>  pipelineOwner.flushCompositingBits();
</span></span><span style=display:flex><span>  pipelineOwner.flushPaint();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyRenderNode</span> <span style=color:#66d9ef>extends</span> RenderBox {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>double</span> _dy <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> Paint _paint <span style=color:#f92672>=</span> Paint()
</span></span><span style=display:flex><span>    ..color <span style=color:#f92672>=</span> Colors.white
</span></span><span style=display:flex><span>    ..strokeWidth <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> _drawLines(Canvas canvas, <span style=color:#66d9ef>double</span> dy) {
</span></span><span style=display:flex><span>    canvas.drawLine(Offset(<span style=color:#ae81ff>300</span>, dy), Offset(<span style=color:#ae81ff>800</span>, dy), _paint);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> paint(PaintingContext context, Offset offset) {
</span></span><span style=display:flex><span>    _drawLines(context.canvas, _dy);
</span></span><span style=display:flex><span>    _dy<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    markNeedsLayout();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这份代码运行的效果和上面的是一样的，但只有一个节点并不能看出转化为 Layer Tree 的优势，我们来构建一颗多个节点的 Render Tree。我们采用 <strong>RenderFlex</strong> 来存储多个节点，并和上面讲解 <code>flushLayout()</code>时所说的一样交由父节点来决定布局大小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 构建根节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>final</span> PipelineOwner pipelineOwner <span style=color:#f92672>=</span> PipelineOwner();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> RenderView renderView <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      RenderView(configuration: <span style=color:#66d9ef>const</span> ViewConfiguration(), window: window);
</span></span><span style=display:flex><span>  pipelineOwner.rootNode <span style=color:#f92672>=</span> renderView;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  renderView.prepareInitialFrame();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> RenderFlex flex <span style=color:#f92672>=</span> RenderFlex(textDirection: TextDirection.ltr);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 从 301 开始移动到 500 一共绘制了 200 次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>double</span> dy <span style=color:#f92672>=</span> <span style=color:#ae81ff>301</span>;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 创建两个叶子节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>final</span> MyRenderNode node1 <span style=color:#f92672>=</span> MyRenderNode(dy, Colors.white);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>final</span> MyRenderNode node2 <span style=color:#f92672>=</span> MyRenderNode(dy, Colors.blue);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  renderView.child <span style=color:#f92672>=</span> flex;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 注意这里是往前插入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  flex.insert(node1);
</span></span><span style=display:flex><span>  flex.insert(node2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  window.onDrawFrame <span style=color:#f92672>=</span> () {
</span></span><span style=display:flex><span>    callFlush(pipelineOwner);
</span></span><span style=display:flex><span>    renderView.compositeFrame();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (dy <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>500</span>) {
</span></span><span style=display:flex><span>      node1.dy <span style=color:#f92672>=</span> <span style=color:#f92672>++</span>dy;
</span></span><span style=display:flex><span>      window.scheduleFrame();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      print(<span style=color:#e6db74>&#39;node1 paint count: </span><span style=color:#e6db74>${</span>node1.paintCount<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>      print(<span style=color:#e6db74>&#39;node2 paint count: </span><span style=color:#e6db74>${</span>node2.paintCount<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  window.scheduleFrame();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> callFlush(PipelineOwner pipelineOwner) {
</span></span><span style=display:flex><span>  pipelineOwner.flushLayout();
</span></span><span style=display:flex><span>  pipelineOwner.flushCompositingBits();
</span></span><span style=display:flex><span>  pipelineOwner.flushPaint();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyRenderNode</span> <span style=color:#66d9ef>extends</span> RenderBox {
</span></span><span style=display:flex><span>  MyRenderNode(<span style=color:#66d9ef>this</span>._dy, Color color) {
</span></span><span style=display:flex><span>    _paint <span style=color:#f92672>=</span> Paint()
</span></span><span style=display:flex><span>      ..color <span style=color:#f92672>=</span> color
</span></span><span style=display:flex><span>      ..strokeWidth <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>double</span> _dy;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> paintCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>set</span> dy(<span style=color:#66d9ef>double</span> dy) {
</span></span><span style=display:flex><span>    _dy <span style=color:#f92672>=</span> dy;
</span></span><span style=display:flex><span>    markNeedsLayout();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>double</span> <span style=color:#66d9ef>get</span> dy <span style=color:#f92672>=&gt;</span> _dy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  late Paint _paint;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> _drawLines(Canvas canvas, <span style=color:#66d9ef>double</span> dy) {
</span></span><span style=display:flex><span>    canvas.drawLine(Offset(<span style=color:#ae81ff>300</span>, dy), Offset(<span style=color:#ae81ff>800</span>, dy), _paint);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> paint(PaintingContext context, Offset offset) {
</span></span><span style=display:flex><span>    _drawLines(context.canvas, dy);
</span></span><span style=display:flex><span>    paintCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>get</span> sizedByParent <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  Size computeDryLayout(BoxConstraints constraints) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> constraints.smallest;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这份代码比较长，对于 <code>MyRenderNode</code>的修改：</p><ul><li>首先我们重写了 <code>sizedByParent</code>和 <code>computeDryLayout()</code>，用于在布局测量时决定大小</li><li><code>_dy</code> 属性添加了 setter 方法，在每次修改 <code>_dy</code> 的值时调用 <code>markNeedsLayout()</code> 来让下一次界面刷新时重新绘制节点</li><li>另外我们还添加了一个 <code>piantCount</code> 属性来记录节点绘制了几次</li></ul><p>接着是 main 方法中：</p><ul><li>使用 RenderFlex 作为 RenderView 的子节点</li><li>创建了两个子节点插入到 RenderFlex 中</li><li>每次渲染时，都会修改 node1 的 dy，让他进行重绘，node2 则不做修改</li><li>当 dy 的值达到了 500 的时候停止界面刷新并打印两个节点的绘制次数</li></ul><p><img loading=lazy src=./05.gif alt=05.gif></p><p>效果如上，会有一根不动的蓝线，和一根移动的白线。
我们再看看控制台打印的信息。</p><p><img loading=lazy src=./06.png alt=06.png></p><p>我们发现两个节点的绘制次数都是 200，这意味着每次渲染两个节点都进行了重新绘制，根据上面我们讲到的 PaintingContext 和 Layer 的特点，我们可以很快判断出，这是由于 node1 和 node2 没有分开绘制，使用同一个 Layer 节点所造成的。</p><p>由于 node1 被污染后也会调用父节点 flex 的 <code>markNeedsPaint()</code>，因此绘制操作时由父节点向下绘制的，而 node2 也是 flex 的子节点，整棵子树都会重新绘制，这就是 node2 污染时 node1 也跟着重绘的原因。
​</p><p>我们在自定义的 RenderBox 里重写 <strong>isRepaintBoundary</strong> 属性，并在 framework 层为 <strong>ContainerLayer</strong> 添加一个节点计数方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#75715e>/// ContainerLayer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> layerCount() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 算上当前节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Layer<span style=color:#f92672>?</span> child <span style=color:#f92672>=</span> firstChild;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (child <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(child <span style=color:#66d9ef>is</span> OffsetLayer)
</span></span><span style=display:flex><span>      count <span style=color:#f92672>+=</span> child.layerCount();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    child <span style=color:#f92672>=</span> child.nextSibling;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>void</span> main() {
</span></span><span style=display:flex><span>  window.onDrawFrame <span style=color:#f92672>=</span> () {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (dy <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>500</span>) {
</span></span><span style=display:flex><span>      node1.dy <span style=color:#f92672>=</span> <span style=color:#f92672>++</span>dy;
</span></span><span style=display:flex><span>      window.scheduleFrame();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      print(<span style=color:#e6db74>&#39;node1 paint count: </span><span style=color:#e6db74>${</span>node1.paintCount<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>      print(<span style=color:#e6db74>&#39;node2 paint count: </span><span style=color:#e6db74>${</span>node2.paintCount<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 在结束时打印 Layer 的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      print(<span style=color:#e6db74>&#39;layer count: </span><span style=color:#e6db74>${</span>renderView.layer<span style=color:#f92672>?</span>.layerCount()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyRenderNode</span> <span style=color:#66d9ef>extends</span> RenderBox {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> _isRepaintBoundary <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>@</span>override
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>get</span> isRepaintBoundary <span style=color:#f92672>=&gt;</span> _isRepaintBoundary;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// 添加设置方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>set</span> isRepaintBoundary(<span style=color:#66d9ef>bool</span> v) {
</span></span><span style=display:flex><span>    _isRepaintBoundary <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们先来演示两种情况：</p><ol><li>不对两个叶子节点的 isRepaintBoundary 进行修改</li></ol><p><img loading=lazy src=./07.png alt=07.png></p><ol><li>将 node1 单独绘制：<code>node1.isRepaintBoundary = false;</code></li></ol><p><img loading=lazy src=./08.png alt=08.png></p><p>可以看到 node1 的 isRepaintBoundary 设置为 true 时， node2 只绘制了 1 次，现在 node2 的污染就不会导致 node1 重绘制了。</p><p>另外我们看到第二种情况的 Layer 节点数量分是 4，为什么会是 4 呢？</p><p>回想一下介绍 PaintingContext 创建时提供 Layout 的要求：</p><blockquote><p>当提供给 PaintingContext 的 Layer 节点不属于 OffsetLayer 时 ，会创建一个 OffsetLayer 来代替原本的 Layer，作为当前子树的根节点。</p></blockquote><p>如果我们对程序进行调试，就可以发现，虽然是以 node1、node2 的顺序插入，但实际 <code>insert()</code> 方法是往前插入，在 flex 中 node2 是处于 node1 的前面，因此 node2 会先进行绘制。</p><p>由于 node2 并没有设置单独绘制，因此会按照正常流程和 flex 绘制在同一个 PictureRecorder 中生成一个 PictureLayer 并添加到 TransformLayer 中。</p><p>node2 绘制完成之后开始绘制 node1。由于我们将 node1 设置为单独绘制，那么绘制 node1 的时候将会作为一个子树重新开始绘制，这时会重新调用 <code>_repaintCompositedChild()</code>方法，创建一个<strong>新的 PaintingContext</strong> 来传递，此时由于 node1 是一个叶子结点，本身并不附带 OffsetLayer 节点，<strong>因此会创建一个新的 OffsetLayer 给 PaintingConext</strong>，再进行绘制。</p><p><strong>绘制 node 1 时生成的 PictureLayer 添加到这个 OffsetLayout 中，完成绘制之后再将 OffsetLayout 添加到 RenderView 的 TransformLayer 中。</strong></p><p>因此第 2 种情况会得到 4 个 Layer 节点，对应的 Layer 图示如下：</p><p><img loading=lazy src=./yuque_diagram_2.jpg alt=yuque_diagram_2></p><p>我们修改一下计数方法，让它打印当前遍历的层次和节点类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>int</span> layerCount() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> deep <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>$</span>deep<span style=color:#e6db74> ==&gt; root is [</span><span style=color:#e6db74>${</span><span style=color:#66d9ef>this</span>.runtimeType<span style=color:#e6db74>}</span><span style=color:#e6db74>]&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> _layerCount(deep <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> _layerCount(<span style=color:#66d9ef>int</span> deep) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 算上当前节点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Layer<span style=color:#f92672>?</span> child <span style=color:#f92672>=</span> firstChild;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (child <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>$</span>deep<span style=color:#e6db74> ==&gt; child is [</span><span style=color:#e6db74>${</span>child.runtimeType<span style=color:#e6db74>}</span><span style=color:#e6db74>]&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(child <span style=color:#66d9ef>is</span> OffsetLayer)
</span></span><span style=display:flex><span>      count <span style=color:#f92672>+=</span> child._layerCount(deep <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    child <span style=color:#f92672>=</span> child.nextSibling;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=./09.png alt=09.png></p><p>可以看到和我们画的转化图是一样的。如果我们将 node1 和 node2 交换一下，先添加 node2 再添加 node1，使 node1 先进行绘制，那么结果会是什么样呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span>flex.insert(node2);
</span></span><span style=display:flex><span>flex.insert(node1);
</span></span></code></pre></div><p><img loading=lazy src=./10.png alt=10.png></p><p>可以看到依旧是 4 个 Layer 节点，node2 生成的 PictureLayer 依旧是 TransformLayer 的子节点。</p><p>我们看一下 RenderFlex 是如何绘制子节点的，我们通过调试进入 RenderFlex 的 <code>paint()</code> 方法，可以看到它调用的是 <code>paintDefault()</code>，也就是进行遍历依次调用<strong>当前 PaintingContext</strong> 的 <code>paintChild()</code> 绘制子节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dart data-lang=dart><span style=display:flex><span><span style=color:#66d9ef>void</span> defaultPaint(PaintingContext context, Offset offset) {
</span></span><span style=display:flex><span>  ChildType<span style=color:#f92672>?</span> child <span style=color:#f92672>=</span> firstChild;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 遍历子节点进行绘制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>while</span> (child <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ParentDataType childParentData <span style=color:#f92672>=</span> child.parentData<span style=color:#f92672>!</span> <span style=color:#f92672>as</span> ParentDataType;
</span></span><span style=display:flex><span>    context.paintChild(child, childParentData.offset <span style=color:#f92672>+</span> offset);
</span></span><span style=display:flex><span>    child <span style=color:#f92672>=</span> childParentData.nextSibling;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>RenderFlex 循环绘制时，父节点和下面的子节点用的都是同一个 PaintingContex。由于 node1 是单独绘制，因此会创建一个<strong>新的 PaintingContext 和 OffsetLayer</strong>，但绘制 node2 时还是使用<strong>父节点的 PaintingContext</strong>，所以 flex 和 node2 会一起生成一个 PictureLayer 添加到根节点中。</p><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>本文到这里就结束了，我们现在可以看到，Flutter 性能高的一个很重要的原因，就是它在资源复用和避免不必要计算等方面，做了很多思考。</p><p>之所以研究这部分，是因为这部分是 Flutter Framework 层最贴近 Engine 层的内容，对以后研究 Flutter 和 Android 两者在 Engine 层的异同点会有很大帮助。</p><p>由于涉及到的东西特别多，因此并没办法讲的很全面，本文所要介绍的内容也可能存在遗漏，但按照本文讲解的流程去阅读源码进行扩展，并不难弄懂，有问题可在评论区留言。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://answerkobe.github.io/tags/flutter/>Flutter</a></li><li><a href=http://answerkobe.github.io/tags/android/>Android</a></li></ul><nav class=paginav><a class=prev href=http://answerkobe.github.io/posts/jetpack-compose-explore/><span class=title>« Prev</span><br><span>Jetpack Compose 探索</span>
</a><a class=next href=http://answerkobe.github.io/posts/explore-the-kotlin-generics/><span class=title>Next »</span><br><span>探索 Java & Kotlin 泛型</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Flutter 绘制流程分析与代码实践 on x" href="https://x.com/intent/tweet/?text=Flutter%20%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90%e4%b8%8e%e4%bb%a3%e7%a0%81%e5%ae%9e%e8%b7%b5&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fanalysis-flutter-paint-process%2f&amp;hashtags=Flutter%2cAndroid"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Flutter 绘制流程分析与代码实践 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fanalysis-flutter-paint-process%2f&amp;title=Flutter%20%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90%e4%b8%8e%e4%bb%a3%e7%a0%81%e5%ae%9e%e8%b7%b5&amp;summary=Flutter%20%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90%e4%b8%8e%e4%bb%a3%e7%a0%81%e5%ae%9e%e8%b7%b5&amp;source=http%3a%2f%2fanswerkobe.github.io%2fposts%2fanalysis-flutter-paint-process%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Flutter 绘制流程分析与代码实践 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fanalysis-flutter-paint-process%2f&title=Flutter%20%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90%e4%b8%8e%e4%bb%a3%e7%a0%81%e5%ae%9e%e8%b7%b5"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Flutter 绘制流程分析与代码实践 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fanalysis-flutter-paint-process%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Flutter 绘制流程分析与代码实践 on whatsapp" href="https://api.whatsapp.com/send?text=Flutter%20%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90%e4%b8%8e%e4%bb%a3%e7%a0%81%e5%ae%9e%e8%b7%b5%20-%20http%3a%2f%2fanswerkobe.github.io%2fposts%2fanalysis-flutter-paint-process%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Flutter 绘制流程分析与代码实践 on telegram" href="https://telegram.me/share/url?text=Flutter%20%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90%e4%b8%8e%e4%bb%a3%e7%a0%81%e5%ae%9e%e8%b7%b5&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fanalysis-flutter-paint-process%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Flutter 绘制流程分析与代码实践 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Flutter%20%e7%bb%98%e5%88%b6%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90%e4%b8%8e%e4%bb%a3%e7%a0%81%e5%ae%9e%e8%b7%b5&u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fanalysis-flutter-paint-process%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script id=utteranc src=https://utteranc.es/client.js repo=Answerkobe/utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.body.className.includes("dark")?"github-light":"photon-dark",t={type:"set-theme",theme:e},n=document.querySelector(".utterances-frame");n.contentWindow.postMessage(t,"https://utteranc.es")})</script></article></main><footer class=footer><span>&copy; 2023 <a href=http://answerkobe.github.io/>Iverson's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>