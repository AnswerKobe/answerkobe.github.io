<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="upgrade-insecure-requests"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ArrayList 与 LinkedList 底层结构 | Iverson's blog</title>
<meta name=keywords content="Java"><meta name=description content="在 Java 中，数组可用来存储相同类型的多个数据，但由于长度不可变，在某些场景下使用比较局限。当我们希望使用类似数组的结构来存储未知个数的元素时，可以使用 ArrayList<E> 和 LinkedList<E>，它们都是 Java Collection Framework 的成员，相比普通的数组，它们提供了更多的操作来方便我们开发。由于底层使用的数据结构不同，它们也经常被拿来做比较。
继承关系 ArrayList 属于 List<E> 接口中的一个 可变长数组 实现，直接 extends AbstractList<E> abstract 类。其继承关系如下：
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable LinkedList 直接 extends AbstractSequentialList<E> abstract 类，间接 extends AbstractList<E>，由于 LinkedList 也实现了 Deque<E> 接口，所以它属于 List<E> 和 Queue<E> 接口的实现。
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable ArrayList 底层结构 对于 ArrayList，Java API 对它的第一句描述为 “Resizable-array implementation of the List interface”。其底层存储元素的结构为 Object 数组。"><meta name=author content><link rel=canonical href=http://answerkobe.github.io/posts/arraylist-and-linkedlist-principle/><link crossorigin=anonymous href=/assets/css/stylesheet.81e9c84b86321fe9cfdf9f01a2f8060920d09e0fec45cb91f131cfed0284007e.css integrity="sha256-genIS4YyH+nP358BovgGCSDQng/sRcuR8THP7QKEAH4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://answerkobe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://answerkobe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://answerkobe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://answerkobe.github.io/apple-touch-icon.png><link rel=mask-icon href=http://answerkobe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4112QEXZJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4112QEXZJ",{anonymize_ip:!1})}</script><meta property="og:title" content="ArrayList 与 LinkedList 底层结构"><meta property="og:description" content="在 Java 中，数组可用来存储相同类型的多个数据，但由于长度不可变，在某些场景下使用比较局限。当我们希望使用类似数组的结构来存储未知个数的元素时，可以使用 ArrayList<E> 和 LinkedList<E>，它们都是 Java Collection Framework 的成员，相比普通的数组，它们提供了更多的操作来方便我们开发。由于底层使用的数据结构不同，它们也经常被拿来做比较。
继承关系 ArrayList 属于 List<E> 接口中的一个 可变长数组 实现，直接 extends AbstractList<E> abstract 类。其继承关系如下：
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable LinkedList 直接 extends AbstractSequentialList<E> abstract 类，间接 extends AbstractList<E>，由于 LinkedList 也实现了 Deque<E> 接口，所以它属于 List<E> 和 Queue<E> 接口的实现。
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable ArrayList 底层结构 对于 ArrayList，Java API 对它的第一句描述为 “Resizable-array implementation of the List interface”。其底层存储元素的结构为 Object 数组。"><meta property="og:type" content="article"><meta property="og:url" content="http://answerkobe.github.io/posts/arraylist-and-linkedlist-principle/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-24T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-24T00:00:00+00:00"><meta property="og:site_name" content="Iverson"><meta name=twitter:card content="summary"><meta name=twitter:title content="ArrayList 与 LinkedList 底层结构"><meta name=twitter:description content="在 Java 中，数组可用来存储相同类型的多个数据，但由于长度不可变，在某些场景下使用比较局限。当我们希望使用类似数组的结构来存储未知个数的元素时，可以使用 ArrayList<E> 和 LinkedList<E>，它们都是 Java Collection Framework 的成员，相比普通的数组，它们提供了更多的操作来方便我们开发。由于底层使用的数据结构不同，它们也经常被拿来做比较。
继承关系 ArrayList 属于 List<E> 接口中的一个 可变长数组 实现，直接 extends AbstractList<E> abstract 类。其继承关系如下：
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable LinkedList 直接 extends AbstractSequentialList<E> abstract 类，间接 extends AbstractList<E>，由于 LinkedList 也实现了 Deque<E> 接口，所以它属于 List<E> 和 Queue<E> 接口的实现。
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable ArrayList 底层结构 对于 ArrayList，Java API 对它的第一句描述为 “Resizable-array implementation of the List interface”。其底层存储元素的结构为 Object 数组。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://answerkobe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ArrayList 与 LinkedList 底层结构","item":"http://answerkobe.github.io/posts/arraylist-and-linkedlist-principle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ArrayList 与 LinkedList 底层结构","name":"ArrayList 与 LinkedList 底层结构","description":"在 Java 中，数组可用来存储相同类型的多个数据，但由于长度不可变，在某些场景下使用比较局限。当我们希望使用类似数组的结构来存储未知个数的元素时，可以使用 ArrayList\u0026lt;E\u0026gt; 和 LinkedList\u0026lt;E\u0026gt;，它们都是 Java Collection Framework 的成员，相比普通的数组，它们提供了更多的操作来方便我们开发。由于底层使用的数据结构不同，它们也经常被拿来做比较。\n继承关系 ArrayList 属于 List\u0026lt;E\u0026gt; 接口中的一个 可变长数组 实现，直接 extends AbstractList\u0026lt;E\u0026gt; abstract 类。其继承关系如下：\npublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable LinkedList 直接 extends AbstractSequentialList\u0026lt;E\u0026gt; abstract 类，间接 extends AbstractList\u0026lt;E\u0026gt;，由于 LinkedList 也实现了 Deque\u0026lt;E\u0026gt; 接口，所以它属于 List\u0026lt;E\u0026gt; 和 Queue\u0026lt;E\u0026gt; 接口的实现。\npublic class LinkedList\u0026lt;E\u0026gt; extends AbstractSequentialList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, Deque\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable ArrayList 底层结构 对于 ArrayList，Java API 对它的第一句描述为 “Resizable-array implementation of the List interface”。其底层存储元素的结构为 Object 数组。","keywords":["Java"],"articleBody":"在 Java 中，数组可用来存储相同类型的多个数据，但由于长度不可变，在某些场景下使用比较局限。当我们希望使用类似数组的结构来存储未知个数的元素时，可以使用 ArrayList 和 LinkedList，它们都是 Java Collection Framework 的成员，相比普通的数组，它们提供了更多的操作来方便我们开发。由于底层使用的数据结构不同，它们也经常被拿来做比较。\n继承关系 ArrayList 属于 List 接口中的一个 可变长数组 实现，直接 extends AbstractList abstract 类。其继承关系如下：\npublic class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable LinkedList 直接 extends AbstractSequentialList abstract 类，间接 extends AbstractList，由于 LinkedList 也实现了 Deque 接口，所以它属于 List 和 Queue 接口的实现。\npublic class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e implements List\u003cE\u003e, Deque\u003cE\u003e, Cloneable, java.io.Serializable ArrayList 底层结构 对于 ArrayList，Java API 对它的第一句描述为 “Resizable-array implementation of the List interface”。其底层存储元素的结构为 Object 数组。\nprivate static final int DEFAULT_CAPACITY = 10; private static final Object[] EMPTY_ELEMENTDATA = {}; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; transient Object[] elementData; ArrayList 存储元素的数组对象变量名为 elementData，在使用 new ArrayList() 创建对象时使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA（一个长度为 0 的数组）来对 elementData 进行初始化。\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } ArrayList 有一个构造方法 ArrayList(int initialCapacity) 让我们传入一个 int 类型的参数，这可以让我们在创建 ArrayList 对象时对 elementData 进行自定义的初始化，ArrayList 会将传入的 initialCapacity 参数来作为初始化 elementData 的长度。当 initialCapacity 是 0 时，使用 EMPTY_ELEMENTDATA 以一个长度为 0 的数组来初始化 elementData。\nprivate static final Object[] EMPTY_ELEMENTDATA = {}; public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } 可变长原理 ArrayList 使用数组来存储元素，而数组长度是固定的，添加的元素数量可能会超过数组容量，并且如果我们创建 ArrayList 对象时不指定 initialCapacity 或指定为 0 的话，那么 elementData 的长度是 0，无法放入元素。因此如果希望 ArrayList 是可变长的，需要有一个扩容机制。\n在 ArrayList 中，每次添加元素都会先调用 ensureCapacityInternal(int minCapacity) 方法，之后才会进行添加操作，只要完成了添加操作，add(E e) 方法总是会返回 true 来表示添加成功。那么关键的代码就在于 ensureCapacityInternal 这个方法做了哪些操作。\npublic boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } private static final int DEFAULT_CAPACITY = 10; private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length \u003e 0) grow(minCapacity); } ensureCapacityInternal 方法传入的参数 minCapacity 为进行添加操作时 elementData 所需的最小容量，方法内可以分为两步操作：\n第一步调用 calculateCapacity(Object[] elementData, int minCapacity) 来计算 elementData 所需容量。\n当 elementData 为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，代表 elementData 需要进行初始化扩容。ArrayList 中有一个默认的数组初始化容量大小 DEFAULT_CAPACITY = 10，ArrayList 添加第一个元素时，以该值作为数组长度进行初始化扩容。 由于 ArrayList 中有 addAll(int index, Collection\u003c? extends E\u003e c) 方法来添加多个元素，添加的元素个数可能比 DEFAULT_CAPACITY 的值要大，因此需要比较 minCapacity 与 DEFAULT_CAPACITY 的大小，取大的一个作为 elementData 所需容量进行返回。 当 elementData 已经进行过初始化扩容时，直接将 minCapacity 作为所需容量返回。 第二步调用 ensureExplicitCapacity(int minCapacity) 方法根据所需容量大小来判断是否需要进行扩容，如果所需容量大于当前 elementData 的容量，则调用 grow(int minCapacity) 方法进行扩容操作。\n扩容方式 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); if (newCapacity - minCapacity \u003c 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity \u003c 0) // overflow throw new OutOfMemoryError(); return (minCapacity \u003e MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } grow 方法中扩容方式为使用 Arrays.copyOf(T[] original, int newLength) 方法来生成一个包含原数组元素的新数组，而新数组容量 newCapacity 取决于 oldCapacity（原本 elementData 的容量），在原本 elementData 的容量上增加一半，这个操作通过对 oldCapacity 进行右移完成。\n当得到的 newCapacity 比所需的最小容量小时，将会直接使用 minCapacity 作为 newCapacity 的值。\n当 elementData 为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，代表原本长度为 0，则 newCapacity 的值也为 0，那么 newCapacity - minCapacity 将会小于 0，此时新数组容量将会变成 minCapacity，也就是 DEFAULT_CAPACITY，从而初步扩容出一个容量为 10 的 elementData。\n最大容量 ArrayList 存放元素的结构为数组，因此 ArrayList 的最大容量也取决于数组的最大容量。\n在 ArrayList 中使用 MAX_ARRAY_SIZE 来代表数组最大长度，数组的长度定义为非负的 int 类型，因此数组的最大长度为 int 类型的最大值。由于在一些虚拟机中，一个数组还包括头部等内容，因此最大长度可能会比 int 的最大值要小，所以 ArrayList 的 MAX_ARRAY_SIZE 的值为 Integer.MAX_VALUE - 8；\n当通过计算得出的 newCapacity 大小比 MAX_ARRAY_SIZE 大时，将会调用 hugeCapacity(int minCapacity) 来尝试获取数组的可能的最大值来作为 newCapacity 的值。\n当 minCapacity 的值为负数时，代表所需最小容量超过了 int 类型最大值，发生了溢出，此时将会在 hugeCapacity 方法内主动抛出 OutOfMemoryError。如果不为负数时，当 minCapacity 比 MAX_ARRAY_SIZE 大的话，则尝试使用 Integer.MAX_VALUE 来作为容量大小，否则使用 MAX_ARRAY_SIZE。\nLinkedList 链表结构 LinkedList 的底层使用的结构是双向 Node 链表，在 LinkedList 中有 first 和 last 两个变量，分别指向链表的第一个节点和最后一个节点，默认为 null，并用 size 来存储链表的长度。Node 节点创建时，必须传入节点值和前后节点，因此 Node 类中没有无参构造方法。\ntransient int size = 0; transient Node\u003cE\u003e first; transient Node\u003cE\u003e last; private static class Node\u003cE\u003e { E item; Node\u003cE\u003e next; Node\u003cE\u003e prev; Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) { this.item = element; this.next = next; this.prev = prev; } } 头尾操作 private void linkFirst(E e) { final Node\u003cE\u003e f = first; final Node\u003cE\u003e newNode = new Node\u003c\u003e(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; } void linkLast(E e) { final Node\u003cE\u003e l = last; final Node\u003cE\u003e newNode = new Node\u003c\u003e(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } LinkedList 中使用 linkFirst 和 linkLast 来将节点添加到首部和尾部，当我们使用添加方法来添加节点时，都是使用这几个方法完成。\npublic boolean add(E e) { linkLast(e); return true; } public void addFirst(E e) { linkFirst(e); } public void addLast(E e) { linkLast(e); } 此外还有一个 linkBefore 来将节点插入到指定位置，但它并不是总被调用，当添加的位置刚好在链表末尾时，则使用 linkLast 来完成插入操作。\nvoid linkBefore(E e, Node\u003cE\u003e succ) { // assert succ != null; final Node\u003cE\u003e pred = succ.prev; final Node\u003cE\u003e newNode = new Node\u003c\u003e(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); } 作为队列使用 由于实现了 Deque 接口，LinkedList 也可以作为队列来使用，我们可以同时使用 Queue 的方法来操作元素。但当一个 LinkedList 具有特定的含义并明确为一个队列时，应当声明为 Deque 类型，避免使用链表操作干扰队列正常的进出流程。\nclass E { /* Deque Element Type */ } Deque\u003cE\u003e deque = new LinkedList\u003c\u003e(); 区别和使用场景 ArrayList 由于其底层结构为数组这一特点，在使用 get 通过获取元素时，可以通过下标直接映射到相对应的元素，随机访问时所需时间复杂度为 O(1)。但在插入时，需要对插入位置和后面的元素进行移动，在 ArrayList 的 size 比较大时，这可能需要花费较多的时间。\npublic void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 在 ArrayList 中，这一操作使用 System.arraycopy() 来对需要移动的元素进行复制，从而提高元素移动操作的效率，但每次添加或插入元素时，不可避免地需要调用 ensureCapacityInternal 来判断所需容量是否足够，当不充足时需要进行扩容操作。\nArrayList 使用数组来存储元素，在扩容时会出现没有使用的空间，造成空间浪费，在数据量越大的情况下，造成的空间浪费可能会越大。\nLinkedList 底层的数据结构为链表，每次查询元素时，需要移动指针来查找对应元素，随机访问时的时间复杂度为 O(n)，要比 ArrayList 慢的多，但在顺序访问的情况下，两者并没有太大区别。而插入时只需要修改前后节点指向，不需要直接移动链表中的元素，效率比 ArrayList 要高。\n由于链表需要为每一个节点创建一个 Node 对象，来存储数据的引用和前后节点的引用，因此每一个节点所占用的内存会比 ArrayList 一个元素占用的多。大部分情况下，或在不考虑 ArrayList 空间浪费的情况下，LinkedList 的开销会比 ArrayList 大。\n因此，ArrayList 更适合于简单的存储、随机访问对应位置数据的场景，如果需要频繁对容器的元素进行增删操作，那么可以使用 LinkedList 来提高代码的性能。\n参考 JDK 1.8 源码 与 Java API 文档：\nhttps://docs.oracle.com/javase/8/docs/api/java/util/List.html\nhttps://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html\nhttps://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html\n","wordCount":"842","inLanguage":"en","datePublished":"2021-04-24T00:00:00Z","dateModified":"2021-04-24T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://answerkobe.github.io/posts/arraylist-and-linkedlist-principle/"},"publisher":{"@type":"Organization","name":"Iverson's blog","logo":{"@type":"ImageObject","url":"http://answerkobe.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://answerkobe.github.io/ accesskey=h title="Iverson's blog (Alt + H)">Iverson's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://answerkobe.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=http://answerkobe.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=http://answerkobe.github.io/profile title=Profile-X><span>Profile-X</span></a></li><li><a href=http://answerkobe.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://answerkobe.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://answerkobe.github.io/posts/>Posts</a></div><h1 class=post-title>ArrayList 与 LinkedList 底层结构</h1><div class=post-meta><span title='2021-04-24 00:00:00 +0000 UTC'>April 24, 2021</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%bb%a7%e6%89%bf%e5%85%b3%e7%b3%bb aria-label=继承关系>继承关系</a></li><li><a href=#arraylist aria-label=ArrayList>ArrayList</a><ul><li><a href=#%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84 aria-label=底层结构>底层结构</a></li><li><a href=#%e5%8f%af%e5%8f%98%e9%95%bf%e5%8e%9f%e7%90%86 aria-label=可变长原理>可变长原理</a></li><li><a href=#%e6%89%a9%e5%ae%b9%e6%96%b9%e5%bc%8f aria-label=扩容方式>扩容方式</a></li><li><a href=#%e6%9c%80%e5%a4%a7%e5%ae%b9%e9%87%8f aria-label=最大容量>最大容量</a></li></ul></li><li><a href=#linkedlist aria-label=LinkedList>LinkedList</a><ul><li><a href=#%e9%93%be%e8%a1%a8%e7%bb%93%e6%9e%84 aria-label=链表结构>链表结构</a></li><li><a href=#%e5%a4%b4%e5%b0%be%e6%93%8d%e4%bd%9c aria-label=头尾操作>头尾操作</a></li><li><a href=#%e4%bd%9c%e4%b8%ba%e9%98%9f%e5%88%97%e4%bd%bf%e7%94%a8 aria-label=作为队列使用>作为队列使用</a></li></ul></li><li><a href=#%e5%8c%ba%e5%88%ab%e5%92%8c%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af aria-label=区别和使用场景>区别和使用场景</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>在 Java 中，数组可用来存储相同类型的多个数据，但由于长度不可变，在某些场景下使用比较局限。当我们希望使用类似数组的结构来存储未知个数的元素时，可以使用 <code>ArrayList&lt;E></code> 和 <code>LinkedList&lt;E></code>，它们都是 <strong>Java Collection Framework</strong> 的成员，相比普通的数组，它们提供了更多的操作来方便我们开发。由于底层使用的数据结构不同，它们也经常被拿来做比较。</p><h2 id=继承关系>继承关系<a hidden class=anchor aria-hidden=true href=#继承关系>#</a></h2><p>ArrayList 属于 <code>List&lt;E></code> 接口中的一个 <strong>可变长数组</strong> 实现，直接 extends <code>AbstractList&lt;E></code> abstract 类。其继承关系如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ArrayList</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> AbstractList<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>implements</span> List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span>, RandomAccess, Cloneable, java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Serializable</span>
</span></span></code></pre></div><p><img loading=lazy src=./ArrayList.png alt=ArrayList></p><p>LinkedList 直接 extends <code>AbstractSequentialList&lt;E></code> abstract 类，间接 extends <code>AbstractList&lt;E></code>，由于 LinkedList 也实现了 <code>Deque&lt;E></code> 接口，所以它属于 <code>List&lt;E></code> 和 <code>Queue&lt;E></code> 接口的实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LinkedList</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> AbstractSequentialList<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>implements</span> List<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span>, Deque<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span>, Cloneable, java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Serializable</span>
</span></span></code></pre></div><p><img loading=lazy src=./LinkedList.png alt=LinkedList></p><h2 id=arraylist>ArrayList<a hidden class=anchor aria-hidden=true href=#arraylist>#</a></h2><h3 id=底层结构>底层结构<a hidden class=anchor aria-hidden=true href=#底层结构>#</a></h3><p>对于 ArrayList，Java API 对它的第一句描述为 “Resizable-array implementation of the List interface”。其底层存储元素的结构为 Object 数组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> DEFAULT_CAPACITY <span style=color:#f92672>=</span> 10;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> EMPTY_ELEMENTDATA <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>transient</span> Object<span style=color:#f92672>[]</span> elementData;
</span></span></code></pre></div><p>ArrayList 存储元素的数组对象变量名为 elementData，在使用 <code>new ArrayList()</code> 创建对象时使用 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>（一个长度为 0 的数组）来对 elementData 进行初始化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ArrayList</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>elementData</span> <span style=color:#f92672>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ArrayList 有一个构造方法 <code>ArrayList(int initialCapacity)</code> 让我们传入一个 int 类型的参数，这可以让我们在创建 ArrayList 对象时对 elementData 进行自定义的初始化，ArrayList 会将传入的 initialCapacity 参数来作为初始化 elementData 的长度。当 initialCapacity 是 0 时，使用 <code>EMPTY_ELEMENTDATA</code> 以一个长度为 0 的数组来初始化 elementData。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Object<span style=color:#f92672>[]</span> EMPTY_ELEMENTDATA <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ArrayList</span>(<span style=color:#66d9ef>int</span> initialCapacity) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (initialCapacity <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>elementData</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>initialCapacity<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (initialCapacity <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>elementData</span> <span style=color:#f92672>=</span> EMPTY_ELEMENTDATA;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;Illegal Capacity: &#34;</span><span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                                            initialCapacity);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=可变长原理>可变长原理<a hidden class=anchor aria-hidden=true href=#可变长原理>#</a></h3><p>ArrayList 使用数组来存储元素，而数组长度是固定的，添加的元素数量可能会超过数组容量，并且如果我们创建 ArrayList 对象时不指定 initialCapacity 或指定为 0 的话，那么 elementData 的长度是 0，无法放入元素。因此如果希望 ArrayList 是可变长的，需要有一个扩容机制。</p><p>在 ArrayList 中，每次添加元素都会先调用 <code>ensureCapacityInternal(int minCapacity)</code> 方法，之后才会进行添加操作，只要完成了添加操作，<code>add(E e)</code> 方法总是会返回 true 来表示添加成功。那么关键的代码就在于 <code>ensureCapacityInternal</code> 这个方法做了哪些操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>add</span>(E e) {
</span></span><span style=display:flex><span>    ensureCapacityInternal(size <span style=color:#f92672>+</span> 1);  <span style=color:#75715e>// Increments modCount!!</span>
</span></span><span style=display:flex><span>    elementData<span style=color:#f92672>[</span>size<span style=color:#f92672>++]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> DEFAULT_CAPACITY <span style=color:#f92672>=</span> 10;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ensureCapacityInternal</span>(<span style=color:#66d9ef>int</span> minCapacity) {
</span></span><span style=display:flex><span>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>calculateCapacity</span>(Object<span style=color:#f92672>[]</span> elementData, <span style=color:#66d9ef>int</span> minCapacity) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (elementData <span style=color:#f92672>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Math.<span style=color:#a6e22e>max</span>(DEFAULT_CAPACITY, minCapacity);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> minCapacity;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ensureExplicitCapacity</span>(<span style=color:#66d9ef>int</span> minCapacity) {
</span></span><span style=display:flex><span>    modCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// overflow-conscious code</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (minCapacity <span style=color:#f92672>-</span> elementData.<span style=color:#a6e22e>length</span> <span style=color:#f92672>&gt;</span> 0)
</span></span><span style=display:flex><span>        grow(minCapacity);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ensureCapacityInternal</code> 方法传入的参数 minCapacity 为进行添加操作时 elementData 所需的最小容量，方法内可以分为两步操作：</p><ol><li><p>第一步调用 <code>calculateCapacity(Object[] elementData, int minCapacity)</code> 来计算 elementData 所需容量。</p><ul><li>当 elementData 为 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 时，代表 elementData 需要进行初始化扩容。ArrayList 中有一个默认的数组初始化容量大小 <code>DEFAULT_CAPACITY = 10</code>，ArrayList 添加第一个元素时，以该值作为数组长度进行初始化扩容。</li><li>由于 ArrayList 中有 <code>addAll(int index, Collection&lt;? extends E> c)</code> 方法来添加多个元素，添加的元素个数可能比 <code>DEFAULT_CAPACITY</code> 的值要大，因此需要比较 minCapacity 与 <code>DEFAULT_CAPACITY</code> 的大小，取大的一个作为 elementData 所需容量进行返回。</li><li>当 elementData 已经进行过初始化扩容时，直接将 minCapacity 作为所需容量返回。</li></ul></li><li><p>第二步调用 <code>ensureExplicitCapacity(int minCapacity)</code> 方法根据所需容量大小来判断是否需要进行扩容，如果所需容量大于当前 elementData 的容量，则调用 <code>grow(int minCapacity)</code> 方法进行扩容操作。</p></li></ol><h3 id=扩容方式>扩容方式<a hidden class=anchor aria-hidden=true href=#扩容方式>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> MAX_ARRAY_SIZE <span style=color:#f92672>=</span> Integer.<span style=color:#a6e22e>MAX_VALUE</span> <span style=color:#f92672>-</span> 8;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>grow</span>(<span style=color:#66d9ef>int</span> minCapacity) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// overflow-conscious code</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> oldCapacity <span style=color:#f92672>=</span> elementData.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> newCapacity <span style=color:#f92672>=</span> oldCapacity <span style=color:#f92672>+</span> (oldCapacity <span style=color:#f92672>&gt;&gt;</span> 1);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newCapacity <span style=color:#f92672>-</span> minCapacity <span style=color:#f92672>&lt;</span> 0)
</span></span><span style=display:flex><span>        newCapacity <span style=color:#f92672>=</span> minCapacity;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newCapacity <span style=color:#f92672>-</span> MAX_ARRAY_SIZE <span style=color:#f92672>&gt;</span> 0)
</span></span><span style=display:flex><span>        newCapacity <span style=color:#f92672>=</span> hugeCapacity(minCapacity);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// minCapacity is usually close to size, so this is a win:</span>
</span></span><span style=display:flex><span>    elementData <span style=color:#f92672>=</span> Arrays.<span style=color:#a6e22e>copyOf</span>(elementData, newCapacity);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>hugeCapacity</span>(<span style=color:#66d9ef>int</span> minCapacity) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (minCapacity <span style=color:#f92672>&lt;</span> 0) <span style=color:#75715e>// overflow</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> OutOfMemoryError();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (minCapacity <span style=color:#f92672>&gt;</span> MAX_ARRAY_SIZE) <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>        Integer.<span style=color:#a6e22e>MAX_VALUE</span> :
</span></span><span style=display:flex><span>        MAX_ARRAY_SIZE;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>grow</code> 方法中扩容方式为使用 <code>Arrays.copyOf(T[] original, int newLength)</code> 方法来生成一个包含原数组元素的新数组，而新数组容量 newCapacity 取决于 oldCapacity（原本 elementData 的容量），在原本 elementData 的容量上增加一半，这个操作通过对 oldCapacity 进行右移完成。</p><p>当得到的 newCapacity 比所需的最小容量小时，将会直接使用 minCapacity 作为 newCapacity 的值。</p><p>当 elementData 为 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 时，代表原本长度为 0，则 newCapacity 的值也为 0，那么 newCapacity - minCapacity 将会小于 0，此时新数组容量将会变成 minCapacity，也就是 DEFAULT_CAPACITY，从而初步扩容出一个容量为 10 的 elementData。</p><h3 id=最大容量>最大容量<a hidden class=anchor aria-hidden=true href=#最大容量>#</a></h3><p>ArrayList 存放元素的结构为数组，因此 ArrayList 的最大容量也取决于数组的最大容量。</p><p>在 ArrayList 中使用 <code>MAX_ARRAY_SIZE</code> 来代表数组最大长度，数组的长度定义为非负的 int 类型，因此数组的最大长度为 int 类型的最大值。由于在一些虚拟机中，一个数组还包括头部等内容，因此最大长度可能会比 int 的最大值要小，所以 ArrayList 的 <code>MAX_ARRAY_SIZE</code> 的值为 <code>Integer.MAX_VALUE - 8</code>；</p><p>当通过计算得出的 newCapacity 大小比 MAX_ARRAY_SIZE 大时，将会调用 <code>hugeCapacity(int minCapacity)</code> 来尝试获取数组的可能的最大值来作为 newCapacity 的值。</p><p>当 minCapacity 的值为负数时，代表所需最小容量超过了 int 类型最大值，发生了溢出，此时将会在 hugeCapacity 方法内主动抛出 <code>OutOfMemoryError</code>。如果不为负数时，当 minCapacity 比 <code>MAX_ARRAY_SIZE</code> 大的话，则尝试使用 <code>Integer.MAX_VALUE</code> 来作为容量大小，否则使用 <code>MAX_ARRAY_SIZE</code>。</p><h2 id=linkedlist>LinkedList<a hidden class=anchor aria-hidden=true href=#linkedlist>#</a></h2><h3 id=链表结构>链表结构<a hidden class=anchor aria-hidden=true href=#链表结构>#</a></h3><p>LinkedList 的底层使用的结构是<strong>双向 Node 链表</strong>，在 LinkedList 中有 <code>first</code> 和 <code>last</code> 两个变量，分别指向链表的第一个节点和最后一个节点，默认为 null，并用 size 来存储链表的长度。Node 节点创建时，必须传入节点值和前后节点，因此 Node 类中没有无参构造方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>transient</span> <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>transient</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> first;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>transient</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> last;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    E item;
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> next;
</span></span><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> prev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Node(Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> prev, E element, Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> next) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>item</span> <span style=color:#f92672>=</span> element;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> prev;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=头尾操作>头尾操作<a hidden class=anchor aria-hidden=true href=#头尾操作>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>linkFirst</span>(E e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> f <span style=color:#f92672>=</span> first;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(<span style=color:#66d9ef>null</span>, e, f);
</span></span><span style=display:flex><span>    first <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        last <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        f.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    modCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>linkLast</span>(E e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> l <span style=color:#f92672>=</span> last;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(l, e, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    last <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        first <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        l.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    modCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>LinkedList 中使用 <code>linkFirst</code> 和 <code>linkLast</code> 来将节点添加到首部和尾部，当我们使用添加方法来添加节点时，都是使用这几个方法完成。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>add</span>(E e) {
</span></span><span style=display:flex><span>    linkLast(e);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addFirst</span>(E e) {
</span></span><span style=display:flex><span>    linkFirst(e);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addLast</span>(E e) {
</span></span><span style=display:flex><span>    linkLast(e);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此外还有一个 <code>linkBefore</code> 来将节点插入到指定位置，但它并不是总被调用，当添加的位置刚好在链表末尾时，则使用 <code>linkLast</code> 来完成插入操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>linkBefore</span>(E e, Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> succ) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assert succ != null;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> pred <span style=color:#f92672>=</span> succ.<span style=color:#a6e22e>prev</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Node<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> newNode <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node<span style=color:#f92672>&lt;&gt;</span>(pred, e, succ);
</span></span><span style=display:flex><span>    succ.<span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pred <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        first <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        pred.<span style=color:#a6e22e>next</span> <span style=color:#f92672>=</span> newNode;
</span></span><span style=display:flex><span>    size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    modCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> index, E element) {
</span></span><span style=display:flex><span>    checkPositionIndex(index);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>==</span> size)
</span></span><span style=display:flex><span>        linkLast(element);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        linkBefore(element, node(index));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=作为队列使用>作为队列使用<a hidden class=anchor aria-hidden=true href=#作为队列使用>#</a></h3><p>由于实现了 <code>Deque&lt;E></code> 接口，LinkedList 也可以作为队列来使用，我们可以同时使用 Queue 的方法来操作元素。但当一个 LinkedList 具有特定的含义并明确为一个队列时，应当声明为 Deque 类型，避免使用链表操作干扰队列正常的进出流程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>E</span> { <span style=color:#75715e>/* Deque Element Type */</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Deque<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> deque <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedList<span style=color:#f92672>&lt;&gt;</span>();
</span></span></code></pre></div><h2 id=区别和使用场景>区别和使用场景<a hidden class=anchor aria-hidden=true href=#区别和使用场景>#</a></h2><p>ArrayList 由于其底层结构为数组这一特点，在使用 get 通过获取元素时，可以通过下标直接映射到相对应的元素，随机访问时所需时间复杂度为 O(1)。但在插入时，需要对插入位置和后面的元素进行移动，在 ArrayList 的 size 比较大时，这可能需要花费较多的时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> index, E element) {
</span></span><span style=display:flex><span>    rangeCheckForAdd(index);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ensureCapacityInternal(size <span style=color:#f92672>+</span> 1);  <span style=color:#75715e>// Increments modCount!!</span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>arraycopy</span>(elementData, index, elementData, index <span style=color:#f92672>+</span> 1,
</span></span><span style=display:flex><span>                        size <span style=color:#f92672>-</span> index);
</span></span><span style=display:flex><span>    elementData<span style=color:#f92672>[</span>index<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> element;
</span></span><span style=display:flex><span>    size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 ArrayList 中，这一操作使用 <code>System.arraycopy()</code> 来对需要移动的元素进行复制，从而提高元素移动操作的效率，但每次添加或插入元素时，不可避免地需要调用 <code>ensureCapacityInternal</code> 来判断所需容量是否足够，当不充足时需要进行扩容操作。</p><p>ArrayList 使用数组来存储元素，在扩容时会出现没有使用的空间，造成空间浪费，在数据量越大的情况下，造成的空间浪费可能会越大。</p><p><img loading=lazy src=./WasteOfSpace.jpg alt=空间浪费></p><p>LinkedList 底层的数据结构为链表，每次查询元素时，需要移动指针来查找对应元素，随机访问时的时间复杂度为 O(n)，要比 ArrayList 慢的多，但在顺序访问的情况下，两者并没有太大区别。而插入时只需要修改前后节点指向，不需要直接移动链表中的元素，效率比 ArrayList 要高。</p><p>由于链表需要为每一个节点创建一个 Node 对象，来存储数据的引用和前后节点的引用，因此每一个节点所占用的内存会比 ArrayList 一个元素占用的多。大部分情况下，或在不考虑 ArrayList 空间浪费的情况下，LinkedList 的开销会比 ArrayList 大。</p><p>因此，ArrayList 更适合于简单的存储、随机访问对应位置数据的场景，如果需要频繁对容器的元素进行增删操作，那么可以使用 LinkedList 来提高代码的性能。</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><blockquote><p>JDK 1.8 源码 与 Java API 文档：</p><p><a href=https://docs.oracle.com/javase/8/docs/api/java/util/List.html>https://docs.oracle.com/javase/8/docs/api/java/util/List.html</a></p><p><a href=https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html>https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html</a></p><p><a href=https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html>https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=http://answerkobe.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=http://answerkobe.github.io/posts/vector-and-stack/><span class=title>« Prev</span><br><span>被遗弃的 Vector 和 Stack</span>
</a><a class=next href=http://answerkobe.github.io/posts/how-to-read-java-byte-code/><span class=title>Next »</span><br><span>如何阅读 Java 字节码（Byte Code）</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ArrayList 与 LinkedList 底层结构 on x" href="https://x.com/intent/tweet/?text=ArrayList%20%e4%b8%8e%20LinkedList%20%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2farraylist-and-linkedlist-principle%2f&amp;hashtags=Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ArrayList 与 LinkedList 底层结构 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2farraylist-and-linkedlist-principle%2f&amp;title=ArrayList%20%e4%b8%8e%20LinkedList%20%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84&amp;summary=ArrayList%20%e4%b8%8e%20LinkedList%20%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84&amp;source=http%3a%2f%2fanswerkobe.github.io%2fposts%2farraylist-and-linkedlist-principle%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ArrayList 与 LinkedList 底层结构 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fanswerkobe.github.io%2fposts%2farraylist-and-linkedlist-principle%2f&title=ArrayList%20%e4%b8%8e%20LinkedList%20%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ArrayList 与 LinkedList 底层结构 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fanswerkobe.github.io%2fposts%2farraylist-and-linkedlist-principle%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ArrayList 与 LinkedList 底层结构 on whatsapp" href="https://api.whatsapp.com/send?text=ArrayList%20%e4%b8%8e%20LinkedList%20%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84%20-%20http%3a%2f%2fanswerkobe.github.io%2fposts%2farraylist-and-linkedlist-principle%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ArrayList 与 LinkedList 底层结构 on telegram" href="https://telegram.me/share/url?text=ArrayList%20%e4%b8%8e%20LinkedList%20%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2farraylist-and-linkedlist-principle%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ArrayList 与 LinkedList 底层结构 on ycombinator" href="https://news.ycombinator.com/submitlink?t=ArrayList%20%e4%b8%8e%20LinkedList%20%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84&u=http%3a%2f%2fanswerkobe.github.io%2fposts%2farraylist-and-linkedlist-principle%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script id=utteranc src=https://utteranc.es/client.js repo=Answerkobe/utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.body.className.includes("dark")?"github-light":"photon-dark",t={type:"set-theme",theme:e},n=document.querySelector(".utterances-frame");n.contentWindow.postMessage(t,"https://utteranc.es")})</script></article></main><footer class=footer><span>&copy; 2023 <a href=http://answerkobe.github.io/>Iverson's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>