<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="upgrade-insecure-requests"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何阅读 Java 字节码（Byte Code） | Iverson's blog</title>
<meta name=keywords content="Java"><meta name=description content="字节码（Byte Code） 学习 Java 的都知道，我们所编写的 .java 代码文件通过编译将会生成 .class 文件，最初的方式就是通过 JDK 的 javac 指令来编译，再通过 java 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。
对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。
字节码文件结构 public class Hello { public static void main(String[] args) { int a = 1; int b = 1; int c = add(a, b); System."><meta name=author content><link rel=canonical href=http://answerkobe.github.io/posts/how-to-read-java-byte-code/><link crossorigin=anonymous href=/assets/css/stylesheet.81e9c84b86321fe9cfdf9f01a2f8060920d09e0fec45cb91f131cfed0284007e.css integrity="sha256-genIS4YyH+nP358BovgGCSDQng/sRcuR8THP7QKEAH4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://answerkobe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://answerkobe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://answerkobe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://answerkobe.github.io/apple-touch-icon.png><link rel=mask-icon href=http://answerkobe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4112QEXZJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4112QEXZJ",{anonymize_ip:!1})}</script><meta property="og:title" content="如何阅读 Java 字节码（Byte Code）"><meta property="og:description" content="字节码（Byte Code） 学习 Java 的都知道，我们所编写的 .java 代码文件通过编译将会生成 .class 文件，最初的方式就是通过 JDK 的 javac 指令来编译，再通过 java 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。
对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。
字节码文件结构 public class Hello { public static void main(String[] args) { int a = 1; int b = 1; int c = add(a, b); System."><meta property="og:type" content="article"><meta property="og:url" content="http://answerkobe.github.io/posts/how-to-read-java-byte-code/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-07T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-07T00:00:00+00:00"><meta property="og:site_name" content="Iverson"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何阅读 Java 字节码（Byte Code）"><meta name=twitter:description content="字节码（Byte Code） 学习 Java 的都知道，我们所编写的 .java 代码文件通过编译将会生成 .class 文件，最初的方式就是通过 JDK 的 javac 指令来编译，再通过 java 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。
对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。
字节码文件结构 public class Hello { public static void main(String[] args) { int a = 1; int b = 1; int c = add(a, b); System."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://answerkobe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"如何阅读 Java 字节码（Byte Code）","item":"http://answerkobe.github.io/posts/how-to-read-java-byte-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何阅读 Java 字节码（Byte Code）","name":"如何阅读 Java 字节码（Byte Code）","description":"字节码（Byte Code） 学习 Java 的都知道，我们所编写的 .java 代码文件通过编译将会生成 .class 文件，最初的方式就是通过 JDK 的 javac 指令来编译，再通过 java 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。\n对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。\n字节码文件结构 public class Hello { public static void main(String[] args) { int a = 1; int b = 1; int c = add(a, b); System.","keywords":["Java"],"articleBody":"字节码（Byte Code） 学习 Java 的都知道，我们所编写的 .java 代码文件通过编译将会生成 .class 文件，最初的方式就是通过 JDK 的 javac 指令来编译，再通过 java 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。\n对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。\n字节码文件结构 public class Hello { public static void main(String[] args) { int a = 1; int b = 1; int c = add(a, b); System.out.println(c); } public static int add(int a, int b) { return a + b; } } 首先我们先编写一个简单的 Java 代码作为演示例子，然后编译这个 Hello.java 文件得到 Hello.class 文件。我们知道 .class 是二进制文件，它无法被直接查看，当然我们可以通过一些二进制文件查看工具来阅读里面的内容。\n一个符合标准的 .class 文件是以 CA FE BA BE 开头，这个四个字节均为魔数，JVM 根据这个开头来判断一个文件是否可能为 .class 文件，如果是才会继续执行。\n魔数后面四个字节 00 00 00 34 是版本号，前两个字节为次版本号，后两个字节为主版本号，在对主版本号进行转换可以得到 52，该序号对应的 Java 版本为 1.8。\n如果需要查阅最新的 Java 版本对应的版本号，可以在官方查看 Java SE 最新版本的文档\nOracle Java SE Specifications：https://docs.oracle.com/javase/specs/index.html\n在版本号后面则是常量池，它包含常量池计数器（constant_pool_count）和常量池数据区两个部分。前面两个字节 00 28 是计数器，用于表示常量池的容量计数值，代表常量池数据区有 constant_pool_count - 1 个常量。\n在常量池后面还有访问标志，很显然这个文件对于我们来说阅读起来并不方便，但是我们可以转换为助记符来帮助我们阅读。\n使用 javap 命令 当我们拥有一个 .class 文件时，我们可以通过 javap 来将字节码指令转换为助记符，这个命令有一些参数，你可以通过 javap -help 来查看所有参数的说明，这里为了显示尽量详细的内容，使用 javap -verbose Hello，其效果如下，但由于内容太长，我们不一次性展示所有内容，而是分区域来进行阅读。\nClassfile /F:/project/java/JavaMain/out/production/JavaMain/Hello.class Last modified 2021-3-26; size 645 bytes MD5 checksum ca1b2193159aece89c05c7f9d3b54c7b Compiled from \"Hello.java\" public class Hello minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER 最开始几行是关于这个文件的基本信息，之后是类的信息，我们的关注点从类这里开始。\n在类里面，它包含了主版本号（major version），次版本号（minor version），访问标志（flags）。\n对于版本号，和我们上面所讲的一样，因此这里不再重复。而 flags 是关于这个类的相关修饰符，根据官方文档，它可能拥有的值如下：\n常量池 在类信息的下面，则是常量池，它类似一个表，每个常量由编号、类型、值，这 3 个部分组成。我们列出一小部分来了解它的结构。\nConstant pool: #1 = Methodref #6.#26 // java/lang/Object.\"\":()V #2 = Methodref #5.#27 // Hello.add:(II)I #3 = Fieldref #28.#29 // java/lang/System.out:Ljava/io/PrintStream; #4 = Methodref #30.#31 // java/io/PrintStream.println:(I)V #5 = Class #32 // Hello #6 = Class #33 // java/lang/Object #7 = Utf8 #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 LHello; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V 在这里列出了前 15 个常量，每个常量都有一个编号，编号以符号 # 开头，编号后面是 = 加上该常量的类型，具体类型说明请参考官方 jvms 文档的 The Constant Pool 的解释。这里我们从中挑选几个常量来进行说明。\n由于我们使用的命令是 javap -verbose 因此它会给我们加上一些注释说明，我们可以看到 #2 常量后面的注释是 Hello.add:(II)I，那么我们可以猜测它应该是我们代码中所编写的 add() 方法，由于这个方法是静态，因此它被加入到这个类中的常量区。那么这个常量的值呢？\n对于 Methodref 类型，它的值是该方法的名称，对于一个方法而言，它的名称是一个字符串，因此构成方法名称的字符串也会被添加到常量池中，#2 这个方法，它的名称引用了常量池中其它的两个常量，也就是 #5 和 #27，而这两个常量以及与它们相关的其它常量在常量池中的值如下：\n#2 = Methodref #5.#27 // Hello.add:(II)I #5 = Class #32 // Hello #22 = Utf8 add #23 = Utf8 (II)I #27 = NameAndType #22:#23 // add:(II)I #32 = Utf8 Hello 在常量池中我们可以看到，#5 是一个类，它的值和方法一样都是名称，因此它引用了常量 #32，对于 Utf8 类型的常量，其值则是一个字符串，也就是常量 #32 的值就是字符串 Hello。因此 #5 的值就是 Hello。同样的 #27 的值是 add:(II)I，将它们组合起来 #2 的值就是 Hello.add:(II)I 了。\n包含的方法 与 Java 代码一样，我们所定义的方法在类里面，而在字节码中我们定义在类中的方法也放在大括号里面，而这个大括号就在常量池下方。\n对于每个方法，都包含首行的声明，以及紧接在后面的 descriptor（描述符号），flags（访问标识），Code（代码），我们把 Code 部分的内容先省略，先看一下类中所拥有的所有方法。\n{ public Hello(); descriptor: ()V flags: ACC_PUBLIC Code: // 省略 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: // 省略 public static int add(int, int); descriptor: (II)I flags: ACC_PUBLIC, ACC_STATIC Code: // 省略 } 可以看到，我们并没有给类写构造方法，但这里却生成了 public Hello();，这也说明了为什么我们在 Java 中不给类写构造方法，默认会有一个无参的构造方法。\n另外我们可以看到到 add(int, int) 方法的 descriptor 为 (II)I，这与我们上面观察常量池时 Hello.add:(II)I 冒号后面带的字符是一样的，这其实是这个方法的参数以及返回值的缩写。当我们在 Java 中编写重载方法时，由于方法名一样，JVM 可以通过 descriptor 来区分所调用的方法是哪一个。\n而 flags 与 Class 的 flags 类似，用于声明方法所拥有的修饰符。而最后的 Code 中包含的则是该方法的代码所执行的指令。\nCode 的结构 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: iconst_1 1: istore_1 2: iconst_1 3: istore_2 4: iload_1 5: iload_2 6: invokestatic #2 // Method add:(II)I 9: istore_3 10: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 13: iload_3 14: invokevirtual #4 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 3: 0 line 4: 2 line 5: 4 line 6: 10 line 7: 17 LocalVariableTable: Start Length Slot Name Signature 0 18 0 args [Ljava/lang/String; 2 16 1 a I 4 14 2 b I 10 8 3 c I 以 main 方法为例子，在 Code 中可以分为 3 个部分，第一个部分是代码的指令表，该部分第一行是该方法的指令以及执行过程的相关信息，这一行信息包括：\nargs_size 是参数数量，在主函数中，因为有 args 这个参数，所以在这里 args_size 为 1； locals 是该方法中的本地变量有多少个，在我们的主函数里面有定义了 3 个变量，加上一个参数，因此有 4 个变量； stack 是方法在执行过程中，操作数栈中最大深度，这个在之后讲解指令执行过程时可以看出。 在这一行信息之后是字节码指令，一条指令包括偏移量以及执行的指令码，PC Register 利用偏移量来判断指令执行位置。\n第二部分是 LineNumberTable，它是一个代码行对照表，用于标识我们 Java 代码中对应的行数的代码在 Code 中从哪个位置开始。\nLineNumberTable: line 3: 0 line 4: 2 line 5: 4 line 6: 10 line 7: 17 line 3: 0 代表 Java 源码文件中的第三行代码从偏移量为 0 的位置开始，而继续往下看可以看到第四行代码从偏移量为 2 的位置开始，也就是说第三行代码所对应的字节码指令有 iconst_1 和 istore_1 两条。这也可以让 JVM 执行指令出现错误时，帮助我们定位到对应的源码位置。\n第三部分为 LocalVariableTable，调试器可以使用它在方法执行的过程中确定局部变量的值，它是一个可选的属性，在程序执行的时候并不需要它。\n第一个属性 start 为这个变量可见的起始偏移位置，它的值必须是在 Code 中存在的偏移量值。 第二个属性 length 为该变量的有效长度，在这个例子中，我们的变量直到方法末尾都有效，因此你会发现 start + lenth 的值都是 18 （方法中执行的指令数）。当我们在一个局部的代码块里面声明一个变量，那么它的有效期长度将会更短。 Slot 为变量在 local variable 中的位置，这可以帮助我们在指令中确定对应的变量，而 Name 则是变量名，Signature 为该变量的类型。 当我们初步了解了 Code 属性的格式后，我们就可以对其中的指令执行进行分析了，但在此之前，我们需要先有一点 JVM 内存布局的基础知识，这对于我们之后了解指令的执行过程非常重要。\nJVM 内存结构 我们的 Java 程序在运行时是通过 main() 方法启动，它是程序的入口，我们的进程在启动时会为该方法创建一个主线程来执行代码。当我们使用多线程时，那么程序的进程将会拥有多个线程。每个线程的资源都拥有独自的资源，当然它们也可以共享进程的资源，那么在 JVM 中，根据资源的可用范围，可将内存区域分为线程独占和线程共享两个类别。\n对于每一个线程，都可将其拥有的内存空间分为 PC Register、Native Method Stack、JVM Stack 这 3 个区域，这 3 个区域对于线程来说都是独占的，其它线程无法进行访问。\nPC Register 用于记录当前线程指令的执行位置。由于一个进程可能有多个线程，而 CPU 会在不同线程之间切换，为了能够记录各个线程的当前执行的指令，每个线程都需要有一个 PC Register，来保证各个线程都可以进行独立运算。 JVM Stack 用于存放调用方法时压入栈的栈帧。相信学过数据结构的对栈应该不陌生，JVM Stack 压入的单位为栈帧（Frame），用于存储数据、动态链接、方法返回值和调度异常等。每次调用一个方法都会创建一个新的栈帧压入 JVM Stack 来存储该方法的信息，当该方法调用完成时，对应的栈帧也会跟着被销毁。一个栈帧都有自己的局部变量数组、操作数栈、对当前方法类的运行常量池的引用。 Native Method Stack 则是用于调用操作系统本地方法时使用的栈空间。 每个线程都可用访问的内存空间为线程共享区域，它包含 Head 和 Method Area 两个部分，Head 用于存放实例对象，也是 GC 回收的主要区域，而 Method Area 用于存放类结构与静态变量。\n现在我们初步了解了 JVM 内存的布局，那么接下来可以继续看指令的执行过程了。\n指令的执行过程 由于 Java 程序从 main() 方法开始，我们也是从这个方法的指令开始进行分析。\n假设程序运行 0 号指令前的状态如下，在 mian 方法栈帧里面，有着 operand stack（操作数栈），它的最大长度为 2（与 Code 下的 stack 的值一致），此外还有一个 local variable（本地变量表）来存放变量的值，其中下标为 0 的变量为主方法的参数 args，我们直接用这个字符串填充在那里来做一个标识（实际的值可能是一个空数组）。\n接下来我们一步步执行方法中的指令，在这里我们先对出现的几个指令做一个简单的介绍：\niconst_ 放一个 int 常量（-1, 0, 1, 2, 3, 4 or 5) 到 operand stack 中 istore_ 从 operand stack 中获取一个 int 到 local variable 的 n 中 iload_ 从 local variable 中读取 int 变量 n 的值到操作数栈中 invokestatic 调用一个 class 的 static 方法 getstatic 从 class 中获取一个 static 字段 invokevirtual 调用一个实例方法，基于类的调度 return 从方法中返回一个 void，ireturn 从方法中返回 operand stack 栈顶的 int 更多的指令与详细的说明请查看文章最后参考中的官方指令文档\n现在我们开始分析指令的执行，我们在上面知道了，我们的 Java 代码所对应的指令分别是偏移量为 0 和 1 的两个，最开始执行的是 0: iconst_1，该指令会把 int 常量 1 放置到 operand stack 中，之后执行的是 1: istore_1，把 operand stack 栈顶的 int 常量取出放到 local variable 下标为 1 的变量中，该过程图示如下。\n我们可以通过查看 LocalVariableTable 得知下标为 1 的变量在我们的 Java 程序中是 int 变量 a，因此上面这两条指令常量 1 赋值给变量 a。同样的，后面两条指令则是将常量 1 赋值给变量 b。这里要注意，操作数栈的数是被取出操作，被取出的数将不会继续在 operand stack 里面。\n执行完 0~3 这 4 条指令后，就来到了本例中最为关键的方法调用了。在执行 iload_1 和 iload_2 后，operand stack 中将会存放着变量 a 和 b 的值，作为 invokestatic 调用函数时传入的参数。\n而执行到 invokestatic #2 这个指令的时候，该指令为调用一个 class 的 static 方法，也就是调用常量池中 #2 的方法，该方法为 Hello.add:(II)I。\n当执行 invokestatic 时会依次读取 operand stack 的数据作为方法的参数，并创建一个新的栈帧来执行方法，将数据放到 local variable 对应变量位置。\n之后开始执行 add() 方法中的指令，首先执行的是两个 iload 指令，将 loca variable 对应下标的变量的值放到 operand stack 中，之后执行 iadd 取出 operand stack 中的值并进行加法运算，再把结果放到，最后执行 ireturn 取出 operand stack 顶部的 int 值进行返回。\n当执行完 ireturn 后，add 方法也就执行完成了，对应的栈帧也会跟着销毁。之后回到 main 方法中继续往下执行，到 istore_3 指令，该指令将栈顶的 int 值取出放到了 local variable 中 Solt 为 3 的地方，这样执行完 4~9 这几条指令后就完成了我们代码中的 int c = add(a, b); 这一行代码。那么接下来就是执行 System.out.println(c); 对应的指令将 2 打印到控制台了。\n到这里其实我们就已经知道如何去阅读我们代码生成的 Byte Code 了，这里我就不继续往下分析本文例子的代码了，阅读过程中如果遇到了没见过的指令，我们可以在 Oracle 官方指令文档里面查阅对应的说明。\n那可能有人会觉得，如果每次查看一个类都需要去 command line 执行 javap 来查看对应的助记符，这样非常麻烦呀。那么接下来我们讲一下如何在 IntelliJ IDEA 里面直接阅读 Byte Code。\n在 IntelliJ IDEA 阅读 如果你希望在 IntelliJ IDEA 里阅读 Byte Code，那么可以按照 Bytecode Viewer 这一个插件，只需要在 Plugins 里面查找就能找到。\n安装完这个插件，在顶部菜单栏的 View 中将会多出一个 Show Bytecode 按钮选项，我们可以在对应的 .java 文件中点击 View -\u003e Show Bytecode，展示出该文件的 Byte Code。\n在这里所展示的 Byte Code 格式与我们上面使用 javap 显示出来的不一样。首先在这里我们看不到常量池，因此在指令里也不会用引用的方式来表示常量池的内容。\n在这里它会将每一行 Java 代码的指令都区分开。例如 main 方法中的第一行指令对应的就是 L0 那一块，第一行的 LINENUMBER 对应上面 javap 中的 LineNumberTable，直接在这里描述当前 L0 这一块的指令对应的代码在文件中的位置。也因此我们不会在生成的这个 Byte Code 里面看到 LineNumberTable，因为它直接分布在各个指令块中了。\n在方法的最后，会多出一块内容来描述方法的信息，在这里会将 LocalVariableTable 里的变量都列出来，但格式与 javap 的 LocalVariableTable 中的描述格式不一样，每一行 LOCALVARIABLE 代表一个变量，描述格式从左到右依次为变量名、类型、开始可见时的指令块、最后有效的位置、Solt。除了描述方法中出现的变量外，操作数栈最大深度和本地变量个数也在放在这里。\n由于该插件主要是为了阅读 Byte Code 中的指令，因此是以一种更加方便阅读指令的方式展示 Byte Code，例如对指令根据源码做分块，并把对应代码行数放在指令块的第一行，这样我们就不需要去对照 LineNumberTable 寻找当前指令的代码所在的位置了，反过来由于进行了分块查询对应代码的指令也很方便。但这个插件显示的内容也少了很多东西，如果需要查看初始常量池的内容，那就需要使用 javap 了。\n参考 字节码增强技术探索：https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html\n一文看懂 JVM 内存布局及 GC 原理：https://www.infoq.cn/article/3wyretkqrhivtw4frmr3\nOracle 官方说明文档：https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jvms-4.10\nOracle 官方指令文档：https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html\n","wordCount":"970","inLanguage":"en","datePublished":"2021-03-07T00:00:00Z","dateModified":"2021-03-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://answerkobe.github.io/posts/how-to-read-java-byte-code/"},"publisher":{"@type":"Organization","name":"Iverson's blog","logo":{"@type":"ImageObject","url":"http://answerkobe.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://answerkobe.github.io/ accesskey=h title="Iverson's blog (Alt + H)">Iverson's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://answerkobe.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=http://answerkobe.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=http://answerkobe.github.io/profile title=Profile-X><span>Profile-X</span></a></li><li><a href=http://answerkobe.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://answerkobe.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://answerkobe.github.io/posts/>Posts</a></div><h1 class=post-title>如何阅读 Java 字节码（Byte Code）</h1><div class=post-meta><span title='2021-03-07 00:00:00 +0000 UTC'>March 7, 2021</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%ad%97%e8%8a%82%e7%a0%81byte-code aria-label="字节码（Byte Code）">字节码（Byte Code）</a></li><li><a href=#%e5%ad%97%e8%8a%82%e7%a0%81%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84 aria-label=字节码文件结构>字节码文件结构</a><ul><li><a href=#%e4%bd%bf%e7%94%a8-javap-%e5%91%bd%e4%bb%a4 aria-label="使用 javap 命令">使用 javap 命令</a></li><li><a href=#%e5%b8%b8%e9%87%8f%e6%b1%a0 aria-label=常量池>常量池</a></li><li><a href=#%e5%8c%85%e5%90%ab%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=包含的方法>包含的方法</a></li><li><a href=#code-%e7%9a%84%e7%bb%93%e6%9e%84 aria-label="Code 的结构">Code 的结构</a></li></ul></li><li><a href=#jvm-%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84 aria-label="JVM 内存结构">JVM 内存结构</a></li><li><a href=#%e6%8c%87%e4%bb%a4%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b aria-label=指令的执行过程>指令的执行过程</a></li><li><a href=#%e5%9c%a8-intellij-idea-%e9%98%85%e8%af%bb aria-label="在 IntelliJ IDEA 阅读">在 IntelliJ IDEA 阅读</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=字节码byte-code>字节码（Byte Code）<a hidden class=anchor aria-hidden=true href=#字节码byte-code>#</a></h2><p>学习 Java 的都知道，我们所编写的 <code>.java</code> 代码文件通过编译将会生成 <code>.class</code> 文件，最初的方式就是通过 JDK 的 <code>javac</code> 指令来编译，再通过 <code>java</code> 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。</p><p>对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。</p><h2 id=字节码文件结构>字节码文件结构<a hidden class=anchor aria-hidden=true href=#字节码文件结构>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> add(a, b);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(c);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>首先我们先编写一个简单的 Java 代码作为演示例子，然后编译这个 Hello.java 文件得到 Hello.class 文件。我们知道 .class 是二进制文件，它无法被直接查看，当然我们可以通过一些二进制文件查看工具来阅读里面的内容。</p><p><img loading=lazy src=./read-byte-code-in-vscode.png alt="（在 Visual Studio Code 里使用 hexdump for VSCode 插件查看到的内容）"></p><p>一个符合标准的 <code>.class</code> 文件是以 <code>CA FE BA BE</code> 开头，这个四个字节均为魔数，JVM 根据这个开头来判断一个文件是否可能为 <code>.class</code> 文件，如果是才会继续执行。</p><p>魔数后面四个字节 <code>00 00 00 34</code> 是版本号，前两个字节为次版本号，后两个字节为主版本号，在对主版本号进行转换可以得到 52，该序号对应的 Java 版本为 1.8。</p><p>如果需要查阅最新的 Java 版本对应的版本号，可以在官方查看 Java SE 最新版本的文档</p><blockquote><p>Oracle Java SE Specifications：https://docs.oracle.com/javase/specs/index.html</p></blockquote><p>在版本号后面则是常量池，它包含常量池计数器（constant_pool_count）和常量池数据区两个部分。前面两个字节 00 28 是计数器，用于表示常量池的容量计数值，代表常量池数据区有 <code>constant_pool_count - 1</code> 个常量。</p><p><img loading=lazy src=./constant-pool-structure.png alt=常量池结构></p><p>在常量池后面还有访问标志，很显然这个文件对于我们来说阅读起来并不方便，但是我们可以转换为助记符来帮助我们阅读。</p><h3 id=使用-javap-命令>使用 javap 命令<a hidden class=anchor aria-hidden=true href=#使用-javap-命令>#</a></h3><p>当我们拥有一个 <code>.class</code> 文件时，我们可以通过 <code>javap</code> 来将字节码指令转换为助记符，这个命令有一些参数，你可以通过 <code>javap -help</code> 来查看所有参数的说明，这里为了显示尽量详细的内容，使用 <code>javap -verbose Hello</code>，其效果如下，但由于内容太长，我们不一次性展示所有内容，而是分区域来进行阅读。</p><pre tabindex=0><code>Classfile /F:/project/java/JavaMain/out/production/JavaMain/Hello.class
  Last modified 2021-3-26; size 645 bytes
  MD5 checksum ca1b2193159aece89c05c7f9d3b54c7b
  Compiled from &#34;Hello.java&#34;
public class Hello
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
</code></pre><p>最开始几行是关于这个文件的基本信息，之后是类的信息，我们的关注点从类这里开始。</p><p>在类里面，它包含了主版本号（major version），次版本号（minor version），访问标志（flags）。</p><p>对于版本号，和我们上面所讲的一样，因此这里不再重复。而 flags 是关于这个类的相关修饰符，根据官方文档，它可能拥有的值如下：</p><p><img loading=lazy src=./class-decorator-flags.png alt></p><h3 id=常量池>常量池<a hidden class=anchor aria-hidden=true href=#常量池>#</a></h3><p>在类信息的下面，则是常量池，它类似一个表，每个常量由编号、类型、值，这 3 个部分组成。我们列出一小部分来了解它的结构。</p><pre tabindex=0><code>Constant pool:
   #1 = Methodref          #6.#26         // java/lang/Object.&#34;&lt;init&gt;&#34;:()V
   #2 = Methodref          #5.#27         // Hello.add:(II)I
   #3 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V
   #5 = Class              #32            // Hello
   #6 = Class              #33            // java/lang/Object
   #7 = Utf8               &lt;init&gt;
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               LHello;
  #14 = Utf8               main
  #15 = Utf8               ([Ljava/lang/String;)V
</code></pre><p>在这里列出了前 15 个常量，每个常量都有一个编号，编号以符号 <code>#</code> 开头，编号后面是 <code>=</code> 加上该常量的类型，具体类型说明请参考官方 jvms 文档的 The Constant Pool 的解释。这里我们从中挑选几个常量来进行说明。</p><p>由于我们使用的命令是 <code>javap -verbose</code> 因此它会给我们加上一些注释说明，我们可以看到 <code>#2</code> 常量后面的注释是 <code>Hello.add:(II)I</code>，那么我们可以猜测它应该是我们代码中所编写的 <code>add()</code> 方法，由于这个方法是静态，因此它被加入到这个类中的常量区。那么这个常量的值呢？</p><p>对于 Methodref 类型，它的值是该方法的名称，对于一个方法而言，它的名称是一个字符串，因此构成方法名称的字符串也会被添加到常量池中，<code>#2</code> 这个方法，它的名称引用了常量池中其它的两个常量，也就是 <code>#5</code> 和 <code>#27</code>，而这两个常量以及与它们相关的其它常量在常量池中的值如下：</p><pre tabindex=0><code>   #2 = Methodref          #5.#27         // Hello.add:(II)I
   #5 = Class              #32            // Hello
  #22 = Utf8               add
  #23 = Utf8               (II)I
  #27 = NameAndType        #22:#23        // add:(II)I
  #32 = Utf8               Hello
</code></pre><p>在常量池中我们可以看到，<code>#5</code> 是一个类，它的值和方法一样都是名称，因此它引用了常量 #32，对于 <code>Utf8</code> 类型的常量，其值则是一个字符串，也就是常量 <code>#32</code> 的值就是字符串 <em>Hello</em>。因此 <code>#5</code> 的值就是 <em>Hello</em>。同样的 <code>#27</code> 的值是 <code>add:(II)I</code>，将它们组合起来 <code>#2</code> 的值就是 <code>Hello.add:(II)I</code> 了。</p><h3 id=包含的方法>包含的方法<a hidden class=anchor aria-hidden=true href=#包含的方法>#</a></h3><p>与 Java 代码一样，我们所定义的方法在类里面，而在字节码中我们定义在类中的方法也放在大括号里面，而这个大括号就在常量池下方。</p><p>对于每个方法，都包含首行的声明，以及紧接在后面的 descriptor（描述符号），flags（访问标识），Code（代码），我们把 Code 部分的内容先省略，先看一下类中所拥有的所有方法。</p><pre tabindex=0><code>{
  public Hello();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      // 省略

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      // 省略

  public static int add(int, int);
    descriptor: (II)I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      // 省略
}
</code></pre><p>可以看到，我们并没有给类写构造方法，但这里却生成了 <code>public Hello();</code>，这也说明了为什么我们在 Java 中不给类写构造方法，默认会有一个无参的构造方法。</p><p>另外我们可以看到到 <code>add(int, int)</code> 方法的 descriptor 为 <code>(II)I</code>，这与我们上面观察常量池时 <code>Hello.add:(II)I</code> 冒号后面带的字符是一样的，这其实是这个方法的参数以及返回值的缩写。当我们在 Java 中编写重载方法时，由于方法名一样，JVM 可以通过 descriptor 来区分所调用的方法是哪一个。</p><p>而 flags 与 Class 的 flags 类似，用于声明方法所拥有的修饰符。而最后的 Code 中包含的则是该方法的代码所执行的指令。</p><h3 id=code-的结构>Code 的结构<a hidden class=anchor aria-hidden=true href=#code-的结构>#</a></h3><pre tabindex=0><code>  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: iconst_1
         1: istore_1
         2: iconst_1
         3: istore_2
         4: iload_1
         5: iload_2
         6: invokestatic  #2                  // Method add:(II)I
         9: istore_3
        10: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
        13: iload_3
        14: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V
        17: return
      LineNumberTable:
        line 3: 0
        line 4: 2
        line 5: 4
        line 6: 10
        line 7: 17
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      18     0  args   [Ljava/lang/String;
            2      16     1     a   I
            4      14     2     b   I
           10       8     3     c   I
</code></pre><p>以 main 方法为例子，在 Code 中可以分为 3 个部分，第一个部分是代码的指令表，该部分第一行是该方法的指令以及执行过程的相关信息，这一行信息包括：</p><ul><li>args_size 是参数数量，在主函数中，因为有 args 这个参数，所以在这里 args_size 为 1；</li><li>locals 是该方法中的本地变量有多少个，在我们的主函数里面有定义了 3 个变量，加上一个参数，因此有 4 个变量；</li><li>stack 是方法在执行过程中，操作数栈中最大深度，这个在之后讲解指令执行过程时可以看出。</li></ul><p>在这一行信息之后是字节码指令，一条指令包括偏移量以及执行的指令码，PC Register 利用偏移量来判断指令执行位置。</p><p>第二部分是 LineNumberTable，它是一个代码行对照表，用于标识我们 Java 代码中对应的行数的代码在 Code 中从哪个位置开始。</p><pre tabindex=0><code>LineNumberTable:
  line 3: 0
  line 4: 2
  line 5: 4
  line 6: 10
  line 7: 17
</code></pre><p><code>line 3: 0</code> 代表 Java 源码文件中的第三行代码从偏移量为 0 的位置开始，而继续往下看可以看到第四行代码从偏移量为 2 的位置开始，也就是说第三行代码所对应的字节码指令有 <code>iconst_1</code> 和 <code>istore_1</code> 两条。这也可以让 JVM 执行指令出现错误时，帮助我们定位到对应的源码位置。</p><p>第三部分为 LocalVariableTable，调试器可以使用它在方法执行的过程中确定局部变量的值，它是一个可选的属性，在程序执行的时候并不需要它。</p><ul><li>第一个属性 start 为这个变量可见的起始偏移位置，它的值必须是在 Code 中存在的偏移量值。</li><li>第二个属性 length 为该变量的有效长度，在这个例子中，我们的变量直到方法末尾都有效，因此你会发现 <code>start + lenth</code> 的值都是 18 （方法中执行的指令数）。当我们在一个局部的代码块里面声明一个变量，那么它的有效期长度将会更短。</li><li>Slot 为变量在 local variable 中的位置，这可以帮助我们在指令中确定对应的变量，而 Name 则是变量名，Signature 为该变量的类型。</li></ul><p>当我们初步了解了 Code 属性的格式后，我们就可以对其中的指令执行进行分析了，但在此之前，我们需要先有一点 JVM 内存布局的基础知识，这对于我们之后了解指令的执行过程非常重要。</p><h2 id=jvm-内存结构>JVM 内存结构<a hidden class=anchor aria-hidden=true href=#jvm-内存结构>#</a></h2><p>我们的 Java 程序在运行时是通过 <code>main()</code> 方法启动，它是程序的入口，我们的进程在启动时会为该方法创建一个主线程来执行代码。当我们使用多线程时，那么程序的进程将会拥有多个线程。每个线程的资源都拥有独自的资源，当然它们也可以共享进程的资源，那么在 JVM 中，根据资源的可用范围，可将内存区域分为线程独占和线程共享两个类别。</p><p><img loading=lazy src=./jvm-memory-layout.png alt=JVM内存布局></p><p>对于每一个线程，都可将其拥有的内存空间分为 PC Register、Native Method Stack、JVM Stack 这 3 个区域，这 3 个区域对于线程来说都是独占的，其它线程无法进行访问。</p><ul><li><strong>PC Register</strong> 用于记录当前线程指令的执行位置。由于一个进程可能有多个线程，而 CPU 会在不同线程之间切换，为了能够记录各个线程的当前执行的指令，每个线程都需要有一个 PC Register，来保证各个线程都可以进行独立运算。</li><li><strong>JVM Stack</strong> 用于存放调用方法时压入栈的栈帧。相信学过数据结构的对栈应该不陌生，JVM Stack 压入的单位为栈帧（Frame），用于存储数据、动态链接、方法返回值和调度异常等。每次调用一个方法都会创建一个新的栈帧压入 JVM Stack 来存储该方法的信息，当该方法调用完成时，对应的栈帧也会跟着被销毁。一个栈帧都有自己的局部变量数组、操作数栈、对当前方法类的运行常量池的引用。</li><li><strong>Native Method Stack</strong> 则是用于调用操作系统本地方法时使用的栈空间。</li></ul><p><img loading=lazy src=./jvm-stack.png alt="JVM Stack 结构"></p><p>每个线程都可用访问的内存空间为线程共享区域，它包含 Head 和 Method Area 两个部分，Head 用于存放实例对象，也是 GC 回收的主要区域，而 Method Area 用于存放类结构与静态变量。</p><p>现在我们初步了解了 JVM 内存的布局，那么接下来可以继续看指令的执行过程了。</p><h2 id=指令的执行过程>指令的执行过程<a hidden class=anchor aria-hidden=true href=#指令的执行过程>#</a></h2><p>由于 Java 程序从 <code>main()</code> 方法开始，我们也是从这个方法的指令开始进行分析。</p><p>假设程序运行 0 号指令前的状态如下，在 mian 方法栈帧里面，有着 operand stack（操作数栈），它的最大长度为 2（与 Code 下的 stack 的值一致），此外还有一个 local variable（本地变量表）来存放变量的值，其中下标为 0 的变量为主方法的参数 args，我们直接用这个字符串填充在那里来做一个标识（实际的值可能是一个空数组）。</p><p><img loading=lazy src=./execute0.png alt></p><p>接下来我们一步步执行方法中的指令，在这里我们先对出现的几个指令做一个简单的介绍：</p><ul><li><code>iconst_&lt;i></code> 放一个 int 常量（-1, 0, 1, 2, 3, 4 or 5) 到 operand stack 中</li><li><code>istore_&lt;n></code> 从 operand stack 中获取一个 int 到 local variable 的 n 中</li><li><code>iload_&lt;n></code> 从 local variable 中读取 int 变量 n 的值到操作数栈中</li><li><code>invokestatic</code> 调用一个 class 的 static 方法</li><li><code>getstatic</code> 从 class 中获取一个 static 字段</li><li><code>invokevirtual</code> 调用一个实例方法，基于类的调度</li><li><code>return</code> 从方法中返回一个 void，<code>ireturn</code> 从方法中返回 operand stack 栈顶的 int</li></ul><p><em>更多的指令与详细的说明请查看文章最后参考中的官方指令文档</em></p><p>现在我们开始分析指令的执行，我们在上面知道了，我们的 Java 代码所对应的指令分别是偏移量为 0 和 1 的两个，最开始执行的是 <code>0: iconst_1</code>，该指令会把 int 常量 1 放置到 operand stack 中，之后执行的是 <code>1: istore_1</code>，把 operand stack 栈顶的 int 常量取出放到 local variable 下标为 1 的变量中，该过程图示如下。</p><p><img loading=lazy src=./execute1.png alt="iconst_1 与 istore_1 的执行过程"></p><p>我们可以通过查看 LocalVariableTable 得知下标为 1 的变量在我们的 Java 程序中是 int 变量 a，因此上面这两条指令常量 1 赋值给变量 a。同样的，后面两条指令则是将常量 1 赋值给变量 b。这里要注意，操作数栈的数是被取出操作，被取出的数将不会继续在 operand stack 里面。</p><p>执行完 0~3 这 4 条指令后，就来到了本例中最为关键的方法调用了。在执行 <code>iload_1</code> 和 <code>iload_2</code> 后，operand stack 中将会存放着变量 a 和 b 的值，作为 <code>invokestatic</code> 调用函数时传入的参数。</p><p>而执行到 <code>invokestatic #2</code> 这个指令的时候，该指令为调用一个 class 的 static 方法，也就是调用常量池中 <code>#2</code> 的方法，该方法为 <code>Hello.add:(II)I</code>。</p><p>当执行 invokestatic 时会依次读取 operand stack 的数据作为方法的参数，并创建一个新的栈帧来执行方法，将数据放到 local variable 对应变量位置。</p><p><img loading=lazy src=./execute2.png alt></p><p>之后开始执行 <code>add()</code> 方法中的指令，首先执行的是两个 <code>iload</code> 指令，将 loca variable 对应下标的变量的值放到 operand stack 中，之后执行 <code>iadd</code> 取出 operand stack 中的值并进行加法运算，再把结果放到，最后执行 ireturn 取出 operand stack 顶部的 int 值进行返回。</p><p><img loading=lazy src=./execute3.png alt="执行了两个 iload 指令"></p><p><img loading=lazy src=./execute4.png alt="执行 iadd 指令"></p><p><img loading=lazy src=./execute5.png alt="ireturn 取出栈顶的 int 常量作为方法的返回值"></p><p><img loading=lazy src=./execute6.png alt="执行 istore_3"></p><p>当执行完 <code>ireturn</code> 后，add 方法也就执行完成了，对应的栈帧也会跟着销毁。之后回到 main 方法中继续往下执行，到 <code>istore_3</code> 指令，该指令将栈顶的 int 值取出放到了 local variable 中 Solt 为 3 的地方，这样执行完 4~9 这几条指令后就完成了我们代码中的 <code>int c = add(a, b);</code> 这一行代码。那么接下来就是执行 <code>System.out.println(c);</code> 对应的指令将 2 打印到控制台了。</p><p>到这里其实我们就已经知道如何去阅读我们代码生成的 Byte Code 了，这里我就不继续往下分析本文例子的代码了，阅读过程中如果遇到了没见过的指令，我们可以在 Oracle 官方指令文档里面查阅对应的说明。</p><p>那可能有人会觉得，如果每次查看一个类都需要去 command line 执行 <code>javap</code> 来查看对应的助记符，这样非常麻烦呀。那么接下来我们讲一下如何在 IntelliJ IDEA 里面直接阅读 Byte Code。</p><h2 id=在-intellij-idea-阅读>在 IntelliJ IDEA 阅读<a hidden class=anchor aria-hidden=true href=#在-intellij-idea-阅读>#</a></h2><p>如果你希望在 IntelliJ IDEA 里阅读 Byte Code，那么可以按照 <strong>Bytecode Viewer</strong> 这一个插件，只需要在 Plugins 里面查找就能找到。</p><p><img loading=lazy src=./idea-bytecode-viewer.png alt="Bytecode Viewer"></p><p>安装完这个插件，在顶部菜单栏的 View 中将会多出一个 Show Bytecode 按钮选项，我们可以在对应的 <code>.java</code> 文件中点击 View -> Show Bytecode，展示出该文件的 Byte Code。</p><p><img loading=lazy src=./view-show-bytecode.png alt="View -&amp;gt; Show Bytecode"></p><p><img loading=lazy src=./idea-bytecode-show.png alt></p><p>在这里所展示的 Byte Code 格式与我们上面使用 <code>javap</code> 显示出来的不一样。首先在这里我们看不到常量池，因此在指令里也不会用引用的方式来表示常量池的内容。</p><p>在这里它会将每一行 Java 代码的指令都区分开。例如 main 方法中的第一行指令对应的就是 L0 那一块，第一行的 LINENUMBER 对应上面 <code>javap</code> 中的 LineNumberTable，直接在这里描述当前 L0 这一块的指令对应的代码在文件中的位置。也因此我们不会在生成的这个 Byte Code 里面看到 LineNumberTable，因为它直接分布在各个指令块中了。</p><p><img loading=lazy src=./main-l5.png alt="main 方法中的 L5"></p><p>在方法的最后，会多出一块内容来描述方法的信息，在这里会将 LocalVariableTable 里的变量都列出来，但格式与 javap 的 LocalVariableTable 中的描述格式不一样，每一行 LOCALVARIABLE 代表一个变量，描述格式从左到右依次为变量名、类型、开始可见时的指令块、最后有效的位置、Solt。除了描述方法中出现的变量外，操作数栈最大深度和本地变量个数也在放在这里。</p><p>由于该插件主要是为了阅读 Byte Code 中的指令，因此是以一种更加方便阅读指令的方式展示 Byte Code，例如对指令根据源码做分块，并把对应代码行数放在指令块的第一行，这样我们就不需要去对照 LineNumberTable 寻找当前指令的代码所在的位置了，反过来由于进行了分块查询对应代码的指令也很方便。但这个插件显示的内容也少了很多东西，如果需要查看初始常量池的内容，那就需要使用 <code>javap</code> 了。</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><blockquote><p>字节码增强技术探索：https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html</p><p>一文看懂 JVM 内存布局及 GC 原理：https://www.infoq.cn/article/3wyretkqrhivtw4frmr3</p><p>Oracle 官方说明文档：https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#jvms-4.10</p><p>Oracle 官方指令文档：https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=http://answerkobe.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=http://answerkobe.github.io/posts/arraylist-and-linkedlist-principle/><span class=title>« Prev</span><br><span>ArrayList 与 LinkedList 底层结构</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何阅读 Java 字节码（Byte Code） on x" href="https://x.com/intent/tweet/?text=%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bb%20Java%20%e5%ad%97%e8%8a%82%e7%a0%81%ef%bc%88Byte%20Code%ef%bc%89&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fhow-to-read-java-byte-code%2f&amp;hashtags=Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何阅读 Java 字节码（Byte Code） on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fhow-to-read-java-byte-code%2f&amp;title=%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bb%20Java%20%e5%ad%97%e8%8a%82%e7%a0%81%ef%bc%88Byte%20Code%ef%bc%89&amp;summary=%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bb%20Java%20%e5%ad%97%e8%8a%82%e7%a0%81%ef%bc%88Byte%20Code%ef%bc%89&amp;source=http%3a%2f%2fanswerkobe.github.io%2fposts%2fhow-to-read-java-byte-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何阅读 Java 字节码（Byte Code） on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fhow-to-read-java-byte-code%2f&title=%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bb%20Java%20%e5%ad%97%e8%8a%82%e7%a0%81%ef%bc%88Byte%20Code%ef%bc%89"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何阅读 Java 字节码（Byte Code） on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fhow-to-read-java-byte-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何阅读 Java 字节码（Byte Code） on whatsapp" href="https://api.whatsapp.com/send?text=%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bb%20Java%20%e5%ad%97%e8%8a%82%e7%a0%81%ef%bc%88Byte%20Code%ef%bc%89%20-%20http%3a%2f%2fanswerkobe.github.io%2fposts%2fhow-to-read-java-byte-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何阅读 Java 字节码（Byte Code） on telegram" href="https://telegram.me/share/url?text=%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bb%20Java%20%e5%ad%97%e8%8a%82%e7%a0%81%ef%bc%88Byte%20Code%ef%bc%89&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fhow-to-read-java-byte-code%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 如何阅读 Java 字节码（Byte Code） on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bb%20Java%20%e5%ad%97%e8%8a%82%e7%a0%81%ef%bc%88Byte%20Code%ef%bc%89&u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fhow-to-read-java-byte-code%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script id=utteranc src=https://utteranc.es/client.js repo=Answerkobe/utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.body.className.includes("dark")?"github-light":"photon-dark",t={type:"set-theme",theme:e},n=document.querySelector(".utterances-frame");n.contentWindow.postMessage(t,"https://utteranc.es")})</script></article></main><footer class=footer><span>&copy; 2023 <a href=http://answerkobe.github.io/>Iverson's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>