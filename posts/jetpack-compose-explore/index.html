<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="upgrade-insecure-requests"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Jetpack Compose 探索 | Iverson's blog</title>
<meta name=keywords content="Kotlin,Android,Jetpack Compose"><meta name=description content="Why compose Compose UI 的编写只需要 Kotlin，在遵循 Android 应用架构时，这样更有利于聚合 UI Elements 的代码，不需要去区分 Kotlin 代码和 xml 布局文件，在我看来这种方式更加容易采用 Android 架构指南去控制项目架构。
但从另一方面来讲，Compose 这种嵌套的 UI 组合方式会加深代码层次，因此开发过程中需要对 UI 上各个元素做更细的区分，以增加代码的可读性。另外如果状态使用没有处理好，也会对 Compose 的重组性能带来影响。
完善的声明式 UI Android View 系统设计的时候是遵循 OOP 的，虽然有 XML 可以帮我们减少下面这种命令式代码的使用，但这种声明式构建 + 命令式执行的缺点还是很明显，因为需要一个加载器把布局转化到业务逻辑代码中。
// 命令式 val parent = ViewGroup(); val node = View(); parent.addView(node); 如果按照理想的声明式 UI 编写方式去改造传统 View 系统，那呈现出的代码可能会包括下面两个特点：
节点的构建不应该有返回值 节点的连接不依赖于 API <LinearLayout> <TextView>Hello World</TextView> <MaterialButton android:onCLick=&#34;syaHi()&#34;>hi</MaterialButton> </LinearLayout> 将上面的布局代码转换为 Java/Kotlin 理想的声明式代码
LinearLayout { TextView(&#34;Hello World&#34;) MaterialButton(&#34;Hi&#34;) { syaHi() } } Compose 利用 Kotlin DSL 构建声明式 UI，一个 @Composable 相当于一个节点，在内部也可以调用其他 @Composable 函数构建子节点。"><meta name=author content><link rel=canonical href=http://answerkobe.github.io/posts/jetpack-compose-explore/><link crossorigin=anonymous href=/assets/css/stylesheet.81e9c84b86321fe9cfdf9f01a2f8060920d09e0fec45cb91f131cfed0284007e.css integrity="sha256-genIS4YyH+nP358BovgGCSDQng/sRcuR8THP7QKEAH4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://answerkobe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://answerkobe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://answerkobe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://answerkobe.github.io/apple-touch-icon.png><link rel=mask-icon href=http://answerkobe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y4112QEXZJ"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y4112QEXZJ",{anonymize_ip:!1})}</script><meta property="og:title" content="Jetpack Compose 探索"><meta property="og:description" content="Why compose Compose UI 的编写只需要 Kotlin，在遵循 Android 应用架构时，这样更有利于聚合 UI Elements 的代码，不需要去区分 Kotlin 代码和 xml 布局文件，在我看来这种方式更加容易采用 Android 架构指南去控制项目架构。
但从另一方面来讲，Compose 这种嵌套的 UI 组合方式会加深代码层次，因此开发过程中需要对 UI 上各个元素做更细的区分，以增加代码的可读性。另外如果状态使用没有处理好，也会对 Compose 的重组性能带来影响。
完善的声明式 UI Android View 系统设计的时候是遵循 OOP 的，虽然有 XML 可以帮我们减少下面这种命令式代码的使用，但这种声明式构建 + 命令式执行的缺点还是很明显，因为需要一个加载器把布局转化到业务逻辑代码中。
// 命令式 val parent = ViewGroup(); val node = View(); parent.addView(node); 如果按照理想的声明式 UI 编写方式去改造传统 View 系统，那呈现出的代码可能会包括下面两个特点：
节点的构建不应该有返回值 节点的连接不依赖于 API <LinearLayout> <TextView>Hello World</TextView> <MaterialButton android:onCLick=&#34;syaHi()&#34;>hi</MaterialButton> </LinearLayout> 将上面的布局代码转换为 Java/Kotlin 理想的声明式代码
LinearLayout { TextView(&#34;Hello World&#34;) MaterialButton(&#34;Hi&#34;) { syaHi() } } Compose 利用 Kotlin DSL 构建声明式 UI，一个 @Composable 相当于一个节点，在内部也可以调用其他 @Composable 函数构建子节点。"><meta property="og:type" content="article"><meta property="og:url" content="http://answerkobe.github.io/posts/jetpack-compose-explore/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-08T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-08T00:00:00+00:00"><meta property="og:site_name" content="Iverson"><meta name=twitter:card content="summary"><meta name=twitter:title content="Jetpack Compose 探索"><meta name=twitter:description content="Why compose Compose UI 的编写只需要 Kotlin，在遵循 Android 应用架构时，这样更有利于聚合 UI Elements 的代码，不需要去区分 Kotlin 代码和 xml 布局文件，在我看来这种方式更加容易采用 Android 架构指南去控制项目架构。
但从另一方面来讲，Compose 这种嵌套的 UI 组合方式会加深代码层次，因此开发过程中需要对 UI 上各个元素做更细的区分，以增加代码的可读性。另外如果状态使用没有处理好，也会对 Compose 的重组性能带来影响。
完善的声明式 UI Android View 系统设计的时候是遵循 OOP 的，虽然有 XML 可以帮我们减少下面这种命令式代码的使用，但这种声明式构建 + 命令式执行的缺点还是很明显，因为需要一个加载器把布局转化到业务逻辑代码中。
// 命令式 val parent = ViewGroup(); val node = View(); parent.addView(node); 如果按照理想的声明式 UI 编写方式去改造传统 View 系统，那呈现出的代码可能会包括下面两个特点：
节点的构建不应该有返回值 节点的连接不依赖于 API <LinearLayout> <TextView>Hello World</TextView> <MaterialButton android:onCLick=&#34;syaHi()&#34;>hi</MaterialButton> </LinearLayout> 将上面的布局代码转换为 Java/Kotlin 理想的声明式代码
LinearLayout { TextView(&#34;Hello World&#34;) MaterialButton(&#34;Hi&#34;) { syaHi() } } Compose 利用 Kotlin DSL 构建声明式 UI，一个 @Composable 相当于一个节点，在内部也可以调用其他 @Composable 函数构建子节点。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://answerkobe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Jetpack Compose 探索","item":"http://answerkobe.github.io/posts/jetpack-compose-explore/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Jetpack Compose 探索","name":"Jetpack Compose 探索","description":"Why compose Compose UI 的编写只需要 Kotlin，在遵循 Android 应用架构时，这样更有利于聚合 UI Elements 的代码，不需要去区分 Kotlin 代码和 xml 布局文件，在我看来这种方式更加容易采用 Android 架构指南去控制项目架构。\n但从另一方面来讲，Compose 这种嵌套的 UI 组合方式会加深代码层次，因此开发过程中需要对 UI 上各个元素做更细的区分，以增加代码的可读性。另外如果状态使用没有处理好，也会对 Compose 的重组性能带来影响。\n完善的声明式 UI Android View 系统设计的时候是遵循 OOP 的，虽然有 XML 可以帮我们减少下面这种命令式代码的使用，但这种声明式构建 + 命令式执行的缺点还是很明显，因为需要一个加载器把布局转化到业务逻辑代码中。\n// 命令式 val parent = ViewGroup(); val node = View(); parent.addView(node); 如果按照理想的声明式 UI 编写方式去改造传统 View 系统，那呈现出的代码可能会包括下面两个特点：\n节点的构建不应该有返回值 节点的连接不依赖于 API \u0026lt;LinearLayout\u0026gt; \u0026lt;TextView\u0026gt;Hello World\u0026lt;/TextView\u0026gt; \u0026lt;MaterialButton android:onCLick=\u0026#34;syaHi()\u0026#34;\u0026gt;hi\u0026lt;/MaterialButton\u0026gt; \u0026lt;/LinearLayout\u0026gt; 将上面的布局代码转换为 Java/Kotlin 理想的声明式代码\nLinearLayout { TextView(\u0026#34;Hello World\u0026#34;) MaterialButton(\u0026#34;Hi\u0026#34;) { syaHi() } } Compose 利用 Kotlin DSL 构建声明式 UI，一个 @Composable 相当于一个节点，在内部也可以调用其他 @Composable 函数构建子节点。","keywords":["Kotlin","Android","Jetpack Compose"],"articleBody":"Why compose Compose UI 的编写只需要 Kotlin，在遵循 Android 应用架构时，这样更有利于聚合 UI Elements 的代码，不需要去区分 Kotlin 代码和 xml 布局文件，在我看来这种方式更加容易采用 Android 架构指南去控制项目架构。\n但从另一方面来讲，Compose 这种嵌套的 UI 组合方式会加深代码层次，因此开发过程中需要对 UI 上各个元素做更细的区分，以增加代码的可读性。另外如果状态使用没有处理好，也会对 Compose 的重组性能带来影响。\n完善的声明式 UI Android View 系统设计的时候是遵循 OOP 的，虽然有 XML 可以帮我们减少下面这种命令式代码的使用，但这种声明式构建 + 命令式执行的缺点还是很明显，因为需要一个加载器把布局转化到业务逻辑代码中。\n// 命令式 val parent = ViewGroup(); val node = View(); parent.addView(node); 如果按照理想的声明式 UI 编写方式去改造传统 View 系统，那呈现出的代码可能会包括下面两个特点：\n节点的构建不应该有返回值 节点的连接不依赖于 API Hello World ","wordCount":"1171","inLanguage":"en","datePublished":"2022-07-08T00:00:00Z","dateModified":"2022-07-08T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://answerkobe.github.io/posts/jetpack-compose-explore/"},"publisher":{"@type":"Organization","name":"Iverson's blog","logo":{"@type":"ImageObject","url":"http://answerkobe.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://answerkobe.github.io/ accesskey=h title="Iverson's blog (Alt + H)">Iverson's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://answerkobe.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=http://answerkobe.github.io/tags title=Tags><span>Tags</span></a></li><li><a href=http://answerkobe.github.io/profile title=Profile-X><span>Profile-X</span></a></li><li><a href=http://answerkobe.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://answerkobe.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://answerkobe.github.io/posts/>Posts</a></div><h1 class=post-title>Jetpack Compose 探索</h1><div class=post-meta><span title='2022-07-08 00:00:00 +0000 UTC'>July 8, 2022</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#why-compose aria-label="Why compose">Why compose</a></li><li><a href=#%e5%ae%8c%e5%96%84%e7%9a%84%e5%a3%b0%e6%98%8e%e5%bc%8f-ui aria-label="完善的声明式 UI">完善的声明式 UI</a></li><li><a href=#%e8%8a%82%e7%82%b9%e4%b8%8e%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label=节点与作用域>节点与作用域</a><ul><li><a href=#slottable-%e5%92%8c-applier aria-label="SlotTable 和 Applier">SlotTable 和 Applier</a></li><li><a href=#%e5%bb%b6%e8%bf%9f%e6%89%a7%e8%a1%8c-slottable-%e7%9a%84%e6%9b%b4%e6%96%b0 aria-label="延迟执行 SlotTable 的更新">延迟执行 SlotTable 的更新</a></li><li><a href=#layoutnode-%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e6%8f%92%e5%85%a5 aria-label="LayoutNode 的创建和插入">LayoutNode 的创建和插入</a></li></ul></li><li><a href=#%e5%93%8d%e5%ba%94%e5%bc%8fui%e4%b8%8e%e5%bf%ab%e7%85%a7 aria-label=响应式UI与快照>响应式UI与快照</a><ul><li><a href=#%e5%85%a8%e5%b1%80%e5%bf%ab%e7%85%a7 aria-label=全局快照>全局快照</a></li><li><a href=#%e9%87%8d%e7%bb%84%e5%9c%a8%e5%bf%ab%e7%85%a7%e4%b8%ad%e6%89%a7%e8%a1%8c aria-label=重组在快照中执行>重组在快照中执行</a></li></ul></li><li><a href=#compose-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96 aria-label="Compose 性能优化">Compose 性能优化</a><ul><li><a href=#%e9%87%8d%e7%bb%84%e8%8c%83%e5%9b%b4%e6%9c%80%e5%b0%8f%e5%8c%96 aria-label=重组范围最小化>重组范围最小化</a></li><li><a href=#inline-%e5%87%bd%e6%95%b0%e4%b8%8d%e8%83%bd%e4%bd%9c%e4%b8%ba%e9%87%8d%e7%bb%84%e7%9a%84%e6%9c%80%e5%b0%8f%e8%8c%83%e5%9b%b4 aria-label="inline 函数不能作为重组的最小范围">inline 函数不能作为重组的最小范围</a></li><li><a href=#%e4%b8%8d%e5%81%9a%e5%a4%9a%e4%bd%99%e7%9a%84%e9%87%8d%e7%bb%84 aria-label=不做多余的重组>不做多余的重组</a></li><li><a href=#%e5%ae%98%e6%96%b9%e6%8f%90%e5%87%ba%e7%9a%84%e6%9c%80%e4%bd%b3%e5%81%9a%e6%b3%95 aria-label=官方提出的最佳做法>官方提出的最佳做法</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=why-compose>Why compose<a hidden class=anchor aria-hidden=true href=#why-compose>#</a></h2><p>Compose UI 的编写只需要 Kotlin，在遵循 Android 应用架构时，这样更有利于聚合 UI Elements 的代码，不需要去区分 Kotlin 代码和 xml 布局文件，在我看来这种方式更加容易采用 Android 架构指南去控制项目架构。</p><p>但从另一方面来讲，Compose 这种嵌套的 UI 组合方式会加深代码层次，因此开发过程中需要对 UI 上各个元素做更细的区分，以增加代码的可读性。另外如果状态使用没有处理好，也会对 Compose 的重组性能带来影响。</p><h2 id=完善的声明式-ui>完善的声明式 UI<a hidden class=anchor aria-hidden=true href=#完善的声明式-ui>#</a></h2><p>Android View 系统设计的时候是遵循 OOP 的，虽然有 XML 可以帮我们减少下面这种命令式代码的使用，但这种声明式构建 + 命令式执行的缺点还是很明显，因为需要一个加载器把布局转化到业务逻辑代码中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// 命令式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>val</span> parent = ViewGroup();
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> node = View();
</span></span><span style=display:flex><span>parent.addView(node);
</span></span></code></pre></div><p>如果按照理想的声明式 UI 编写方式去改造传统 View 系统，那呈现出的代码可能会包括下面两个特点：</p><ul><li>节点的构建不应该有返回值</li><li>节点的连接不依赖于 API</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;LinearLayout&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;TextView&gt;</span>Hello World<span style=color:#f92672>&lt;/TextView&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;MaterialButton</span> <span style=color:#a6e22e>android:onCLick=</span><span style=color:#e6db74>&#34;syaHi()&#34;</span><span style=color:#f92672>&gt;</span>hi<span style=color:#f92672>&lt;/MaterialButton&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/LinearLayout&gt;</span>
</span></span></code></pre></div><p>将上面的布局代码转换为 Java/Kotlin 理想的声明式代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>LinearLayout {
</span></span><span style=display:flex><span>    TextView(<span style=color:#e6db74>&#34;Hello World&#34;</span>)
</span></span><span style=display:flex><span>    MaterialButton(<span style=color:#e6db74>&#34;Hi&#34;</span>) {
</span></span><span style=display:flex><span>        syaHi()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Compose 利用 Kotlin DSL 构建声明式 UI，一个 <code>@Composable</code> 相当于一个节点，在内部也可以调用其他
<code>@Composable</code> 函数构建子节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Composable</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> text <span style=color:#66d9ef>by</span> remember { mutableStateOf(<span style=color:#ae81ff>1</span>) }
</span></span><span style=display:flex><span>    Button(onClick = { text <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> }) {
</span></span><span style=display:flex><span>        Text(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$text</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Button</span>()
</span></span></code></pre></div><p>Compose Compiler 与 Kotlin 的版本是绑定的，对应的版本对照表可以参考官方文档：
<a href="https://developer.android.com/jetpack/androidx/releases/compose-kotlin?hl=zh-cn">https://developer.android.com/jetpack/androidx/releases/compose-kotlin?hl=zh-cn</a></p><h2 id=节点与作用域>节点与作用域<a hidden class=anchor aria-hidden=true href=#节点与作用域>#</a></h2><p>Compose 中节点分两种：</p><ul><li>Group 代表一个组合范围，属于重组的最小单位，用于构建树的结构，识别结构的变化</li><li>LayoutNode 是最终组成渲染树的节点，可以完成测量布局绘制等渲染过程</li></ul><p>Group 的创建是在执行 <code>@Composable</code> 函数的过程中进行。<code>@Composable</code> 函数编译时，会在签名中会插入一个 <code>$composer</code> 参数，并调用该对象的方法，我们可以使用 jadx 对 <code>@Composable</code> 函数代码生成的字节码进行反编译。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 上面的 Foo 函数签名经过 compose.compiler 编译后会变成这样</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Foo1</span>(<span style=color:#a6e22e>@Nullable</span> Composer $composer, <span style=color:#66d9ef>int</span> $changed) {
</span></span><span style=display:flex><span>    Composer $composer2 <span style=color:#f92672>=</span> $composer.<span style=color:#a6e22e>startRestartGroup</span>(<span style=color:#f92672>-</span>1679608079);
</span></span><span style=display:flex><span>    ComposerKt.<span style=color:#a6e22e>sourceInformation</span>($composer2, <span style=color:#e6db74>&#34;C(Foo1)21@424L6:Foo.kt#a1gac0&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ($changed <span style=color:#f92672>!=</span> 0 <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>$composer2.<span style=color:#a6e22e>getSkipping</span>()) {
</span></span><span style=display:flex><span>        Foo2($composer2, 0);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        $composer2.<span style=color:#a6e22e>skipToGroupEnd</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ScopeUpdateScope endRestartGroup <span style=color:#f92672>=</span> $composer2.<span style=color:#a6e22e>endRestartGroup</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (endRestartGroup <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        endRestartGroup.<span style=color:#a6e22e>updateScope</span>(<span style=color:#66d9ef>new</span> Foo1.<span style=color:#a6e22e>1</span>($changed));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>参数中的 Composer 类似于上下文的东西，会贯穿 <code>@Composable</code> 函数的调用过程。Composer 大部分方法的调用，都是由 Compose 使用 KCP 解析 <code>@Composable</code> 注解对字节码进行修改时的结果。这一步由是 compose.compiler 完成，我们不应该自己创建 Composer 对象以及使用它的方法，不然可能会对 composition 过程造成影响。</p><h3 id=slottable-和-applier>SlotTable 和 Applier<a hidden class=anchor aria-hidden=true href=#slottable-和-applier>#</a></h3><p>Composer 在 Jetpack Compose 上实现类有一个 internal 的 ComposerImpl，它包含了两个操作节点的成员：</p><ul><li>Applier 负责 NodeLayout 操作，LayoutNode 树的根节点其实就包含在里面</li><li>SlotTable 负责存储 composition 过程的各种数据，包括 Group 和作用域对象，以及其他一些状态</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ComposerImpl</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>val</span> applier: Applier&lt;*&gt;,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> slotTable: SlotTable,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> changes: MutableList&lt;Change&gt;,
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>) : Composer
</span></span></code></pre></div><p>SlotTable 中包含两个数组。</p><ul><li>groups 存储 Group，Group 不以对象形式存在，在 groups 中每 5 数值代表一个 Group，其中偏移位为0的就是 startGroup 的时候传入的 key，一般由编译器生成</li><li>slots 用于存储相关的数据，包括作用域、内容体等</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// Group layout
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  0     | 1             | 2             | 3         | 4             |
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  Key   | Group info    | Parent anchor | Size      | Data anchor   |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SlotTable</span> : CompositionData, Iterable&lt;CompositionGroup&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> groups = IntArray(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> slots = Array&lt;Any?&gt;(<span style=color:#ae81ff>0</span>) { <span style=color:#66d9ef>null</span> }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Composer 调用 <code>startRestartGroup</code> 会传入编译生成的 Key，通过识别当前 Group 的 key 是否匹配，来判断是否需要对树结构进行更改。
如果是创建一个新的 Group 或者当前位置结构发生变化时，会创建一个作用域对象 <code>RecomposeScopeImpl</code> 对象存到 slots 里，当结束一个 Group 的执行后会调用作用域对象的 updateScope 注册 <code>@Composable</code> 函数体，当作用域进行重组时会重新执行注册的 <code>@Composable</code> 函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RecomposeScopeImpl</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> composition: CompositionImpl?
</span></span><span style=display:flex><span>) : ScopeUpdateScope, RecomposeScope {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ScopeUpdateScope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>updateScope</span>(block: (Composer, Int) <span style=color:#f92672>-&gt;</span> Unit)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// RecomposeScope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>invalidate</span>()   
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=延迟执行-slottable-的更新>延迟执行 SlotTable 的更新<a hidden class=anchor aria-hidden=true href=#延迟执行-slottable-的更新>#</a></h3><p>SlotTable 的读写需要通过 SlotReader 和 SlotWriter 来完成，为了保证操作时不会发生冲突，两者只能打开一个，并且对 SlotTable 会把对应的更新操作不会马上执行，而是记录到 Change 列表中延迟执行。
composition 过程会把步骤拆分为2个：</p><ol><li>计算和记录 SlotTable 的变化</li><li>应用 SlotTable 的修改并使用 Applier 对 LayoutNode 树做对应的更新</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// ComposerImpl
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> changes: MutableList&lt;Change&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>typealias</span> Change = (
</span></span><span style=display:flex><span>    applier: Applier&lt;*&gt;,
</span></span><span style=display:flex><span>    slots: SlotWriter,
</span></span><span style=display:flex><span>    rememberManager: RememberManager
</span></span><span style=display:flex><span>) <span style=color:#f92672>-&gt;</span> Unit
</span></span></code></pre></div><p>SlotTable 对 Group 的操作用了类似于 <a href=https://en.wikipedia.org/wiki/Gap_buffer>GapBuffer</a> 的数据结构来完成。</p><h3 id=layoutnode-的创建和插入>LayoutNode 的创建和插入<a hidden class=anchor aria-hidden=true href=#layoutnode-的创建和插入>#</a></h3><p>如果使用 androidx.compose.material 的组件会发生最终都是调用 <code>Layout()</code> 函数，<code>Layout()</code> 函数分两个主要的重载类型，一个有带 <code>content</code> 参数，一个没有，但里面会调用 <code>ReusableComposeNode()</code> 函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Composable</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Layout</span>(
</span></span><span style=display:flex><span>    modifier: Modifier = Modifier, <span style=color:#75715e>// 样式修饰和行为定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    measurePolicy: MeasurePolicy <span style=color:#75715e>// 定义布局的测量和布局行为
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;(
</span></span><span style=display:flex><span>      <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ReusableComposeNode</code> 就是将 LayoutNode 作为节点加到当前位置，节点的创建和复用也是由当前的 Composer 执行的。节点的创建是在回调中使用 <code>factory</code> 去创建，同样该回调也是在最后应用更改的时候执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Composable</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span> : <span style=color:#a6e22e>Any</span>, <span style=color:#66d9ef>reified</span> <span style=color:#a6e22e>E</span> : <span style=color:#a6e22e>Applier</span>&lt;*&gt;&gt; <span style=color:#a6e22e>ReusableComposeNode</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>noinline</span> factory: () <span style=color:#f92672>-&gt;</span> T, <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    update: <span style=color:#a6e22e>@DisallowComposableCalls</span> Updater&lt;T&gt;.() <span style=color:#f92672>-&gt;</span> Unit
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (currentComposer.applier <span style=color:#f92672>!is</span> E) invalidApplier()
</span></span><span style=display:flex><span>    currentComposer.startReusableNode()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果当前作用于进行的组合正在调度插入树的节点，例如第一次组合或者节点重组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (currentComposer.inserting) {
</span></span><span style=display:flex><span>        currentComposer.createNode { factory() }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        currentComposer.useNode()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    currentComposer.disableReusing()
</span></span><span style=display:flex><span>    Updater&lt;T&gt;(currentComposer).update()
</span></span><span style=display:flex><span>    currentComposer.enableReusing() <span style=color:#75715e>// 节点可复用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    currentComposer.endNode()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> Constructor: () <span style=color:#f92672>-&gt;</span> ComposeUiNode = <span style=color:#a6e22e>LayoutNode</span>.Constructor
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>val</span> Constructor: () <span style=color:#f92672>-&gt;</span> LayoutNode = { LayoutNode() }
</span></span></code></pre></div><p>NodeLayout 的节点操作都是交给 Applier 处理，AbstractApplier 中会存着 LayoutNode 树的根节点。
Applier 对节点的插入方式由两种，两种方式插入性能和节点的通知有关，具体可以看看源码的注释。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AbstractApplier</span>&lt;T&gt;(<span style=color:#66d9ef>val</span> root: T) : Applier&lt;T&gt;
</span></span><span style=display:flex><span><span style=color:#75715e>// 节点插入操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>insertTopDown</span>(index: Int, instance: N)
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>insertBottomUp</span>(index: Int, instance: N)
</span></span></code></pre></div><h2 id=响应式ui与快照>响应式UI与快照<a hidden class=anchor aria-hidden=true href=#响应式ui与快照>#</a></h2><p>在 Compose 中，当 State 发生变化时，会自动进行重组，更新依赖了该 State 的 <code>@Composable</code> 函数的这种响应式布局本质也是基于观察订阅，但不需要开发者自己去做订阅和反订阅这些事情，而是交给 Snapshot 完成。Snapshot 相当于给当前程序的 State 拍个照做个记录，因此称为<strong>快照</strong>。
快照内部对 State 值的读取和修改，会触发 <code>readobserver</code> 和 <code>writeObserver</code> 回调，在快照内修改 State 的值不会影响到外部状态。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> state = mutableStateOf(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 拍照
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>val</span> snapshot = <span style=color:#a6e22e>Snapshot</span>.takeMutableSnapshot (
</span></span><span style=display:flex><span>    readObserver = { println(<span style=color:#e6db74>&#34;read&#34;</span>) },
</span></span><span style=display:flex><span>    writeObserver = { println(<span style=color:#e6db74>&#34;write&#34;</span>) }
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>snapshot.enter {
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;enter state: </span><span style=color:#e6db74>${state.value}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    state.<span style=color:#66d9ef>value</span> = <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>println(<span style=color:#e6db74>&#34;outer state: </span><span style=color:#e6db74>${state.value}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>snapshot.apply()
</span></span><span style=display:flex><span>println(<span style=color:#e6db74>&#34;apply state: </span><span style=color:#e6db74>${state.value}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 打印
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>read
</span></span><span style=display:flex><span>enter state: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>write
</span></span><span style=display:flex><span>outer state: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>apply state: <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p><code>mutableStateOf()</code>返回的本质是一个 <code>SnapshotMutableStateImpl</code> 对象，它的 value 值都是交给
<code>StateStateRecord</code> 去维护。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>override</span> <span style=color:#66d9ef>var</span> value: T
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>get</span>() = next.readable(<span style=color:#66d9ef>this</span>).<span style=color:#66d9ef>value</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>set</span>(<span style=color:#66d9ef>value</span>) = next.withCurrent {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!policy.equivalent(<span style=color:#66d9ef>it</span>.<span style=color:#66d9ef>value</span>, <span style=color:#66d9ef>value</span>)) {
</span></span><span style=display:flex><span>            next.overwritable(<span style=color:#66d9ef>this</span>, <span style=color:#66d9ef>it</span>) { <span style=color:#66d9ef>this</span>.<span style=color:#66d9ef>value</span> = <span style=color:#66d9ef>value</span> }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> next: StateStateRecord&lt;T&gt; = StateStateRecord(<span style=color:#66d9ef>value</span>)
</span></span></code></pre></div><p>当修改或读取 State 的值时，会获取当前的快照，并通知当前的 Snapshot 触发相关回调。</p><ul><li>Compose 读取 State 时会记录依赖了此状态的作用域</li><li>当 State 被修改时，会将依赖了该状态的作用域标记为 <code>invalid</code>，在重组的时候会重新执行这些作用域的组合函数</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span> : <span style=color:#a6e22e>StateRecord</span>, <span style=color:#a6e22e>R</span>&gt; <span style=color:#a6e22e>T</span>.overwritable(
</span></span><span style=display:flex><span>    state: StateObject,
</span></span><span style=display:flex><span>    candidate: T,
</span></span><span style=display:flex><span>    block: <span style=color:#a6e22e>T</span>.() <span style=color:#f92672>-&gt;</span> R
</span></span><span style=display:flex><span>): R {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> snapshot: Snapshot = snapshotInitializer
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sync {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取当前线程快照/全局快照
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        snapshot = <span style=color:#a6e22e>Snapshot</span>.current
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.overwritableRecord(state, snapshot, candidate).block()
</span></span><span style=display:flex><span>    }.also {
</span></span><span style=display:flex><span>        notifyWrite(snapshot, state)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@PublishedApi</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>notifyWrite</span>(snapshot: Snapshot, state: StateObject) {
</span></span><span style=display:flex><span>    snapshot.writeObserver<span style=color:#f92672>?.</span>invoke(state)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=全局快照>全局快照<a hidden class=anchor aria-hidden=true href=#全局快照>#</a></h3><p>UI 的变化通常是在主线程，如果更新 State 的操作是在其它线程，那么获取到的当前快照将会是全局快照 GlobalSnapShot。
全局快照会在启动的时候就注册一个回调，通过 Kotlin 协程的 Channel 发送消息，这个消息的处理会切到主线程中进行，并 <code>applyObservers</code> 中的回调，其中有一个回调会执行<code>performRecompose()</code>执行重组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> applyObservers = mutableListOf&lt;(Set&lt;Any&gt;, Snapshot) <span style=color:#f92672>-&gt;</span> Unit&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>GlobalSnapshotManager</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> started = AtomicBoolean(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ensureStarted</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (started.compareAndSet(<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> channel = Channel&lt;Unit&gt;(<span style=color:#a6e22e>Channel</span>.CONFLATED)
</span></span><span style=display:flex><span>            CoroutineScope(<span style=color:#a6e22e>AndroidUiDispatcher</span>.Main).launch {
</span></span><span style=display:flex><span>                channel.consumeEach {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>Snapshot</span>.sendApplyNotifications()
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Snapshot</span>.registerGlobalWriteObserver {
</span></span><span style=display:flex><span>                channel.trySend(Unit)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=重组在快照中执行>重组在快照中执行<a hidden class=anchor aria-hidden=true href=#重组在快照中执行>#</a></h3><p>进行重组时会先拍一次快照，再让重组过程在快照中执行，此时在快照中 <code>@Composable</code> 函数中读取 State 的值时会触发读观察者，把 State 和当前的作用域绑定起来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>performRecompose</span>(<span style=color:#f92672>..</span>.){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>        composing(composition, modifiedValues) {
</span></span><span style=display:flex><span>            composition.recompose()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    ) composition <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span>&gt; <span style=color:#a6e22e>composing</span>(<span style=color:#f92672>..</span>.): T {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> snapshot = <span style=color:#a6e22e>Snapshot</span>.takeMutableSnapshot(
</span></span><span style=display:flex><span>        readObserverOf(composition), writeObserverOf(composition, modifiedValues)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> snapshot.enter(block)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        applyAndCheck(snapshot)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>applyObservers</code> 是一个静态变量，当主线程的 MutableSnapshot 触发写入通知的时候也会触发里面的回调进行重组。在 composition 是写入不会马上就通过写观察者进行重组，而是在 composition 过程结束后，apply 后再进行重组。</p><h2 id=compose-性能优化>Compose 性能优化<a hidden class=anchor aria-hidden=true href=#compose-性能优化>#</a></h2><p>Compose 在更新帧的时候要经过3个阶段：</p><ul><li><strong>组合</strong>：Compose 确定<strong>要显示的内容</strong> - 运行可组合函数并构建界面树。</li><li><strong>布局</strong>：Compose 确定界面树中每个元素的<strong>尺寸和位置</strong>。</li><li><strong>绘图</strong>：Compose 实际<strong>渲染</strong>各个界面元素。</li></ul><p>Compose 对这些阶段做了许多优化，例如在组合阶段使用 SoltTable 记录树结构，通过 diff 树结构的变化来更新 LayotNode 节点，还使用 RecomposeScope 作用域标记修改状态。在布局阶段使用了固有特性测量来解决布局嵌套问题。</p><h3 id=重组范围最小化>重组范围最小化<a hidden class=anchor aria-hidden=true href=#重组范围最小化>#</a></h3><p>开头说过，Compose 中编写代码要尽量控制组件的细度，过多的嵌套调用这不会影响 Compose 测量效率（），但如果不控制好组件的细度，导致 Group 的范围过大，可能会影响重组效率。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Composable</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Foo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> text <span style=color:#66d9ef>by</span> remember { mutableStateOf(<span style=color:#ae81ff>1</span>) }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Foo&#34;</span>)
</span></span><span style=display:flex><span>    Button(
</span></span><span style=display:flex><span>        onClick = { text <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> }
</span></span><span style=display:flex><span>    ).also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Button&#34;</span>) }) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Button content lambda&#34;</span>)
</span></span><span style=display:flex><span>        Text(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$text</span><span style=color:#e6db74>&#34;</span>).also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Text&#34;</span>) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>回到前面的例子，如果点击按钮改变状态，会发现发生重组的实际上是整个 Botton 内容体的 Lambda 表达式，如果在 Lambda 表达式中存在其它的组件，那么也会跟着重组。
如果不希望 Text 对状态的依赖影响到同级的其他 <code>@Composable</code> 组件，那么可以套一层非 inline 的函数。例如下面的例子，状态变化时，重组的就只有依赖了状态的 Text 了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>RecomposeFoo</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> text <span style=color:#66d9ef>by</span> remember { mutableStateOf(<span style=color:#ae81ff>0</span>) }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Foo&#34;</span>)
</span></span><span style=display:flex><span>    Button(onClick = {
</span></span><span style=display:flex><span>        text <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    }.also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Button&#34;</span>) }) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Button content lambda&#34;</span>)
</span></span><span style=display:flex><span>        ChangeableText {
</span></span><span style=display:flex><span>            Text(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$text</span><span style=color:#e6db74>&#34;</span>).also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Text&#34;</span>) } <span style=color:#75715e>// recompose
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }.also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;ChangeableText call&#34;</span>) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>ChangeableText</span>(content: <span style=color:#a6e22e>@Composable</span> () <span style=color:#f92672>-&gt;</span> Unit) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;ChangeableText content&#34;</span>)
</span></span><span style=display:flex><span>    content()
</span></span><span style=display:flex><span>    Text(text = <span style=color:#e6db74>&#34;Hi&#34;</span>).also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Hi&#34;</span>) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=inline-函数不能作为重组的最小范围>inline 函数不能作为重组的最小范围<a hidden class=anchor aria-hidden=true href=#inline-函数不能作为重组的最小范围>#</a></h3><p>由于 inline 函数的特点，会共享调用方的 Group，因此 inline 函数不能作为组合的最小范围。
例如 <code>Column</code>、<code>Row</code>、<code>Box</code> 以及 <code>Layout</code> 这些容器类。
当然如果希望缩小范围提高性能，同样可以套一层非 inline 函数来缩小 Group 的范围。</p><h3 id=不做多余的重组>不做多余的重组<a hidden class=anchor aria-hidden=true href=#不做多余的重组>#</a></h3><p>上面提到了，重组过程只会对 <code>invalid</code> 的作用域做重组。
例如下面的代码，当 num 发生变化时，Foo1 的内容会进行重组，Foo2 会被调用，但由于编译时 Foo2 的代码插入了 Group 的逻辑， Foo2 中的 Group 和作用域并没有发生修改，因此里面的内容并不会执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Foo1</span>(num: MutableState&lt;Int&gt;) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Foo1 content&#34;</span>)
</span></span><span style=display:flex><span>    Text(text = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${num.value}</span><span style=color:#e6db74>&#34;</span>).also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Text&#34;</span>) }
</span></span><span style=display:flex><span>    Foo2().also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;call Foo2&#34;</span>) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Foo2</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Foo2 content&#34;</span>)
</span></span><span style=display:flex><span>    Text(text = <span style=color:#e6db74>&#34;End&#34;</span>).also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;End&#34;</span>) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Foo1 content
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Text
</span></span></span><span style=display:flex><span><span style=color:#75715e>// call Foo2
</span></span></span></code></pre></div><p>但如果 Foo2 的有一个 <code>Int</code> 类型的参数，并且由 Foo1 读取后传入，那么Foo1和Foo2将会一起参与重组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Foo1</span>(num: MutableState&lt;Int&gt;) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Foo1 content&#34;</span>)
</span></span><span style=display:flex><span>    Foo2(num.<span style=color:#66d9ef>value</span>).also {  <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;call Foo2&#34;</span>) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Foo2</span>(num: Int) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Foo2 content&#34;</span>)
</span></span><span style=display:flex><span>    Text(text = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>$num</span><span style=color:#e6db74>&#34;</span>).also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Text&#34;</span>) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Foo1 content
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Foo2 content
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Text
</span></span></span><span style=display:flex><span><span style=color:#75715e>// call Foo2
</span></span></span></code></pre></div><p>因此我们需要做状态的延迟读取，以缩小读取状态的 Group 范围，避免不必要的重组参与。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Foo1</span>(num: MutableState&lt;Int&gt;) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Foo1 content&#34;</span>)
</span></span><span style=display:flex><span>    Foo2 { num.<span style=color:#66d9ef>value</span> }.also {  <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;call Foo2&#34;</span>) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Composable</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>Foo2</span>(num: () <span style=color:#f92672>-&gt;</span> Int) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Foo2 content&#34;</span>)
</span></span><span style=display:flex><span>    Text(text = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${num()}</span><span style=color:#e6db74>&#34;</span>).also { <span style=color:#a6e22e>Log</span>.d(TAG, <span style=color:#e6db74>&#34;Text&#34;</span>) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Foo2 content
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Text
</span></span></span></code></pre></div><h3 id=官方提出的最佳做法>官方提出的最佳做法<a hidden class=anchor aria-hidden=true href=#官方提出的最佳做法>#</a></h3><p>官方在性能优化的一文中也提出了开发过程中的5个最佳做法
<a href=https://developer.android.com/jetpack/compose/performance#use-remember>https://developer.android.com/jetpack/compose/performance#use-remember</a></p><ol><li>尽可能从组合函数中移除计算，或使用 remember 记住计算结果，降低计算开销</li><li>使用延迟布局 Key</li><li>使用 derivedStaeOf 限制重组</li><li>尽可能延迟读取</li><li>避免向后写入</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=http://answerkobe.github.io/tags/kotlin/>Kotlin</a></li><li><a href=http://answerkobe.github.io/tags/android/>Android</a></li><li><a href=http://answerkobe.github.io/tags/jetpack-compose/>Jetpack Compose</a></li></ul><nav class=paginav><a class=prev href=http://answerkobe.github.io/posts/design-pattern/><span class=title>« Prev</span><br><span>Java设计模式</span>
</a><a class=next href=http://answerkobe.github.io/posts/analysis-flutter-paint-process/><span class=title>Next »</span><br><span>Flutter 绘制流程分析与代码实践</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Jetpack Compose 探索 on x" href="https://x.com/intent/tweet/?text=Jetpack%20Compose%20%e6%8e%a2%e7%b4%a2&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fjetpack-compose-explore%2f&amp;hashtags=Kotlin%2cAndroid%2cJetpackCompose"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Jetpack Compose 探索 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fjetpack-compose-explore%2f&amp;title=Jetpack%20Compose%20%e6%8e%a2%e7%b4%a2&amp;summary=Jetpack%20Compose%20%e6%8e%a2%e7%b4%a2&amp;source=http%3a%2f%2fanswerkobe.github.io%2fposts%2fjetpack-compose-explore%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Jetpack Compose 探索 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fjetpack-compose-explore%2f&title=Jetpack%20Compose%20%e6%8e%a2%e7%b4%a2"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Jetpack Compose 探索 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fjetpack-compose-explore%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Jetpack Compose 探索 on whatsapp" href="https://api.whatsapp.com/send?text=Jetpack%20Compose%20%e6%8e%a2%e7%b4%a2%20-%20http%3a%2f%2fanswerkobe.github.io%2fposts%2fjetpack-compose-explore%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Jetpack Compose 探索 on telegram" href="https://telegram.me/share/url?text=Jetpack%20Compose%20%e6%8e%a2%e7%b4%a2&amp;url=http%3a%2f%2fanswerkobe.github.io%2fposts%2fjetpack-compose-explore%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Jetpack Compose 探索 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Jetpack%20Compose%20%e6%8e%a2%e7%b4%a2&u=http%3a%2f%2fanswerkobe.github.io%2fposts%2fjetpack-compose-explore%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script id=utteranc src=https://utteranc.es/client.js repo=Answerkobe/utterances issue-term=pathname theme=github-light crossorigin=anonymous async></script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.body.className.includes("dark")?"github-light":"photon-dark",t={type:"set-theme",theme:e},n=document.querySelector(".utterances-frame");n.contentWindow.postMessage(t,"https://utteranc.es")})</script></article></main><footer class=footer><span>&copy; 2023 <a href=http://answerkobe.github.io/>Iverson's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>